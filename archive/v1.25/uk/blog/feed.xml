<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Istio Blog</title><description>Blog posts from the Istio service mesh.</description><link>/v1.25/</link><image><title>Istio Blog</title><url>/v1.25//favicons/android-192x192.png</url><link>/v1.25/</link></image><category>Service mesh</category><item><title>Авторизація на основі політик за допомогою Kyverno</title><description><![CDATA[<p>Istio підтримує інтеграцію з багатьма різними проєктами. Нещодавно в блозі Istio була опублікована стаття про <a href="../l7-policy-with-opa">функціональність політик L7 з OpenPolicyAgent</a>. Kyverno є подібним проєктом, і сьогодні ми розглянемо, як Istio та сервер авторизації Kyverno можуть використовуватися разом для забезпечення політик Layer 7 у вашій платформі.</p>
<p>Ми покажемо вам, як почати роботу з простого прикладу. Ви побачите, як це поєднання є надійним варіантом для швидкого та прозорого впровадження політик для команд розробників у всій організації, одночасно надаючи дані, необхідні командам безпеки для аудиту та відповідності вимогам.</p>
<h2 id="try-it-out">Спробуймо</h2>
<p>При інтеграції з Istio, сервер авторизації Kyverno можна використовувати для забезпечення детального контролю доступу до мікросервісів.</p>
<p>Цей посібник показує, як застосовувати політики контролю доступу для простого мікросервісного застосунку.</p>
<h3 id="prerequisites">Передумови</h3>
<ul>
<li>Кластер Kubernetes з встановленим Istio.</li>
<li>Встановлений інструмент командного рядка <code>istioctl</code>.</li>
</ul>
<p>Встановіть Istio та налаштуйте ваші <a href="/docs/reference/config/istio.mesh.v1alpha1/">параметри мережі</a> для активації Kyverno:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl install -y -f - &lt;&lt;EOF
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    accessLogFile: /dev/stdout
    accessLogFormat: |
      [KYVERNO DEMO] my-new-dynamic-metadata: &#39;%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%&#39;
    extensionProviders:
    - name: kyverno-authz-server
      envoyExtAuthzGrpc:
        service: kyverno-authz-server.kyverno.svc.cluster.local
        port: &#39;9081&#39;
EOF</code></pre>
<p>Зверніть увагу, що в конфігурації ми визначаємо розділ <code>extensionProviders</code>, який вказує на встановлення сервера авторизації Kyverno:</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
    extensionProviders:
    - name: kyverno-authz-server
      envoyExtAuthzGrpc:
        service: kyverno-authz-server.kyverno.svc.cluster.local
        port: &#39;9081&#39;
[...]</code></pre>
<h4 id="deploy-the-kyverno-authz-server">Розгортання сервера авторизації Kyverno</h4>
<p>Сервер авторизації Kyverno — це GRPC сервер, здатний обробляти запити зовнішньої авторизації Envoy.</p>
<p>Його можна налаштувати за допомогою ресурсів <code>AuthorizationPolicy</code> Kyverno, які зберігаються в кластері або надаються ззовні.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl create ns kyverno
$ kubectl label namespace kyverno istio-injection=enabled
$ helm install kyverno-authz-server --namespace kyverno --wait --version 0.1.0 --repo https://kyverno.github.io/kyverno-envoy-plugin kyverno-authz-server</code></pre>
<h4 id="deploy-the-sample-application">Розгортання демонстраційного застосунку</h4>
<p>httpbin — це добре відомий застосунок, який можна використовувати для тестування HTTP-запитів і який допомагає швидко показати, як ми можемо працювати з атрибутами запиту та відповіді.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl create ns my-app
$ kubectl label namespace my-app istio-injection=enabled
$ kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.25/samples/httpbin/httpbin.yaml -n my-app</code></pre>
<h4 id="deploy-an-istio-authorization-policy">Розгортання Istio AuthorizationPolicy</h4>
<p><code>AuthorizationPolicy</code> визначає сервіси, які будуть захищені сервером авторизації Kyverno.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: my-kyverno-authz
  namespace: istio-system # Це застосовує політику на всю мережу, istio-system буде кореневим простором імен мережі
spec:
  selector:
    matchLabels:
      ext-authz: enabled
  action: CUSTOM
  provider:
    name: kyverno-authz-server
  rules: [{}] # Порожні правила, буде застосовано до селекторів з міткою ext-authz: enabled
EOF</code></pre>
<p>Зверніть увагу, що в цьому ресурсі ми визначаємо <code>extensionProvider</code> Kyverno Authz Server, який ви встановили в конфігурації Istio:</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
  provider:
    name: kyverno-authz-server
[...]</code></pre>
<h4 id="add-the-label-to-enforce-the-policy">Додавання мітки до застосунку для застосування політики</h4>
<p>Додамо мітку до застосунку для застосування політики. Мітка потрібна для того, щоб політика авторизації Istio застосовувалася до podʼів демонстраційного застосунку.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl patch deploy httpbin -n my-app --type=merge -p=&#39;{
  &#34;spec&#34;: {
    &#34;template&#34;: {
      &#34;metadata&#34;: {
        &#34;labels&#34;: {
          &#34;ext-authz&#34;: &#34;enabled&#34;
        }
      }
    }
  }
}&#39;</code></pre>
<h4 id="deploy-a-kyverno-authorizationpolicy">Розгортання Kyverno AuthorizationPolicy</h4>
<p>Політика авторизації Kyverno <code>AuthorizationPolicy</code> визначає правила, які використовуються сервером авторизації Kyverno для прийняття рішення на основі наданого Envoy <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/external_auth.proto#service-auth-v3-checkrequest">CheckRequest</a>.</p>
<p>Вона використовує мову <a href="https://github.com/google/cel-spec">CEL</a> для аналізу вхідного <code>CheckRequest</code> і повинна створити <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/external_auth.proto#service-auth-v3-checkresponse">CheckResponse</a> у відповідь.</p>
<p>Вхідний запит доступний у полі <code>object</code>, і політика може визначати <code>variables</code>, які будуть доступні для всіх <code>authorizations</code>.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: envoy.kyverno.io/v1alpha1
kind: AuthorizationPolicy
metadata:
  name: demo-policy.example.com
spec:
  failurePolicy: Fail
  variables:
  - name: force_authorized
    expression: object.attributes.request.http.?headers[&#34;x-force-authorized&#34;].orValue(&#34;&#34;)
  - name: allowed
    expression: variables.force_authorized in [&#34;enabled&#34;, &#34;true&#34;]
  authorizations:
  - expression: &gt;
      variables.allowed
        ? envoy.Allowed().Response()
        : envoy.Denied(403).Response()
EOF</code></pre>
<p>Зверніть увагу, що ви можете створити <code>CheckResponse</code> вручну або використовувати <a href="https://kyverno.github.io/kyverno-envoy-plugin/latest/cel-extensions/">допоміжні функції CEL</a> як <code>envoy.Allowed()</code> та <code>envoy.Denied(403)</code>, щоб спростити створення повідомлення відповіді:</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
  - expression: &gt;
      variables.allowed
        ? envoy.Allowed().Response()
        : envoy.Denied(403).Response()
[...]</code></pre>
<h2 id="how-it-works">Як це працює</h2>
<p>При застосуванні <code>AuthorizationPolicy</code>, панель управління Istio (istiod) надсилає необхідні конфігурації до проксі-сервера sidecar (Envoy) вибраних сервісів у політиці. Envoy потім надсилає запит до сервера авторизації Kyverno, щоб перевірити, чи дозволено запит, чи ні.</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:56.25%">
        <a data-skipendnotes="true" href="/uk/blog/2024/authz-policy-with-kyverno/overview.svg" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/authz-policy-with-kyverno/overview.svg" alt="Istio та сервер авторизації Kyverno" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Проксі-сервер Envoy працює, налаштовуючи фільтри в ланцюжку. Один з цих фільтрів — <code>ext_authz</code>, який реалізує зовнішню службу авторизації зі конкретним повідомленням. Будь-який сервер, що реалізує правильний protobuf, може підʼєднатися до проксі-сервера Envoy і надати рішення щодо авторизації; сервер авторизації Kyverno є одним з таких серверів.</p>
<figure style="width:100%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:56.25%">
        <a data-skipendnotes="true" href="/uk/blog/2024/authz-policy-with-kyverno/filters-chain.svg" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/authz-policy-with-kyverno/filters-chain.svg" alt="Фільтри" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Ознайомившись з <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/external_auth.proto">документацією служби авторизації Envoy</a>, ви побачите, що повідомлення має такі атрибути:</p>
<ul>
<li>
<p>Відповідь Ok</p>
<pre><code class='language-json' data-expandlinks='true' data-repo='istio' >{
  &#34;status&#34;: {...},
  &#34;ok_response&#34;: {
    &#34;headers&#34;: [],
    &#34;headers_to_remove&#34;: [],
    &#34;response_headers_to_add&#34;: [],
    &#34;query_parameters_to_set&#34;: [],
    &#34;query_parameters_to_remove&#34;: []
  },
  &#34;dynamic_metadata&#34;: {...}
}</code></pre>
</li>
<li>
<p>Відповідь Denied</p>
<pre><code class='language-json' data-expandlinks='true' data-repo='istio' >{
  &#34;status&#34;: {...},
  &#34;denied_response&#34;: {
    &#34;status&#34;: {...},
    &#34;headers&#34;: [],
    &#34;body&#34;: &#34;...&#34;
  },
  &#34;dynamic_metadata&#34;: {...}
}</code></pre>
</li>
</ul>
<p>Це означає, що на основі відповіді від сервера авторизації Envoy може додавати або видаляти заголовки, параметри запиту і навіть змінювати тіло відповіді.</p>
<p>Ми також можемо це зробити, як задокументовано в <a href="https://kyverno.github.io/kyverno-envoy-plugin">документації сервера авторизації Kyverno</a>.</p>
<h2 id="testing">Тестування</h2>
<p>Протестуймо просте використання (авторизація), а потім створимо складнішу політику, щоб показати, як ми можемо використовувати сервер авторизації Kyverno для зміни запиту та відповіді.</p>
<p>Розгорніть застосунок для виконання команд curl до демонстраційного застосунку httpbin:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -n my-app -f https://raw.githubusercontent.com/istio/istio/release-1.25/samples/curl/curl.yaml</code></pre>
<p>Застосуйте політику:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: envoy.kyverno.io/v1alpha1
kind: AuthorizationPolicy
metadata:
  name: demo-policy.example.com
spec:
  failurePolicy: Fail
  variables:
  - name: force_authorized
    expression: object.attributes.request.http.?headers[&#34;x-force-authorized&#34;].orValue(&#34;&#34;)
  - name: allowed
    expression: variables.force_authorized in [&#34;enabled&#34;, &#34;true&#34;]
  authorizations:
  - expression: &gt;
      variables.allowed
        ? envoy.Allowed().Response()
        : envoy.Denied(403).Response()
EOF</code></pre>
<p>Простий сценарій полягає в тому, щоб дозволити запити, якщо вони містять заголовок <code>x-force-authorized</code> зі значенням <code>enabled</code> або <code>true</code>. Якщо заголовок відсутній або має інше значення, запит буде відхилено.</p>
<p>У цьому випадку ми поєднали обробку дозволених і відхилених відповідей в одному виразі. Однак можна використовувати кілька виразів, перший з яких повертає ненульову відповідь, буде використаний сервером авторизації Kyverno, це корисно, коли правило не хоче приймати рішення і делегує наступному правилу:</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
  authorizations:
  # дозволити запит, коли значення заголовка збігається
  - expression: &gt;
      variables.allowed
        ? envoy.Allowed().Response()
        : null
  # інакше відхилити запит
  - expression: &gt;
      envoy.Denied(403).Response()
[...]</code></pre>
<h3 id="simple-rules">Прості правила</h3>
<p>Наступний запит поверне <code>403</code>:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get</code></pre>
<p>Наступний запит поверне <code>200</code>:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get -H &#34;x-force-authorized: true&#34;</code></pre>
<h3 id="advanced-manipulations">Складніші маніпуляції</h3>
<p>Тепер складніший випадок використання, застосуйте другу політику:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: envoy.kyverno.io/v1alpha1
kind: AuthorizationPolicy
metadata:
  name: demo-policy.example.com
spec:
  variables:
  - name: force_authorized
    expression: object.attributes.request.http.headers[?&#34;x-force-authorized&#34;].orValue(&#34;&#34;) in [&#34;enabled&#34;, &#34;true&#34;]
  - name: force_unauthenticated
    expression: object.attributes.request.http.headers[?&#34;x-force-unauthenticated&#34;].orValue(&#34;&#34;) in [&#34;enabled&#34;, &#34;true&#34;]
  - name: metadata
    expression: &#39;{&#34;my-new-metadata&#34;: &#34;my-new-value&#34;}&#39;
  authorizations:
    # якщо force_unauthenticated -&gt; 401
  - expression: &gt;
      variables.force_unauthenticated
        ? envoy
            .Denied(401)
            .WithBody(&#34;Authentication Failed&#34;)
            .Response()
        : null
    # якщо force_authorized -&gt; 200
  - expression: &gt;
      variables.force_authorized
        ? envoy
            .Allowed()
            .WithHeader(&#34;x-validated-by&#34;, &#34;my-security-checkpoint&#34;)
            .WithoutHeader(&#34;x-force-authorized&#34;)
            .WithResponseHeader(&#34;x-add-custom-response-header&#34;, &#34;added&#34;)
            .Response()
            .WithMetadata(variables.metadata)
        : null
    # інакше -&gt; 403
  - expression: &gt;
      envoy
        .Denied(403)
        .WithBody(&#34;Unauthorized Request&#34;)
        .Response()
EOF</code></pre>
<p>У цій політиці ви можете побачити:</p>
<ul>
<li>Якщо запит має заголовок <code>x-force-unauthenticated: true</code> (або <code>x-force-unauthenticated: enabled</code>), ми повернемо <code>401</code> з тілом &ldquo;Authentication Failed&rdquo;</li>
<li>Інакше, якщо запит має заголовок <code>x-force-authorized: true</code> (або <code>x-force-authorized: enabled</code>), ми повернемо <code>200</code> і маніпулюватимемо заголовками запиту, заголовками відповіді та вставлятимемо динамічні метадані</li>
<li>У всіх інших випадках ми повернемо <code>403</code> з тілом &ldquo;Unauthorized Request&rdquo;</li>
</ul>
<p>Відповідний CheckResponse буде повернуто до проксі-сервера Envoy від сервера авторизації Kyverno. Envoy використовуватиме ці значення для зміни запиту та відповіді відповідно.</p>
<h4 id="changing-returned-body">Зміна тіла відповіді</h4>
<p>Протестуймо нові можливості:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get</code></pre>
<p>Тепер ми можемо змінити тіло відповіді.</p>
<p>З <code>403</code> тіло буде змінено на &ldquo;Unauthorized Request&rdquo;, виконавши попередню команду, ви повинні отримати:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >Unauthorized Request
http_code=403</code></pre>
<h4 id="change-returned-body-and-status-code">Зміна тіла відповіді та коду статусу</h4>
<p>Виконання запиту з заголовком <code>x-force-unauthenticated: true</code>:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get -H &#34;x-force-unauthenticated: true&#34;</code></pre>
<p>Цього разу ви повинні отримати тіло &ldquo;Authentication Failed&rdquo; та помилку <code>401</code>:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >Authentication Failed
http_code=401</code></pre>
<h4 id="adding-headers-to-request">Додавання заголовків до запиту</h4>
<p>Виконання валідного запиту:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get -H &#34;x-force-authorized: true&#34;</code></pre>
<p>Ви повинні отримати тіло з новим заголовком <code>x-validated-by: my-security-checkpoint</code> і видаленим заголовком <code>x-force-authorized</code>:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >[...]
    &#34;X-Validated-By&#34;: [
      &#34;my-security-checkpoint&#34;
    ]
[...]
http_code=200</code></pre>
<h4 id="adding-headers-to-response">Додавання заголовків до відповіді</h4>
<p>Виконання того ж запиту, але показуючи лише заголовок:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -I -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get -H &#34;x-force-authorized: true&#34;</code></pre>
<p>Ви знайдете заголовок відповіді, доданий під час перевірки авторизації <code>x-add-custom-response-header: added</code>:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >HTTP/1.1 200 OK
[...]
x-add-custom-response-header: added
[...]
http_code=200</code></pre>
<h3 id="sharing-data-between-filters">Обмін даними між фільтрами</h3>
<p>Нарешті, ви можете передавати дані наступним фільтрам Envoy, використовуючи <code>dynamic_metadata</code>.</p>
<p>Це корисно, коли ви хочете передати дані іншому фільтру <code>ext_authz</code> у ланцюжку або хочете надрукувати їх у журналах застосунку.</p>
<figure style="width:100%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:56.25%">
        <a data-skipendnotes="true" href="/uk/blog/2024/authz-policy-with-kyverno/dynamic-metadata.svg" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/authz-policy-with-kyverno/dynamic-metadata.svg" alt="Метадані" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Для цього перегляньте формат журналу доступу, який ви встановили раніше:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >[...]
    accessLogFormat: |
      [KYVERNO DEMO] my-new-dynamic-metadata: &#34;%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%&#34;
[...]</code></pre>
<p><code>DYNAMIC_METADATA</code> — це зарезервоване ключове слово для доступу до обʼєкта метаданих. Решта — це назва фільтра, до якого ви хочете отримати доступ.</p>
<p>У нашому випадку назва <code>envoy.filters.http.ext_authz</code> створюється автоматично Istio. Ви можете перевірити це, зробивши дамп конфігурації Envoy:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl pc all deploy/httpbin -n my-app -oyaml | grep envoy.filters.http.ext_authz</code></pre>
<p>Ви побачите конфігурації для фільтра.</p>
<p>Тепер протестуємо динамічні метадані. У розширеному правилі ми створюємо новий запис метаданих: <code>{&quot;my-new-metadata&quot;: &quot;my-new-value&quot;}</code>.</p>
<p>Виконайте запит і перевірте журнали застосунку:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app deploy/curl -- curl -s -I httpbin:8000/get -H &#34;x-force-authorized: true&#34;</code></pre>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs -n my-app deploy/httpbin -c istio-proxy --tail 1</code></pre>
<p>Ви побачите у вихідних даних нові атрибути, налаштовані політикою Kyverno:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >[...]
[KYVERNO DEMO] my-new-dynamic-metadata: &#39;{&#34;my-new-metadata&#34;:&#34;my-new-value&#34;,&#34;ext_authz_duration&#34;:5}&#39;
[...]</code></pre>
<h2 id="conclusion">Висновок</h2>
<p>У цьому посібнику ми показали, як інтегрувати Istio та сервер авторизації Kyverno для забезпечення політик для простого мікросервісного застосунку. Ми також показали, як використовувати політики для зміни атрибутів запиту та відповіді.</p>
<p>Це основний приклад для побудови системи політик на рівні платформи, яка може використовуватися всіма командами розробників.</p>
]]></description><pubDate>Mon, 25 Nov 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/authz-policy-with-kyverno/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/authz-policy-with-kyverno/</guid><category>istio</category><category>kyverno</category><category>policy</category><category>platform</category><category>authorization</category></item><item><title>Нова історія про Фіппі та друзів: Іззі рятує день народження</title><description><![CDATA[<p>На початку цього року <a href="/blog/2024/istio-phippy/">ми додали Дельфіна Іззі, індо-тихоокеанського афаліну</a> до <a href="https://www.cncf.io/phippy/">родини CNCF &ldquo;Фіппі та друзі&rdquo;</a>. З того часу шанувальники Istio по всьому світу з нетерпінням чекали на першу дитячу книжку за участю нашого милого дельфіна.</p>
<p>І ось вона!</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:78.04208600182983%">
        <a data-skipendnotes="true" href="/uk/blog/2024/istio-phippy-book/book_cover.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/istio-phippy-book/book_cover.png" alt="Обкладинка книги Іззі рятує день народження" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Проєкт Istio радий представити пригоди Іззі, що пливе разом із родиною Фіппі на <a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/">KubeCon North America 2024</a> цього тижня, коли ми разом святкуємо 10-річний ювілей Kubernetes. Примірники доступні в магазині CNCF або в <a href="https://store.cncf.io">онлайн-магазині</a> незабаром після події.</p>
<p>Капітан Куб влаштовує грандіозне святкування дня народження під час особливого круїзу з Фіппі та її друзями, але корабель у великій небезпеці! Проте хвилюватися нема про що, коли Іззі відповідає за безпеку! Приєднуйтесь до цікавого та захопливого переслідування піратів Іззі, які хочуть зіпсувати святкування дня народження Капітана Куба.</p>
<h2 id="навіщо-ця-книга">Навіщо ця книга?</h2>
<p>Співавторки книги, Фасіла К. та Лін Сан, є мейнтейнерами Istio та батьками. Вони часто опинялися в складній ситуації, пояснюючи, чим займаються на роботі, особливо в контексті, зрозумілому для молодших людей. Їхні діти читали та насолоджувалися <a href="https://www.cncf.io/phippy/the-childrens-illustrated-guide-to-kubernetes/">Ілюстрованим дитячим путівником по Kubernetes</a>, але були зацікавлені дізнатися більше про інших персонажів та їхні ролі та обовʼязки!</p>
<p>Ця книга для всіх, хто стикався з допитливими очима, які постійно запитують, що таке &ldquo;Service Mesh&rdquo;. Це також чудовий подарунок для будь-кого будь-якого віку, хто хоче зрозуміти, що таке Istio, або хто вважає, що сервісна мережа занадто складна.</p>
<h2 id="подяки">Подяки</h2>
<p>Керівний комітет Istio хоче подякувати Фасілі та Лін за написання цієї чудової книги. Сурі Патель та Алекс Деві з CNCF чудово попрацювали над дизайном та ілюстраціями, ожививши історію. І, нарешті, велика подяка Кеті Грінлі за її підтримку протягом усього процесу, щоб книга була випущена вчасно до святкування дня народження Капітана Куба на нашій найбільшій міжнародній конференції спільноти.</p>
<p>Ми плануємо захід з підписанням книг на наступному <a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/">KubeCon EU в Лондоні</a>.</p>
<p>Веселого читання!</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:42.22222222222222%">
        <a data-skipendnotes="true" href="/uk/blog/2024/istio-phippy-book/phippy_and_family.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/istio-phippy-book/phippy_and_family.png" alt="Фіппі та родина" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
]]></description><pubDate>Tue, 12 Nov 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/istio-phippy-book/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/istio-phippy-book/</guid><category>istio</category><category>phippy</category><category>izzy</category><category>dolphin</category></item><item><title>Швидкий, безпечний та простий: режим ambient в Istio досяг стану загальної доступності (GA) у версії 1.24</title><description><![CDATA[<p>Ми раді оголосити, що режим ambient панелі даних Istio досяг стану Загальної Доступності, і модулі ztunnel, waypoints та API були позначені як Stable Комітетом технічного нагляду Istio. Це знаменує фінальну стадію прогресу функцій Istio, що сигналізує, що режим ambient повністю готовий для широкого використання в промислових середовищах.</p>
<p>Ambient mesh, і його референсна реалізація в режимі ambient  Istio, <a href="/blog/2022/introducing-ambient-mesh/">була анонсована у вересні 2022 року</a>. З того часу наша спільнота працювала 26 місяців завдяки співпраці з Solo.io, Google, Microsoft, Intel, Aviatrix, Huawei, IBM, Red Hat та багатьма іншими. Статус стабільності у версії 1.24 свідчить, що функції режиму ambient тепер повністю готові для широкого використання у промислових робочих навантаженнях. Це важливий етап для Istio, оскільки він дозволяє використовувати Istio без sidecars, <a href="/uk/docs/overview/dataplane-modes/">пропонуючи користувачам вибір</a>.</p>
<h2 id="why-ambient-mesh">Навіщо ambient mesh?</h2>
<p>З моменту запуску Istio у 2017 році ми помітили чіткий і зростаючий попит на можливості mesh для застосунків, але багато користувачів повідомляли, що накладні витрати ресурсів і операційна складність sidecars були важкими для подолання. Виклики, з якими стикаються користувачі Istio, включають те, як sidecars можуть порушити роботу застосунків після їхнього додавання, великі вимоги до CPU та памʼяті для проксі з кожним робочим навантаженням і незручність необхідності перезапуску застосунків при кожному новому випуску Istio.</p>
<p>Ми як спільнота розробили ambient mesh з нуля, щоб подолати ці проблеми, усуваючи попередні барʼєри складності для користувачів, які хочуть впровадити сервісну мережу. Нова концепція була названа &ldquo;ambient mesh&rdquo;, оскільки вона була розроблена так, щоб бути прозорою для вашого застосунку: без проксі, розташованих поруч з робочими навантаженнями користувачів, без необхідності змінювати конфігурацію для підключення і без перезапуску застосунків. В режимі ambient дуже легко додавати або видаляти застосунки з mesh. Все, що вам потрібно зробити, це <a href="/uk/docs/ambient/usage/add-workloads/">позначити простір імен</a>, і всі застосунки в цьому просторі імен будуть миттєво додані до mesh. Це одразу ж захистить весь трафік у цьому просторі імен за допомогою стандартного в галузі шифрування mTLS, без додаткових налаштувань чи перезапусків! Більше інформації про причини створення режиму ambient в Istio можна знайти у <a href="/blog/2022/introducing-ambient-mesh/">блозі &ldquo;Introducing Ambient Mesh&rdquo;</a>.</p>
<h2 id="how-does-ambient-mode-make-adoption-easier">Як режим ambient полегшує адаптацію?</h2>
<p>Основна інновація ambient mesh полягає у розподілі обробки рівнів L4 (Layer 4) та L7 (Layer 7) на два окремих шари. Ambient режим Istio працює завдяки легким, спільним проксі L4 на рівні вузлів та додатковим проксі L7, що усуває потребу у традиційних sidecar-проксі в панелі даних. Цей пошарований підхід дозволяє впроваджувати Istio поступово, переходячи від відсутності mesh до захищеного оверлею (L4) і до повної обробки L7, за потреби, на основі простору імен, у межах вашої інфраструктури.</p>
<p>Використовуючи ambient mesh, користувачі можуть уникнути деяких обмежень моделі sidecar. Протоколи, що надсилають дані з сервера, тепер працюють, більшість зарезервованих портів доступні, а можливість для контейнерів обійти сайдкар, навмисно чи ненавмисно, усунена.</p>
<p>Легкий спільний L4 проксі на рівні вузла називається <em><a href="/uk/docs/ambient/overview/#ztunnel">ztunnel</a></em> (тунель з нульовою довірою). ztunnel значно знижує витрати на утримання mesh, усуваючи необхідність можливого перевищення використання ресурсів пам’яті та CPU в кластері для обробки очікуваних навантажень. У деяких випадках економія може перевищити 90% або більше, забезпечуючи при цьому безпеку з нульовою довірою з використанням mTLS, простих авторизаційних політик L4 та телеметрії.</p>
<p>L7 проксі називаються <em><a href="/uk/docs/ambient/overview/#waypoint-proxies">waypoints</a></em>. Waypoints обробляють функції L7, такі як маршрутизація трафіку, розширене застосування політики авторизації та стійкість корпоративного рівня. Waypoints працюють окремо від ваших розгортань застосунків та можуть масштабуватися незалежно від ваших потреб, які можуть охоплювати весь простір імен або декілька сервісів в ньому. Порівняно з sidecar, вам не потрібен один waypoint на кожен pod застосунку, і ви можете ефективно масштабувати waypoint відповідно до його області дії, заощаджуючи значну кількість CPU та пам’яті у більшості випадків.</p>
<p>Розділення між захисним оверлеєм L4 та шаром обробки L7 дозволяє поступово впроваджувати ambient режим панелі даних, на відміну від попередньої бінарної моделі &ldquo;все-в-одному&rdquo; з інʼєкцією sidecarʼів. Користувачі можуть почати з захисного L4 оверлею, який пропонує більшість функцій, для яких зазвичай впроваджується Istio (mTLS, авторизаційна політика та телеметрія). Складніша обробка L7, така як повторні спроби, розподіл трафіку, балансування навантаження та збір даних для спостереження, може бути увімкнена за необхідності.</p>
<h2 id="rapid-exploration-and-adoption-of-ambient-mode">Швидке дослідження та впровадження режиму ambient</h2>
<p>Завантаження образу ztunnel на Docker Hub перевищило <a href="https://hub.docker.com/search?q=istio">1 мільйон</a>, причому лише за останній тиждень його завантажили близько 63 000 разів.</p>
<figure style="width:100%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:11.105552776388194%">
        <a data-skipendnotes="true" href="/uk/blog/2024/ambient-reaches-ga/ztunnel-image.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/ambient-reaches-ga/ztunnel-image.png" alt="Завантаження Istio ztunnel на Docker Hub!" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Ми запитали у кількох наших користувачів їхню думку про режим ambient у статусі GA:</p>
<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Реалізація сервісної мережі від Istio з їхнім дизайном ambient mesh стала чудовим доповненням до наших кластерів Kubernetes, спрощуючи обов’язки команди та загальну архітектуру мережі. У поєднанні з проєктом Gateway API це дає мені чудову можливість дозволити розробникам задовольняти їхні мережеві потреби, водночас делегуючи лише ту частину контролю, яка потрібна. Хоча це проєкт, що швидко розвивається, він був надійним і стабільним у промисловому використанні та буде нашим стандартним варіантом для впровадження інструментів керування мережею у розгортанні Kubernetes в майбутньому.</strong></p>
<p>— <a href="https://uk.linkedin.com/in/danielloader">Daniel Loader</a>, провідний інженер платформи в Quotech</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Режим ambient mesh дуже легко встановити за допомогою обгортки Helm chart. Перехід простий, як налаштування шлюзу waypoint, оновлення міток у просторі імен і перезапуск. Я з нетерпінням чекаю на відмову від sidecar та зменшення використання ресурсів. До того ж оновлення стали простішими. Більше ніяких перезапусків розгортань!</strong></p>
<p>— <a href="https://www.linkedin.com/in/raymond-wong-43baa8a2/">Raymond Wong</a>, старший архітектор в Forbes</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Режим ambient від Istio використовується в нашій промисловій системі з моменту його переходу в статус Beta. Ми задоволені його стабільністю та простотою та з нетерпінням чекаємо додаткових переваг і функцій, які прийдуть разом зі статусом GA. Дякуємо команді Istio за великі зусилля!</strong></p>
<p>— Saarko Eilers, менеджер операційної інфраструктури в EISST International Ltd</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Перейшовши з AWS App Mesh на Istio у режимі ambient, нам вдалося скоротити приблизно кількість запущених контейнерів на 45%, просто видаливши sidecar та DaemonSets агента SPIRE. Ми отримали багато переваг, таких як зменшення витрат на обчислення або спостереження, пов’язане з sidecar, усунення багатьох умов перегонів, пов’язаних із запуском і завершенням sidecar, а також всі готові переваги лише завдяки міграції, такі як mTLS, зонування та балансування навантаження.</strong></p>
<p>— <a href="https://www.linkedin.com/in/ahmad-al-masry-9ab90858/">Ahmad Al-Masry</a>, менеджер з інженерії DevSecOps в Harri</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Ми обрали Istio, тому що нам подобається ambient mesh. На відміну від інших варіантів, з Istio перехід від sidecar до інфраструктури без-sidecar не є стрибком віри. Ми можемо створювати нашу інфраструктуру сервісної мережі з Istio, знаючи, що шлях до системи без-sidecar є двостороннім.</strong></p>
<p>— <a href="https://www.linkedin.com/in/troydai/">Troy Dai</a>, старший програмний інженер в Coinbase</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Надзвичайно гордимося бачити швидке і стабільне зростання режиму ambient до GA і чудову співпрацю, що відбувалась протягом останніх місяців, щоб зробити це можливим! Ми з нетерпінням чекаємо, як нова архітектура змінить світ телекомунікацій.</strong></p>
<p>— <a href="https://www.linkedin.com/in/faseela-k-42178528/">Faseela K</a>, розробник хмарних технологій в Ericsson</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Ми раді бачити розвиток панелі даних Istio з виходом режиму ambient у статус GA та активно розглядаємо його для нашої платформи інфраструктури нового покоління. Спільнота Istio є динамічною та привітною, а ambient mesh є доказом того, що спільнота приймає нові ідеї та прагматично працює над покращенням досвіду розробників у масштабах експлуатації Istio.</strong></p>
<p>— <a href="https://www.linkedin.com/in/tylerschade/">Tyler Schade</a>, видатний інженер у GEICO Tech</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>З виходом режиму ambient в статусі GA, ми нарешті маємо рішення для сервісної мережі, яке не прив’язане до життєвого циклу podʼів, вирішуючи основне обмеження моделей на базі sidecar. Ambient mesh забезпечує більш легку, масштабовану архітектуру, що спрощує операції та знижує витрати на інфраструктуру, усуваючи навантаження sidecar.</strong></p>
<p>— <a href="https://www.linkedin.com/in/bartoszsobieraj/">Bartosz Sobieraj</a>, інженер платформи в Spond</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Наша команда обрала Istio за його функції сервісної мережі та сильну сумісність з Gateway API для створення надійного рішення для розміщення на основі Kubernetes. Під час інтеграції застосунків у mesh ми зіткнулися з проблемами ресурсів через sidecar-проксі, що спонукало нас перейти до режиму ambient в статусі Beta для поліпшення масштабованості та безпеки. Ми почали з безпеки та спостереження L4 через ztunnel, отримавши автоматичне шифрування внутрішньокластерного трафіку та прозорий моніторинг трафіку. Вибіркове включення функцій L7 і відокремлення проксі від застосунків дозволили нам досягти безперебійного масштабування та зменшити використання ресурсів і затримки. Цей підхід дозволив розробникам зосередитися на розробці застосунків, що призвело до створення більш стійкої, безпечної та масштабованої платформи, підтримуваної режимом ambient.</strong></p>
<p>— <a href="https://www.linkedin.com/in/jdcmarques/">Jose Marques</a>, старший інженер DevOps в Blip.pt</p>
</div>

        
    </aside>
</div>

<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content"><p><strong>Ми використовуємо Istio для забезпечення суворого трафіку mTLS L4 у нашій mesh і радіємо з приводу режиму ambient. У порівнянні з режимом sidecar, це значна економія ресурсів, і водночас це робить налаштування ще простішим і прозорішим.</strong></p>
<p>— <a href="https://www.linkedin.com/in/andrea-dolfi-58b427128/">Andrea Dolfi</a>, інженер DevOps</p>
</div>

        
    </aside>
</div>

<h2 id="what-is-in-scope">Що входить у сферу дії?</h2>
<p>Загальна доступність режиму ambient означає, що наступні речі тепер вважаються стабільними:</p>
<ul>
<li><a href="/uk/docs/ambient/install/">Встановлення Istio з підтримкою режиму ambient</a>, за допомогою Helm або <code>istioctl</code>.</li>
<li><a href="/uk/docs/ambient/usage/add-workloads/">Додавання ваших робочих навантажень до mesh</a> для отримання взаємного TLS із криптографічною ідентичністю, <a href="/uk/docs/ambient/usage/l4-policy/">політик авторизації рівня L4</a> та телеметрії.</li>
<li><a href="/uk/docs/ambient/usage/waypoint/">Налаштування waypoint</a> для <a href="/uk/docs/ambient/usage/l7-features/">використання функцій L7</a>, таких як зміна трафіку, маршрутизація запитів та забезпечення повноцінного контролю політик авторизації.</li>
<li>Підключення Istio ingress gateway до робочих навантажень у режимі ambient, що підтримує Kubernetes Gateway API та всі наявні Istio API.</li>
<li>Використання waypoint для контрольованого виходу з mesh.</li>
<li>Використання <code>istioctl</code> для управління waypoint та усунення неполадок із ztunnel та waypoint.</li>
</ul>
<p>Більше інформації дивіться на <a href="/uk/docs/releases/feature-stages/#ambient-mode">сторінці статусу функцій</a>.</p>
<h3 id="roadmap">Плани</h3>
<p>Ми не зупиняємося! Існує кілька функцій, над якими ми продовжуємо працювати для майбутніх випусків, включаючи деякі, які зараз перебувають на стадії Alpha/Beta.</p>
<p>У наших майбутніх випусках ми плануємо швидко розвивати такі розширення режиму ambient:</p>
<ul>
<li>Повна підтримка взаємодії між sidecar та режимом ambient.</li>
<li>Багатокластерні установки.</li>
<li>Підтримка багатомережевих конфігурацій.</li>
<li>Підтримка VM.</li>
</ul>
<h2 id="what-about-sidecars">Що з sidecar?</h2>
<p>Sidecar не зникнуть і залишаються важливим елементом в Istio. Ви можете продовжувати використовувати sidecar, і вони залишатимуться повністю підтримуваними. Хоча ми вважаємо, що більшість сценаріїв найкраще обслуговуватимуться мережею в режимі ambient, проєкт Istio залишається відданим подальшій підтримці режиму sidecar.</p>
<h2 id="try-ambient-mode-today">Спробуйте режим ambient сьогодні</h2>
<p>З випуском Istio 1.24 та загальною доступністю режиму ambient тепер легше, ніж будь-коли, випробувати Istio на власних робочих навантаженнях.</p>
<ul>
<li>Слідуйте <a href="/uk/docs/ambient/getting-started/">керівництву з початку роботи</a>, щоб дослідити режим ambient.</li>
<li>Ознайомтеся з нашими <a href="/uk/docs/ambient/usage/">посібниками користувача</a>, щоб дізнатися, як поступово впроваджувати ambient для взаємного TLS і політик авторизації L4, управління трафіком, розширених політик авторизації L7 та інших функцій.</li>
<li>Досліджуйте <a href="https://medium.com/kialiproject/kiali-2-0-for-istio-2087810f337e">нову інфопанель Kiali 2.0</a> для візуалізації вашої мережі.</li>
</ul>
<p>Ви можете поспілкуватися з розробниками в каналі #ambient на <a href="https://slack.istio.io">Istio Slack</a> або використовувати форум обговорень на <a href="https://github.com/istio/istio/discussions">GitHub</a> для будь-яких запитань.</p>
]]></description><pubDate>Thu, 07 Nov 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/ambient-reaches-ga/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/ambient-reaches-ga/</guid><category>ambient</category><category>sidecars</category></item><item><title>Istio в Солт-Лейк-Сіті!</title><description><![CDATA[<p>Неймовірна програма заходів Istio чекає на вас у Солт-Лейк-Сіті, штат Юта, на <a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/">KubeCon + CloudNativeCon North America 2024</a>!</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:45.933014354066984%">
        <a data-skipendnotes="true" href="/uk/blog/2024/kubecon-na/kubecon-na.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/kubecon-na/kubecon-na.png" alt="KubeCon &#43; CloudNativeCon North America, 12-15 листопада 2024, Солт-Лейк-Сіті, Юта. #KubeCon" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<ul>
<li>
<p>Відвідайте <a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/co-located-events/istio-day/">Istio Day</a>, що проводиться на конференції.</p>
</li>
<li>
<p>Долучайтеся до сесії Istio Maintainers&rsquo; Track: <a href="https://sched.co/1hovw">Життя пакета: Ambient Edition</a></p>
</li>
<li>
<p>Завітайте на сесію Istio Contribfest: <a href="https://sched.co/1hoyI">Сервісна мережа без sidecar: Давайте разом працювати над Istio V2</a></p>
</li>
<li>
<p>Додайте наступні сесії KubeCon до свого розкладу, всі вони мають тематику Istio:</p>
<ul>
<li><a href="https://sched.co/1iW9Q">Чому обрати Istio у 2025 році | Короткі доповіді проєктів</a></li>
<li><a href="https://sched.co/1i7k0">Короткі доповіді: Легке, без sidecarʼів mTLS та політики авторизації за 5 хвилин</a></li>
<li><a href="https://sched.co/1i7mr">Cесія gjcnthsd: Використання прогнозування для масштабування компонентів панелі управління</a></li>
<li><a href="https://sched.co/1i7nP">Що Istio зробив неправильно: уроки з семирічного досвіду в Service Mesh</a></li>
<li><a href="https://sched.co/1i7np">Навчання: Робота з API Gateway V1.2</a></li>
<li><a href="https://sched.co/1i7ow"><code>Mish-Mesh</code>: Використання Service Mesh для компрометації середовищ Kubernetes</a></li>
<li><a href="https://sched.co/1i7r4">Взаємодія з KServe Community: Вплив інтеграції з проєктами CNCF</a></li>
<li><a href="https://sched.co/1i7pE">Як Google створив нову хмару на базі Kubernetes</a></li>
<li><a href="https://sched.co/1i7ps">Забезпечення вихідного трафіку: створення потужного шлюзу для надійного зʼєднання з Інтернетом</a></li>
<li><a href="https://sched.co/1i7qh">Тестування Kubernetes без Kubernetes: глибокий аналіз мережевих рішень</a></li>
<li><a href="https://sched.co/1i7rH">Як GoTo Financial автоматизує оновлення більш ніж 60 Istio Service Mesh без простоїв!</a></li>
</ul>
</li>
<li>
<p>Поспілкуйтеся з розробниками та користувачами на стенді Istio в Project Pavilion протягом усього заходу, де ви зможете отримати круту футболку Istio з новим дизайном.</p>
</li>
<li>
<p>У нас також буде цікавий сюрприз для всіх шанувальників Istio, який буде представлено в магазині CNCF на KubeCon North America. Слідкуйте за новинами!</p>
</li>
</ul>
<p>Слідкуйте за нами на <a href="https://x.com/istiomesh">X</a>, <a href="https://www.linkedin.com/company/istio/">LinkedIn</a> або <a href="https://bsky.app/profile/istio.io">Bluesky</a>, щоб отримувати актуальні новини з події. До зустрічі!</p>
]]></description><pubDate>Tue, 05 Nov 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/kubecon-na/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/kubecon-na/</guid><category>Istio Day</category><category>Istio</category><category>conference</category><category>KubeCon</category><category>CloudNativeCon</category></item><item><title>Масштабування в хмарі: Istio Ambient проти Cilium</title><description><![CDATA[<p>Звичне питання від потенційних користувачів Istio: &ldquo;Як порівняти Istio з Cilium?&rdquo; Хоча спочатку Cilium пропонував лише функціональність L3/L4, включаючи мережеву політику, останні релізи додали функції сервісної мережі за допомогою Envoy, а також шифрування за допомогою WireGuard. Як і Istio, Cilium є проєктом, що досяг статусу CNCF Graduated, та присутній у спільноті протягом багатьох років.</p>
<p>Попри подібний набір функцій, ці два проєкти мають суттєво різні архітектури, особливо в тому, як Cilium використовує eBPF та WireGuard для обробки та шифрування L4-трафіку в ядрі, на відміну від Istio, який використовує компонент ztunnel для L4 у просторі користувача. Ці відмінності породили чимало припущень щодо продуктивності Istio на великих масштабах у порівнянні з Cilium.</p>
<p>Хоча вже було зроблено чимало порівнянь щодо моделей оренди, протоколів безпеки та базової продуктивності двох проєктів, повна оцінка на рівні корпоративного масштабу ще не опублікована. Замість теоретичних показників продуктивності, ми випробували режим ambient в Istio та Cilium у реальних навантаженнях, зосередившись на таких ключових метриках, як затримка, пропускна здатність та споживання ресурсів. Ми збільшили навантаження у реалістичних сценаріях для Kubernetes, і врешті-решт розширили наш кластер AKS до 1 000 вузлів на 11 000 ядрах, щоб зрозуміти, як ці проєкти поводяться на великих масштабах. Наші результати показують, що обидва проєкти мають місце для вдосконалення, але також вказують, що Istio є очевидним переможцем.</p>
<h2 id="test-scenario">Сценарій тестування</h2>
<p>Щоб випробувати Istio та Cilium на межі можливостей, ми створили 500 різних сервісів, кожен з яких підтримувався 100 подами. Кожен сервіс був створений в окремому просторі імен, який також містив клієнта для навантаження <a href="https://fortio.org/">Fortio</a>. Ми обмежили клієнтів пулом вузлів зі 100 32-ядерних машин, щоб усунути шум від спільних клієнтів, та виділили решту 900 8-ядерних екземплярів для наших сервісів.</p>
<figure style="width:60%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:78.66379310344827%">
        <a data-skipendnotes="true" href="/uk/blog/2024/ambient-vs-cilium/scale-scenario.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/ambient-vs-cilium/scale-scenario.png" alt="Масштабування до 500 сервісів з 50 000 подами." />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Для тесту Istio ми використали його режим ambient з <a href="/uk/docs/ambient/usage/waypoint/">waypoint проксі</a> у кожному просторі імен сервісу та стандартними параметрами інсталяції. Щоб зробити наші тестові сценарії схожими, ми увімкнули кілька нестандартних функцій у Cilium, включаючи шифрування WireGuard, L7-проксі та Node Init. Ми також створили мережеву політику Cilium у кожному просторі імен з правилами на основі HTTP-шляхів. У кожному сценарії ми створили зміни, масштабуючи один сервіс випадковим чином між 85 і 115 екземплярами щосекунди та переіменовуючи один простір імен щохвилини. Для перегляду точних налаштувань, які ми використовували, та для відтворення наших результатів, дивіться <a href="https://github.com/therealmitchconnors/tools/blob/2384dc26f114300687b21f921581a158f27dc9e1/perf/load/many-svc-scenario/README.md">ці нотатки</a>.</p>
<h2 id="scalability-scorecard">Оцінка масштабованості</h2>
<figure style="width:80%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:56.081525312294545%">
        <a data-skipendnotes="true" href="/uk/blog/2024/ambient-vs-cilium/scale-scorecard.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/ambient-vs-cilium/scale-scorecard.png" alt="Оцінка масштабованості: Istio проти Cilium!" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Istio вдалося обробити на 56% більше запитів за 20% меншої затримки. Споживання ресурсів процесора було на 30% менше у Cilium, хоча наші вимірювання не враховують ядра, які Cilium використовував для обробки шифрування, що здійснюється у ядрі.</p>
<p>Враховуючи використані ресурси, Istio обробила 2178 запитів на ядро проти 1815 у Cilium, що є покращенням на 20%.</p>
<ul>
<li><strong>Уповільнення Cilium:</strong> Хоча Cilium має напрочуд низьку затримку зі стандартними параметрами встановлення, він значно уповільнюється, коли активуються основні функції Istio, такі як політики L7 та шифрування. Крім того, споживання памʼяті та процесора в Cilium залишалося високим, навіть коли в мережі не було трафіку. Це може вплинути на загальну стабільність та надійність вашого кластера, особливо при його зростанні.</li>
<li><strong>Istio — стабільний гравець:</strong> Режим ambient в Istio продемонстрував свою силу у стабільності та підтримці пристойної пропускної здатності, навіть з додатковим навантаженням через шифрування. Хоча Istio споживав більше памʼяті та процесора ніж Cilium під час тесту, використання процесора стабілізувалося на рівні, що значно нижчий, ніж у Cilium, коли мережа не була навантажена.</li>
</ul>
<h2 id="behind-the-scenes-why-the-difference">За лаштунками: Чому така різниця?</h2>
<p>Ключ до розуміння цих відмінностей у продуктивності лежить в архітектурі та дизайні кожного інструменту.</p>
<ul>
<li><strong>Дилема панелі управління Cilium:</strong> Cilium запускає екземпляр панелі управління на кожному вузлі, що спричиняє навантаження на API-сервер та створює додаткові конфігураційні складнощі зі збільшенням кластера. Це часто призводило до збоїв API-сервера, через що Cilium ставав недоступним, і весь кластер ставав неактивним.</li>
<li><strong>Перевага Istio в ефективності:</strong> Istio, завдяки централізованій панелі управління та підходу, заснованому на ідентифікації, спрощує конфігурацію та зменшує навантаження на API-сервер і вузли, спрямовуючи критичні ресурси на обробку та захист трафіку.</li>
</ul>
<h2 id="digging-deeper">Додаткові подробиці</h2>
<p>Хоча метою цього проєкту є порівняння масштабованості Istio та Cilium, існують кілька обмежень, що ускладнюють пряме порівняння.</p>
<h3 id="layer-4-isnt-always-layer-4">Не завжди L4 — це L4</h3>
<p>Хоча Istio та Cilium обидва забезпечують політику L4, їхні API та реалізація значно відрізняються.</p>
<h3 id="not-all-encryption-is-created-equal">Не все шифрування однакове</h3>
<p>Cilium підтримує IPsec для шифрування, що відповідає FIPS, проте більшість інших функцій Cilium, як-от політика L7 та балансування навантаження, несумісні з IPsec.</p>
<h3 id="hidden-costs">Приховані витрати</h3>
<p>Хоча Istio повністю працює у просторі користувача, панель даних L4 Cilium працює в ядрі Linux за допомогою eBPF. Метрики Prometheus для використання ресурсів враховують лише ресурси простору користувача.</p>
<h2 id="recommendations-choosing-the-right-tool-for-the-job">Рекомендації: Вибір правильного інструменту для завдання</h2>
<p>Отже, яке рішення обрати? Це залежить від ваших конкретних потреб і пріоритетів. Для малих кластерів з чисто L3/L4 сценаріями використання та без потреби в шифруванні, Cilium пропонує економічно вигідне та продуктивне рішення. Проте для більших кластерів з акцентом на стабільність, масштабованість та розширені функції, варто обрати Istio в режимі ambient разом з альтернативною реалізацією NetworkPolicy. Багато клієнтів поєднують L3/L4 функції Cilium з L4/L7 та функціями шифрування Istio для стратегії багаторівневого захисту.</p>
<p>Памʼятайте, що світ cloud-native мережевих технологій постійно розвивається. Слідкуйте за розвитком як Istio, так і Cilium, оскільки обидва інструменти продовжують вдосконалюватись і вирішувати ці виклики.</p>
<h2 id="lets-keep-the-conversation-going">Продовжимо спілкування</h2>
<p>Ви вже працювали з Istio в режимі ambient або з Cilium? Які у вас досвід та враження? Поділіться своїми думками в коментарях нижче. Вчімося один в одного та разом досліджуймо захопливий світ Kubernetes!</p>
]]></description><pubDate>Mon, 21 Oct 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/ambient-vs-cilium/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/ambient-vs-cilium/</guid><category>istio</category><category>cilium</category><category>analysis</category></item><item><title>Залучення спільноти: Регулярні вибори в Технічний наглядовий комітет Istio</title><description><![CDATA[<p>Як і багато проєктів з відкритим кодом, проєкт Istio має дві керівні групи: <a href="https://github.com/istio/community/blob/master/steering/CHARTER.md">Керівний комітет</a>, що відповідає за адміністративні та маркетингові аспекти проєкту, і <a href="https://github.com/istio/community/blob/master/TECH-OVERSIGHT-COMMITTEE.md">Технічний наглядовий комітет</a> (TOC), що відповідає за прийняття важливих рішень щодо продукту та дизайну.</p>
<p>Керівний комітет представляє компанії та учасників, які підтримують проєкт Istio, тоді як TOC є найвищим щаблем в <a href="https://github.com/istio/community/blob/master/ROLES.md">індивідуальній системі внесків</a>, що включає членів, мейнтейнерів та лідерів робочих груп.</p>
<p>Щороку ми формуємо Керівний комітет з представників наших основних комерційних учасників і членів, обраних нашою спільнотою мейнтейнерів. Саме ця група відповідає за вибори нових членів TOC, які раніше виконували свої обовʼязки безстроково.</p>
<p>Ми хочемо гарантувати, що всі члени нашої спільноти мають можливість висувати свої кандидатури та обіймати наші керівні посади. Сьогодні ми раді оголосити про перехід до регулярних виборів у TOC, де члени працюватимуть впродовж дворічного терміну, і закликаємо кандидатів до участі у наших перших виборах.</p>
<h2 id="чим-займається-технічний-наглядовий-комітет">Чим займається Технічний наглядовий комітет?</h2>
<p>Статут TOC описує обовʼязки його членів, включаючи:</p>
<ul>
<li>Встановлення загального технічного напрямку та планів проєкту.</li>
<li>Розвʼязання технічних питань, розбіжностей і суперечок.</li>
<li>Призначення <a href="/uk/docs/releases/feature-stages/">рівнів зрілості для функцій Istio</a>.</li>
<li>Схвалення створення та розпуску робочих груп і затвердження змін у керівництві робочих груп.</li>
<li>Забезпечення дотримання <a href="https://github.com/istio/community/blob/master/CONTRIBUTING.md#code-of-conduct">кодексу поведінки</a> та поваги до <a href="https://github.com/istio/community/blob/master/VALUES.md">цінностей спільноти</a>.</li>
<li>Створення здорової та дружньої атмосфери для розробників і учасників спільноти.</li>
</ul>
<p>Хоча інтереси наших комерційних партнерів представлені Керівним комітетом, членство в TOC пов’язане з особистістю, незалежно від їхнього роботодавця. Члени діють незалежно, у своїй індивідуальній якості, і повинні ставити інтереси проєкту та спільноти на перше місце. Всі рішення ухвалюються на основі консенсусу, і тому кількість членів TOC є парною. TOC традиційно складається з 6 членів, і це залишиться без змін.</p>
<h2 id="що-змінюється-з-новим-статутом">Що змінюється з новим статутом?</h2>
<p>Основні зміни в <a href="https://github.com/istio/community/blob/master/TECH-OVERSIGHT-COMMITTEE.md#charter">новому статуті</a>, нещодавно ратифікованому Керівним комітетом, включають:</p>
<ul>
<li>Члени тепер працюватимуть терміном у 2 роки.</li>
<li>Керівний комітет щороку голосуватиме за переобрання 3 із 6 членів TOC.</li>
<li>Процедура виборів <a href="https://github.com/istio/community/blob/master/TECH-OVERSIGHT-COMMITTEE.md#qualification-and-eligibility">чітко визначена</a>, включаючи вимоги до кандидатів та оцінювання.</li>
<li>Формалізовано очікування щодо регулярних зустрічей між Керівним комітетом і TOC.</li>
<li>Передбачено формальний процес усунення члена TOC у разі втрати довіри з боку Керівного комітету.</li>
</ul>
<p><sup>†</sup> Немає обмежень на кількість термінів, протягом яких член може перебувати на посаді, і чинні члени TOC можуть знову балотуватися після закінчення їхнього терміну.</p>
<h2 id="прощання-з-членами-toc">Прощання з членами TOC</h2>
<p>Ми нещодавно оголосили про <a href="/news/releases/1.22.x/announcing-1.22/#a-thank-you">вихід з проєкту давнього учасника Еріка Ван Нормана</a>. Також ми прощаємось із Ніраджем Поддаром з Istio TOC. Нірадж брав участь у проєкті з 2017 року, став співзасновником Aspen Mesh у F5, а пізніше очолював Gloo Mesh як віце-президент з інженерії в Solo.io. Він вперше був обраний до TOC у 2020 році. <a href="https://www.linkedin.com/feed/update/urn:li:activity:7251958639400206336/">Нірадж прийняв посаду віце-президента інженерії в NimbleEdge</a>, і ми вітаємо його та бажаємо успіхів у майбутньому.</p>
<h2 id="мейнтейнери-беріть-участь-у-перших-виборах">Мейнтейнери: беріть участь у перших виборах</h2>
<p>Ми запланували щорічні вибори до TOC після формування Керівного комітету кожного року, що дозволить провести перші вибори приблизно в березні 2025 року.</p>
<p>Однак, оскільки в нас наразі є дві вакансії, ми оголошуємо наші перші вибори як додаткові, щоб заповнити ці два місця на <a href="https://github.com/istio/community/blob/master/TECH-OVERSIGHT-COMMITTEE.md#members">решту їхніх термінів</a>.</p>
<p>Планка для приєднання до TOC навмисно встановлена високо. Кандидати повинні бути постійними мантейнерами, визнаними у спільноті Istio як технічні лідери, здатні до співпраці, і відповідати <a href="https://github.com/istio/community/blob/master/TECH-OVERSIGHT-COMMITTEE.md#qualification-and-eligibility">вимогам кваліфікації</a>, які демонструють їхню відповідність цій посаді.</p>
<p>Щоб подати заявку на місце в TOC, надішліть електронного листа на <a href="mailto:elections@istio.io">elections@istio.io</a>, включивши посилання на односторінковий документ Google Doc з вашою самооцінкою за критеріями кваліфікації. Приймання заявок закривається через два тижні, 31 жовтня.</p>
<p>Бажаємо успіхів!</p>
]]></description><pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/toc-charter-elections/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/toc-charter-elections/</guid><category>istio</category><category>toc</category><category>governance</category><category>community</category><category>election</category></item><item><title>Чи може ваша платформа реалізовувати політики? Прискорте команди завдяки функціональності платформних політик L7</title><description><![CDATA[<p>Спільні обчислювальні платформи надають ресурси та функціональність для команд орендарів, щоб їм не доводилося створювати все з нуля. Хоча часом буває важко збалансувати всі запити від орендарів, важливо, щоб платформа ставила питання: яку найціннішу функцію ми можемо запропонувати нашим орендарям?</p>
<p>Часто роботу доручають безпосередньо командам що створюють застосунки, але деякі функції найкраще реалізувати один раз і надавати їх як сервіс для всіх команд. Однією з таких функцій, яку може запропонувати більшість команд, що опікуються платформами, є надання стандартної, гнучкої системи політики авторизації для рівня застосунків L7. Політика як код дозволяє командам переносити рішення щодо авторизації з рівня застосунків у легку та ефективну розподілену систему. Це може здатися складним завданням, але з правильними інструментами воно не обов’язково є таким.</p>
<p>Ми розглянемо, як Istio та Open Policy Agent (OPA) можуть використовуватися для забезпечення політик рівня L7 у вашій платформі. Ми покажемо, як почати з простого прикладу. Ви побачите, як ця комбінація є надійним варіантом для швидкого і прозорого надання політик командам розробки застосунків у бізнесі, а також забезпечує дані, необхідні командам безпеки для аудиту та дотримання стандартів.</p>
<h2 id="try-it-out">Спробуйте самі</h2>
<p>Коли OPA інтегровано з Istio, він може використовуватися для забезпечення детальних політик контролю доступу для мікросервісів. У цьому посібнику описано, як забезпечити політики контролю доступу для простого мікросервісного застосунку.</p>
<h3 id="prerequisites">Попередні вимоги</h3>
<ul>
<li>Кластер Kubernetes з встановленим Istio.</li>
<li>Встановлений інструмент командного рядка <code>istioctl</code>.</li>
</ul>
<p>Встановіть Istio і налаштуйте <a href="/docs/reference/config/istio.mesh.v1alpha1/">параметри mesh</a>, щоб увімкнути OPA:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl install -y -f - &lt;&lt;&#39;EOF&#39;
apiVersion: install.istio.io/v1alpha1
kind: IstioOperator
spec:
  meshConfig:
    accessLogFile: /dev/stdout
    accessLogFormat: |
      [OPA DEMO] my-new-dynamic-metadata: &#34;%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%&#34;
    extensionProviders:
    - name: &#34;opa.local&#34;
      envoyExtAuthzGrpc:
        service: &#34;opa.opa.svc.cluster.local&#34;
        port: &#34;9191&#34;
EOF</code></pre>
<p>Зверніть увагу, що в конфігурації ми визначаємо розділ <code>extensionProviders</code>, який вказує на самостійне встановлення OPA.</p>
<p>Розгорніть приклад застосунків. Httpbin — відомий застосунок, який можна використовувати для тестування HTTP-запитів; він швидко демонструє, як можна працювати з атрибутами запиту та відповіді.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl create ns my-app
$ kubectl label namespace my-app istio-injection=enabled

$ kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.25/samples/httpbin/httpbin.yaml -n my-app</code></pre>
<p>Розгорніть OPA. Це не вдасться, оскільки очікується <code>configMap</code>, що містить стандартне правило Rego для використання. Цей <code>configMap</code> буде розгорнуто пізніше у нашому прикладі.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl create ns opa
$ kubectl label namespace opa istio-injection=enabled

$ kubectl apply -f - &lt;&lt;EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: opa
  name: opa
  namespace: opa
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opa
  template:
    metadata:
      labels:
        app: opa
    spec:
      containers:
      - image: openpolicyagent/opa:0.61.0-envoy
        name: opa
        args:
          - &#34;run&#34;
          - &#34;--server&#34;
          - &#34;--disable-telemetry&#34;
          - &#34;--config-file=/config/config.yaml&#34;
          - &#34;--log-level=debug&#34; # Розкоментуйте цей рядок, щоб увімкнути журнали налагодження
          - &#34;--diagnostic-addr=0.0.0.0:8282&#34;
          - &#34;/policy/policy.rego&#34; # Стандартна політика
        volumeMounts:
          - mountPath: &#34;/config&#34;
            name: opa-config
          - mountPath: &#34;/policy&#34;
            name: opa-policy
      volumes:
        - name: opa-config
          configMap:
            name: opa-config
        - name: opa-policy
          configMap:
            name: opa-policy
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-config
  namespace: opa
data:
  config.yaml: |
    # Тут ви знайдете конфігурацію OPA, яку ви можете знайти в офіційній документації
    decision_logs:
      console: true
    plugins:
      envoy_ext_authz_grpc:
        addr: &#34;:9191&#34;
        path: mypackage/mysubpackage/myrule # Default path for grpc plugin
    # Тут ви можете додати власну конфігурацію з сервісами та пакетами
---
apiVersion: v1
kind: Service
metadata:
  name: opa
  namespace: opa
  labels:
    app: opa
spec:
  ports:
    - port: 9191
      protocol: TCP
      name: grpc
  selector:
    app: opa
---
EOF</code></pre>
<p>Розгорніть <code>AuthorizationPolicy</code>, щоб визначити, які служби будуть захищені OPA.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: security.istio.io/v1
kind: AuthorizationPolicy
metadata:
  name: my-opa-authz
  namespace: istio-system # Цей рядок застосовує політику до всіх мереж в просторі назв налаштувань istio-system
spec:
  selector:
    matchLabels:
      ext-authz: enabled
  action: CUSTOM
  provider:
    name: &#34;opa.local&#34;
  rules: [{}] # Порожнє правило, буде застосовуватися до селекторів з міткою ext-authz: enabled
EOF</code></pre>
<p>Позначімо застосунок міткою, щоб впровадити політику:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl patch deploy httpbin -n my-app --type=merge -p=&#39;{
  &#34;spec&#34;: {
    &#34;template&#34;: {
      &#34;metadata&#34;: {
        &#34;labels&#34;: {
          &#34;ext-authz&#34;: &#34;enabled&#34;
        }
      }
    }
  }
}&#39;</code></pre>
<p>Зверніть увагу, що в цьому ресурсі ми визначаємо OPA <code>extensionProvider</code>, який ви встановили в конфігурації Istio:</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
  provider:
    name: &#34;opa.local&#34;
[...]</code></pre>
<h2 id="how-it-works">Як це працює</h2>
<p>При застосуванні <code>AuthorizationPolicy</code> панель управління Istio (istiod) надсилає необхідні конфігурації до sidecar проксі (Envoy) вибраних сервісів, зазначених у політиці. Envoy потім відправляє запит на сервер OPA, щоб перевірити, чи дозволено цей запит.</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:47.43008314436886%">
        <a data-skipendnotes="true" href="/uk/blog/2024/l7-policy-with-opa/opa1.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/l7-policy-with-opa/opa1.png" alt="Istio та OPA" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Проксі Envoy працює шляхом налаштування фільтрів у ланцюгу. Одним із таких фільтрів є <code>ext_authz</code>, який реалізує зовнішню службу авторизації з певним повідомленням. Будь-який сервер, що реалізує відповідний protobuf, може підʼєднатися до проксі Envoy та надати рішення щодо авторизації; OPA є одним з таких серверів.</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:40.17825311942959%">
        <a data-skipendnotes="true" href="/uk/blog/2024/l7-policy-with-opa/opa2.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/l7-policy-with-opa/opa2.png" alt="Фільтри" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Раніше, коли ви встановлювали сервер OPA, ви використовували версію сервера Envoy. Цей образ дозволяє налаштувати втулок gRPC, який впроваджує службу <code>ext_authz</code> protobuf.</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
      containers:
      - image: openpolicyagent/opa:0.61.0-envoy # Це версія образу OPA з втулком Envoy
        name: opa
[...]</code></pre>
<p>У конфігурації ви увімкнули втулок Envoy та порт, на якому він слухає:</p>
<pre><code class='language-yaml' data-expandlinks='true' data-repo='istio' >[...]
    decision_logs:
      console: true
    plugins:
      envoy_ext_authz_grpc:
        addr: &#34;:9191&#34; # Це порт, на якому буде слухати втулок Envoy
        path: mypackage/mysubpackage/myrule # Стандартний шлях для втулка grpc
    # Тут ви можете додати власну конфігурацію з сервісами та наборами даних
[...]</code></pre>
<p>Переглядаючи <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/auth/v3/external_auth.proto">документацію про службу авторизації Envoy</a>, можна побачити, що повідомлення має такі атрибути:</p>
<pre><code class='language-json' data-expandlinks='true' data-repo='istio' >OkHttpResponse
{
  &#34;status&#34;: {...},
  &#34;denied_response&#34;: {...},
  &#34;ok_response&#34;: {
      &#34;headers&#34;: [],
      &#34;headers_to_remove&#34;: [],
      &#34;dynamic_metadata&#34;: {...},
      &#34;response_headers_to_add&#34;: [],
      &#34;query_parameters_to_set&#34;: [],
      &#34;query_parameters_to_remove&#34;: []
    },
  &#34;dynamic_metadata&#34;: {...}
}</code></pre>
<p>Це означає, що на основі відповіді від сервера authz Envoy може додавати або видаляти заголовки, параметри запиту та навіть змінювати статус відповіді. OPA також може це робити, як описано в його <a href="https://www.openpolicyagent.org/docs/latest/envoy-primer/#example-policy-with-additional-controls">документації</a>.</p>
<h2 id="testing">Тестування</h2>
<p>Протестуймо просте використання (авторизацію), а потім створимо більш розширене правило, щоб показати, як можна використовувати OPA для зміни запиту та відповіді.</p>
<p>Розгорніть застосунок для запуску команд curl до тестового застосунку httpbin:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n my-app run --image=curlimages/curl curl -- /bin/sleep 100d</code></pre>
<p>Застосуйте перше правило Rego і перезапустіть розгортання OPA:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: opa
data:
  policy.rego: |
    package mypackage.mysubpackage

    import rego.v1

    default myrule := false

    myrule if {
      input.attributes.request.http.headers[&#34;x-force-authorized&#34;] == &#34;enabled&#34;
    }

    myrule if {
      input.attributes.request.http.headers[&#34;x-force-authorized&#34;] == &#34;true&#34;
    }
EOF</code></pre>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl rollout restart deployment -n opa</code></pre>
<p>Простий сценарій передбачає дозвіл запитів, якщо вони містять заголовок <code>x-force-authorized</code> зі значенням <code>enabled</code> або <code>true</code>. Якщо заголовок відсутній або має інше значення, запит буде відхилено.</p>
<p>Існує кілька способів створити правило Rego. У цьому випадку ми створили два різні правила. Виконуються вони у порядку, і перше правило, яке задовольняє всі умови, буде застосоване.</p>
<h3 id="simple-rule">Просте правило</h3>
<p>Результатом наступного запиту буде відповідь <code>403</code>:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get</code></pre>
<p>Наступний запит поверне <code>200</code> та тіло відповіді:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get -H &#34;x-force-authorized: enabled&#34;</code></pre>
<h3 id="advanced-manipulations">Складніші маніпуляції</h3>
<p>Тепер складніше правило. Застосуйте друге правило Rego і перезапустіть розгортання OPA:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &lt;&lt;EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: opa-policy
  namespace: opa
data:
  policy.rego: |
    package mypackage.mysubpackage

    import rego.v1

    request_headers := input.attributes.request.http.headers

    force_unauthenticated if request_headers[&#34;x-force-unauthenticated&#34;] == &#34;enabled&#34;

    default allow := false

    allow if {
      not force_unauthenticated
      request_headers[&#34;x-force-authorized&#34;] == &#34;true&#34;
    }

    default status_code := 403

    status_code := 200 if allow

    status_code := 401 if force_unauthenticated

    default body := &#34;Unauthorized Request&#34;

    body := &#34;Authentication Failed&#34; if force_unauthenticated

    myrule := {
      &#34;body&#34;: body,
      &#34;http_status&#34;: status_code,
      &#34;allowed&#34;: allow,
      &#34;headers&#34;: {&#34;x-validated-by&#34;: &#34;my-security-checkpoint&#34;},
      &#34;response_headers_to_add&#34;: {&#34;x-add-custom-response-header&#34;: &#34;added&#34;},
      &#34;request_headers_to_remove&#34;: [&#34;x-force-authorized&#34;],
      &#34;dynamic_metadata&#34;: {&#34;my-new-metadata&#34;: &#34;my-new-value&#34;},
    }
EOF</code></pre>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl rollout restart deployment -n opa</code></pre>
<p>В цьому правилі ви можете побачити:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >myrule[&#34;allowed&#34;] := allow # Зверніть увагу, що `allowed` є обовʼязковим при поверненні обʼєкта, як тут `myrule`.
myrule[&#34;headers&#34;] := headers
myrule[&#34;response_headers_to_add&#34;] := response_headers_to_add
myrule[&#34;request_headers_to_remove&#34;] := request_headers_to_remove
myrule[&#34;body&#34;] := body
myrule[&#34;http_status&#34;] := status_code</code></pre>
<p>Це значення, які будуть повернуті проксі-серверу Envoy від OPA-сервера. Envoy буде використовувати ці значення для модифікації запиту і відповіді.</p>
<p>Зверніть увагу, що при поверненні JSON-обʼєкта потрібно вказувати <code>allowed</code>, а не тільки true/false. Це можна знайти <a href="https://www.openpolicyagent.org/docs/latest/envoy-primer/#output-document">в документації OPA</a>.</p>
<h4 id="change-returned-body">Зміна тіла відповіді</h4>
<p>Випробуємо нові можливості:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get</code></pre>
<p>Тепер ми можемо змінити тіло відповіді. Значення <code>403</code> змінює тіло в правилі Rego на «Unauthorized Request» (Несанкціонований запит). За допомогою попередньої команди ви повинні отримати:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >Unauthorized Request
http_code=403</code></pre>
<h4 id="change-returned-body-and-status-code">Зміна тіла, що повертається і коду статусу</h4>
<p>Запустивши запит із заголовком <code>x-force-authorized: enabled</code> ви повинні отримати тіло «Authentication Failed» і помилку «401»:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s -w &#34;\nhttp_code=%{http_code}&#34; httpbin:8000/get -H &#34;x-force-unauthenticated: enabled&#34;</code></pre>
<h4 id="adding-headers-to-request">Додавання заголовків до запиту</h4>
<p>Запустивши відповідний запит, ви повинні отримати тіло відповіді з новим заголовком <code>x-validated-by: my-security-checkpoint</code> і видаленим заголовком <code>x-force-authorized</code>:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s httpbin:8000/get -H &#34;x-force-authorized: true&#34;</code></pre>
<h4 id="adding-headers-to-response">Додавання заголовків до відповіді</h4>
<p>Запустивши той самий запит, але показавши лише заголовок, ви побачите заголовок відповіді, доданий під час перевірки Authz <code>x-add-custom-response-header: added</code>:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s -I httpbin:8000/get -H &#34;x-force-authorized: true&#34;</code></pre>
<h4 id="sharing-data-between-filters">Обмін даними між фільтрами</h4>
<p>Останнім кроком є передача даних іншим фільтрам Envoy за допомогою <code>dynamic_metadata</code>. Це корисно, коли потрібно передати дані іншому фільтру <code>ext_authz</code> у ланцюзі або вивести їх у логи застосунку.</p>
<figure style="width:75%">
    <div class="wrapper-with-intrinsic-ratio" style="padding-bottom:44.210204705163456%">
        <a data-skipendnotes="true" href="/uk/blog/2024/l7-policy-with-opa/opa3.png" title="">
            <img class="element-to-stretch" src="/uk/blog/2024/l7-policy-with-opa/opa3.png" alt="Metadata" />
        </a>
    </div>
    <figcaption></figcaption>
</figure>
<p>Для цього перегляньте формат журналу доступу, який ви налаштували раніше:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >[...]
    accessLogFormat: |
      [OPA DEMO] my-new-dynamic-metadata: &#34;%DYNAMIC_METADATA(envoy.filters.http.ext_authz)%&#34;
[...]</code></pre>
<p><code>DYNAMIC_METADATA</code> — це зарезервоване ключове слово для доступу до обʼєкта метаданих. Далі вказується назва фільтра, до якого ви хочете звернутися. У вашому випадку, імʼя <code>envoy.filters.http.ext_authz</code> автоматично створюється Istio. Ви можете перевірити це, вивівши конфігурацію Envoy:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl pc all deploy/httpbin -n my-app -oyaml | grep envoy.filters.http.ext_authz</code></pre>
<p>Ви побачите конфігурації для фільтра.</p>
<p>Тепер перевіримо динамічні метадані. У розширеному правилі ви створюєте новий запис метаданих: <code>{&quot;my-new-metadata&quot;: &quot;my-new-value&quot;}</code>.</p>
<p>Виконайте запит і перевірте логи застосунку:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -n my-app curl -c curl  -- curl -s -I httpbin:8000/get -H &#34;x-force-authorized: true&#34;
$ kubectl logs -n my-app deploy/httpbin -c istio-proxy --tail 1</code></pre>
<p>У виводі ви побачите нові атрибути, налаштовані за допомогою правил OPA Rego:</p>
<pre><code class='language-plain' data-expandlinks='true' data-repo='istio' >[...]
 my-new-dynamic-metadata: &#34;{&#34;my-new-metadata&#34;:&#34;my-new-value&#34;,&#34;decision_id&#34;:&#34;8a6d5359-142c-4431-96cd-d683801e889f&#34;,&#34;ext_authz_duration&#34;:7}&#34;
[...]</code></pre>
<h2 id="conclusion">Підсумки</h2>
<p>У цьому посібнику ми показали, як інтегрувати Istio та OPA для впровадження політик для простого мікросервісного застосунку. Ми також продемонстрували, як використовувати Rego для модифікації атрибутів запиту та відповіді. Це основний приклад для побудови системи політик на платформі, яку можуть використовувати всі команди розробників застосунків.</p>
]]></description><pubDate>Mon, 14 Oct 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/l7-policy-with-opa/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/l7-policy-with-opa/</guid><category>istio</category><category>opa</category><category>policy</category><category>platform</category><category>authorization</category></item><item><title>Зовнішня публікація: Сервісна мережа Istio для тих, хто має справи</title><description><![CDATA[<div>
    <aside class="callout quote">
        <div class="type">
            <svg class="large-icon"><use xlink:href="/img/icons.svg#callout-quote"/></svg>
        </div>
        <div class="content">Нещодавно я зробив невеликий внесок в Istio, проєкт з відкритим кодом для створення сервісних мереж. Мій внесок полягав у додаванні кількох тестів для однієї з команд CLI Istio. Якщо вам цікаві деталі, ви можете знайти pull request тут. Це були незначні зміни, але чудовий досвід навчання. Робота з Istio допомогла мені глибше зрозуміти сервісні мережі. Я з нетерпінням чекаю можливості зробити ще більше змін. У цій публікації я поясню, що таке Istio, чому цей проєкт може бути корисним та як він працює.</div>

        
    </aside>
</div>

<p><a href="https://www.lucavall.in/blog/the-istio-service-mesh-for-people-who-have-stuff-to-do">Прочитайте повну публікацію на lucavall.in</a>.</p>
]]></description><pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/link-the-istio-service-mesh-for-people-who-have-stuff-to-do/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/link-the-istio-service-mesh-for-people-who-have-stuff-to-do/</guid></item><item><title>Представляємо Sail Operator: новий спосіб керування Istio</title><description><![CDATA[<p>З нещодавнім оголошенням про <a href="/uk/blog/2024/in-cluster-operator-deprecation-announcement/">застарівання</a> In-Cluster IstioOperator в Istio 1.23 та його подальше видалення в Istio 1.24, ми хочемо підвищити обізнаність про <a href="https://github.com/istio-ecosystem/sail-operator">новий оператор</a>, який команда Red Hat розробляє для керування Istio в рамках організації <a href="https://github.com/istio-ecosystem">istio-ecosystem</a>.</p>
<p>Sail Operator керує життєвим циклом панелей управління Istio, що спрощує й робить ефективнішим процес розгортання, налаштування та оновлення Istio для адміністраторів кластерів у великих виробничих середовищах. Замість того, щоб створювати нову схему конфігурації та &ldquo;вигадувати велосипед&rdquo;, API Sail Operator побудовані навколо API Helm charts Istio. Усі параметри інсталяції та конфігурації, які надаються через Helm charts Istio, доступні через поля значень CRD Sail Operator. Це означає, що ви можете легко керувати та налаштовувати Istio за допомогою знайомих конфігурацій без необхідності вивчати додаткові елементи.</p>
<p>Sail Operator має три основні концепції ресурсів:</p>
<ul>
<li><a href="https://github.com/istio-ecosystem/sail-operator/blob/main/docs/README.md#istio-resource">Istio</a>: використовується для керування панелями управління Istio.</li>
<li><a href="https://github.com/istio-ecosystem/sail-operator/blob/main/docs/README.md#istiorevision-resource">Istio Revision</a>: представляє ревізію панелі управління, що є інстанцією Istio з певною версією та імʼям ревізії.</li>
<li><a href="https://github.com/istio-ecosystem/sail-operator/blob/main/docs/README.md#istiocni-resource">Istio CNI</a>: використовується для керування ресурсами та життєвим циклом втулка Istio CNI. Для інсталяції втулка Istio CNI створюється ресурс <code>IstioCNI</code>.</li>
</ul>
<p>Наразі основна функція Sail Operator — це стратегія оновлення. Оператор надає інтерфейс для керування оновленням панелей управління Istio. Він підтримує дві стратегії оновлення:</p>
<ul>
<li><a href="https://github.com/istio-ecosystem/sail-operator/blob/main/docs/README.md#inplace">In Place</a>: зі стратегією <code>InPlace</code>, наявна панель управління Istio замінюється новою версією, і sidecarʼи навантажень одразу підключаються до нової панелі управління. Це означає, що навантаження не потрібно переносити з однієї панелі управління на іншу.</li>
<li><a href="https://github.com/istio-ecosystem/sail-operator/blob/main/docs/README.md#revisionbased">Revision Based</a>: зі стратегією <code>RevisionBased</code>, новий екземпляр панелі управління Istio створюється для кожної зміни поля <code>Istio.spec.version</code>. Стара панель управління залишається на місці, доки всі навантаження не будуть перенесені на новий екземпляр. Додатково, прапорець <code>updateWorkloads</code> може бути встановлений для автоматичного переміщення навантажень на нову панель управління після її готовності.</li>
</ul>
<p>Ми розуміємо, що оновлення панелі управління Istio повʼязане з ризиками та може вимагати значних зусиль для великих розгортань, тому це є нашим основним фокусом на цей момент. У майбутньому ми розглядаємо можливості покращення Sail Operator для підтримки таких випадків використання, як мультиоренда та ізоляція, федерація між кластерами та спрощена інтеграція зі сторонніми проєктами.</p>
<p>Проєкт Sail Operator ще на стадії alpha і знаходиться у стадії активної розробки. Зазначимо, що як проєкт з організації istio-ecosystem, він не підтримується в рамках основного проєкту Istio. Ми активно шукаємо відгуки та внески від спільноти. Якщо ви бажаєте взяти участь у проєкті, зверніться до <a href="https://github.com/istio-ecosystem/sail-operator/blob/main/README.md">документації</a> та <a href="https://github.com/istio-ecosystem/sail-operator/blob/main/CONTRIBUTING.md">інструкцій для внесків</a>. Також ви можете випробувати новий оператор, дотримуючись вказівок у <a href="https://github.com/istio-ecosystem/sail-operator/blob/main/docs/README.md">документації для користувачів</a>.</p>
<p>Для додаткової інформації звʼяжіться з нами:</p>
<ul>
<li><a href="https://github.com/istio-ecosystem/sail-operator/discussions">Обговорення</a></li>
<li><a href="https://github.com/istio-ecosystem/sail-operator/issues">Питання</a></li>
<li><a href="https://istio.slack.com/archives/C06SE9XCK3Q">Slack</a></li>
</ul>
]]></description><pubDate>Mon, 19 Aug 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/introducing-sail-operator/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/introducing-sail-operator/</guid><category>istio</category><category>operator</category><category>sail</category><category>incluster</category><category>deprecation</category></item><item><title>Istio оголошує про визнання застарілим In-Cluster Operator</title><description><![CDATA[<p>In-Cluster Operator Istio було визнано застарілим в Istio 1.23. Користувачам, які використовують оператор, кількість яких ми оцінюємо менше ніж 10% від нашої бази користувачів, потрібно буде мігрувати до інших механізмів інсталяції та оновлення, щоб оновитися до Istio 1.24 або вище. Читайте далі, щоб дізнатися, чому ми прийняли це рішення та що потрібно зробити користувачам оператора.</p>
<h2 id="does-this-affect-you">Чи це вплине на вас?</h2>
<p>Це застарівання стосується лише користувачів <a href="https://archive.istio.io/v1.23/docs/setup/install/operator/">In-Cluster Operator</a>. <strong>Користувачі, які встановлюють Istio за допомогою команди <code>istioctl install</code> і YAML файлу <code>IstioOperator</code>, не постраждають</strong>.</p>
<p>Щоб визначити, чи це вплине на вас, виконайте команди <code>kubectl get deployment -n istio-system istio-operator</code> і <code>kubectl get IstioOperator</code>. Якщо обидві команди повертають непорожні значення, ваш кластер знаходиться під впливом цього застарівання. Згідно з останніми опитуваннями, ми очікуємо, що це вплине на менше ніж 10% користувачів Istio.</p>
<p>Інсталяції Istio на основі оператора продовжать працювати безстроково, але не зможуть бути оновлені вище 1.23.x.</p>
<h2 id="when-do-i-need-to-migrate">Коли потрібно мігрувати?</h2>
<p>Відповідно до політики визнання функцій застарілими в Istio для бета-функцій, In-Cluster Operator Istio буде видалено з релізом Istio 1.24, приблизно через три місяці після цього оголошення. Istio 1.23 буде підтримуватись до березня 2025 року, після чого користувачам оператора потрібно буде мігрувати до іншого механізму інсталяції для збереження підтримки.</p>
<h2 id="how-do-i-migrate">Як мігрувати?</h2>
<p>Проєкт Istio продовжить підтримувати інсталяцію та оновлення через команду <code>istioctl</code>, а також з допомогою Helm. Через популярність Helm в екосистемі розробки платформ, ми рекомендуємо більшості користувачів мігрувати на Helm. <code>istioctl install</code> базується на шаблонах Helm, і в майбутніх версіях можливе глибше інтегрування з Helm.</p>
<p>Інсталяції Helm також можуть бути керовані з допомогою GitOps інструментів, таких як <a href="https://fluxcd.io/">Flux</a> або <a href="https://argo-cd.readthedocs.io/">Argo CD</a>.</p>
<p>Користувачі, які віддають перевагу шаблону оператора для запуску Istio, можуть мігрувати до одного з двох нових проєктів екосистеми Istio: Classic Operator Controller або Sail Operator.</p>
<h3 id="migrating-to-helm">Міграція на Helm</h3>
<p>Міграція на Helm вимагає переведення вашого YAML файлу <code>IstioOperator</code> у Helm <code>values.yaml</code>. Інструменти для підтримки цієї міграції будуть надані разом з релізом Istio 1.24.</p>
<h3 id="migrating-to-istioctl">Міграція на istioctl</h3>
<p>Визначте ваш ресурс <code>IstioOperator</code>: має бути лише один результат.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get IstioOperator</code></pre>
<p>Використовуючи імʼя вашого ресурсу, завантажте конфігурацію вашого оператора у форматі YAML:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get IstioOperator &lt;name&gt; &gt; istio.yaml</code></pre>
<p>Вимкніть In-Cluster Operator. Це не вимкне вашу панель управління або порушить ваш поточний трафік мережі.</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl scale deployment -n istio-system istio-operator –replicas 0</code></pre>
<p>Коли ви будете готові оновити Istio до версії 1.24 або пізнішої, дотримуйтесь <a href="/uk/docs/setup/upgrade/canary/">інструкцій з оновлення</a>, використовуючи файл <code>istio.yaml</code>, який ви завантажили вище.</p>
<p>Після завершення та перевірки вашої міграції виконайте наступні команди для очищення ресурсів оператора:</p>
<pre><code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete deployment -n istio-system istio-operator
$ kubectl delete customresourcedefinition istiooperator</code></pre>
<h3 id="migrating-to-the-classic-operator-controller">Міграція на Classic Operator Controller</h3>
<p>Новий проєкт екосистеми, <a href="https://github.com/istio-ecosystem/classic-operator-controller">Classic Operator Controller</a>, є форком оригінального контролера, вбудованого в Istio. Цей проєкт підтримує той самий API та кодову базу, що й оригінальний оператор, але підтримується поза основним проєктом Istio.</p>
<p>Оскільки API є таким самим, міграція є прямолінійною: потрібно лише інсталювати новий оператор.</p>
<p>Classic Operator Controller не підтримується проєктом Istio.</p>
<h3 id="migrating-to-sail-operator">Міграція на Sail Operator</h3>
<p>Новий проєкт екосистеми, <a href="https://github.com/istio-ecosystem/sail-operator">Sail Operator</a>, може інсталювати та керувати життєвим циклом панелі управління Istio у Kubernetes або OpenShift кластері.</p>
<p>API Sail Operator побудовані навколо API Helm charts Istio. Усі параметри інсталяції та конфігурації, які надаються через Helm charts Istio, доступні через поля <code>values:</code> CRD Sail Operator.</p>
<p>Sail Operator не підтримується проєктом Istio.</p>
<h2 id="what-is-an-operator-and-why-did-istio-have-one">Що таке оператор і чому Istio його мав?</h2>
<p><a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">Шаблон оператора</a> був популяризований CoreOS у 2016 році метод кодифікації людського інтелекту в код. Найбільш поширене використання — це оператор бази даних, де користувач може мати кілька екземплярів бази даних в одному кластері з кількома поточними операційними завданнями (резервні копії, вакуумування, розподіл).</p>
<p>Istio вперше представив istioctl і In-Cluster Operator у версії 1.4, у відповідь на проблеми з Helm v2. Того ж часу було представлено Helm v3, який вирішив проблеми спільноти і є переважним методом інсталяції програмного забезпечення в Kubernetes сьогодні. Підтримка Helm v3 була додана в Istio 1.8.</p>
<p>In-Cluster Operator Istio обробляв інсталяцію компонентів сервісної мережі — операцію, яку зазвичай виконуєте один раз і для одного екземпляра на кластер. Можна вважати це способом запуску istioctl всередині вашого кластера. Однак це означало, що у вас є контролер з високими привілеями всередині вашого кластера, що послаблює вашу безпеку. Він не обробляє жодних поточних адміністративних завдань (резервні копії, знімки тощо, не є вимогами для запуску Istio).</p>
<p>Istio оператор є чимось, що потрібно встановити в кластер, що означає, що ви вже повинні управляти інсталяцією чогось. Використання його для оновлення кластера також спочатку вимагало завантаження та запуску нової версії istioctl.</p>
<p>Використання оператора означає, що ви створили рівень абстракції, де вам потрібно мати параметри у вашому власному ресурсі для налаштування всього, що ви можете бажати змінити в інсталяції. Istio обійшов це, пропонуючи API <code>IstioOperator</code>, яке дозволяє конфігурувати параметри інсталяції. Цей ресурс використовується як In-Cluster Operator, так і istioctl install, тому є тривіальний шлях міграції для користувачів оператора.</p>
<p>Три роки тому, приблизно в часі Istio 1.12, ми оновили нашу документацію, щоб сказати, що використання оператора для нових інсталяцій Istio не рекомендується, і що користувачі повинні використовувати istioctl або Helm для інсталяції Istio.</p>
<p><a href="https://blog.howardjohn.info/posts/istio-install/">Наявність трьох різних методів інсталяції викликало плутанину</a>, і для того, щоб забезпечити найкращий досвід для людей, які використовують Helm або istioctl, понад 90% нашої бази установок, ми вирішили офіційно визнати застарілим In-Cluster Operator в Istio 1.23.</p>
]]></description><pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/in-cluster-operator-deprecation-announcement/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/in-cluster-operator-deprecation-announcement/</guid><category>operator</category><category>deprecation</category></item><item><title>Прощавай, sidecar: Ambient режим Istio досяг бета-версії в v1.22</title><description><![CDATA[<p>Сьогодні революційний новий режим Ambient <span class="term" data-title="Панель даних" data-body="&lt;p&gt;Панель даних — це частина mesh, яка безпосередньо обробляє та маршрутизує трафік між екземплярами навантаження.&lt;/p&gt;
&lt;p&gt;У режимі &lt;span class=&#34;term&#34; data-title=&#34;Sidecar&#34; data-body=&#34;&amp;lt;p&amp;gt;Sidecar загалом є контейнером, який працює поряд з основним застосунком, надаючи додаткову функціональність. В Istio режим sidecar — це &amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#data-plane-mode&amp;#34;&amp;gt;режим панелі даних&amp;lt;/a&amp;gt;, який запускає проксі &amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#envoy&amp;#34;&amp;gt;Envoy&amp;lt;/a&amp;gt; поряд з кожним
&amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#pod&amp;#34;&amp;gt;Podʼом&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&#34;&gt;sidecar&lt;/span&gt; панель даних Istio використовує проксі &lt;a href=&#34;/v1.25/uk/docs/reference/glossary/#envoy&#34;&gt;Envoy&lt;/a&gt;, розгорнуті як sidecar, для медіації та контролю всього трафіку, який надсилають і отримують ваші сервіси mesh.&lt;/p&gt;
&lt;p&gt;У режимі &lt;span class=&#34;term&#34; data-title=&#34;Ambient&#34; data-body=&#34;&amp;lt;p&amp;gt;Режим ambient (режим оточення) належить до &amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#data-plane-mode&amp;#34;&amp;gt;режиму панелі даних&amp;lt;/a&amp;gt;, що складається з компонента для кожного вузла та, за бажанням, компонента для кожного простору імен. Мережа, що створюється при встановленні Istio в режимі ambient, може називатися ambient &amp;lt;em&amp;gt;mesh&amp;lt;/em&amp;gt;. Режим ambient є альтернативою розгортанню в &amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#sidecar&amp;#34;&amp;gt;режимі sidecar&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&#34;&gt;ambient&lt;/span&gt; панель даних Istio використовує проксі &lt;span class=&#34;term&#34; data-title=&#34;ztunnel&#34; data-body=&#34;&amp;lt;p&amp;gt;Ztunnel належить до компонента проксі вузла в режимі &amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#ambient&amp;#34;&amp;gt;ambient&amp;lt;/a&amp;gt; панелі даних. Ztunnel працює на кожному вузлі й безпечно передає трафік, використовуючи протокол &amp;lt;a href=&amp;#34;/uk/docs/reference/glossary/#hbone&amp;#34;&amp;gt;HBONE&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Детальнішу інформацію можна знайти в &amp;lt;a href=&amp;#34;/uk/docs/ambient/architecture/data-plane/&amp;#34;&amp;gt;документації по панелі даних ambient&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;
&#34;&gt;ztunnel&lt;/span&gt; на рівні вузла, розгорнуті як DaemonSet, для медіації та контролю всього трафіку, який надсилають і отримують ваші сервіси mesh.&lt;/p&gt;
">панелі даних</span> в Istio досяг бета-версії. Ambient режим розроблений для спрощення операцій, розширення сумісності з застосунками та зменшення витрат на інфраструктуру. Він забезпечує панель даних без sidecar, інтегровану у вашу інфраструктуру, залишаючи основні функції Istio, такі як безпека нульового рівня довіри, телеметрія та управління трафіком.</p>
<p>Ambient режим <a href="/blog/2022/introducing-ambient-mesh/">був оголошений у вересні 2022 року</a>. З того часу наша спільнота впродовж 20 місяців важкої роботи та співпраці, з участю від Solo.io, Google, Microsoft, Intel, Aviatrix, Huawei, IBM, Red Hat та багатьох інших, зробила значний внесок. Статус бета-версії в 1.22 вказує на те, що функції ambient режиму тепер готові до промислового використання з відповідними запобіжними заходами. Це величезна подія для Istio, що забезпечує як функції рівня 4, так і рівня 7 для готовності до використання без sidecar контейнерів.</p>
<h2 id="why-ambient-mode">Чому режим Ambient?</h2>
<p>Дослухаючись до відгуків користувачів Istio, ми спостерігали зростаючий попит на можливості мережі для застосунків — але почули, що багато з вас вважали витрати ресурсів та операційну складність sidecar важкими для подолання. Проблеми, якими користувачі sidecar ділилися з нами, включають те, як Istio може зламати застосунки після додавання sidecar контейнерів, велике споживання CPU та памʼяті sidecar контейнерами та незручність вимоги перезапуску застосунків з кожним новим випуском проксі.</p>
<p>Як спільнота, ми спроєктували режим ambient для усунення цих проблем, прибираючи попередні барʼєри складності, з якими стикалися користувачі, які намагалися впровадити сервісну мережу. Новий набір функцій був названий &ldquo;ambient режим&rdquo; (режим оточення) оскільки він був призначений бути прозорим для вашого застосунку, забезпечуючи відсутність необхідності додаткової конфігурації для його прийняття, і не вимагав перезапуску застосунків користувачами.</p>
<p>У режимі ambient додати чи видалити застосунки з мережі дуже просто. Тепер ви можете просто <a href="/uk/docs/ambient/usage/add-workloads/">позначити простір імен</a>, і всі застосунки в цьому просторі імен будуть додані до мережі. Це негайно забезпечує весь трафік з mTLS, все без sidecar контейнерів чи потреби перезапуску застосунків.</p>
<p>Перегляньте <a href="/blog/2022/introducing-ambient-mesh/">блог про представлення Ambient Mesh</a> для отримання додаткової інформації про те, чому ми створили режим ambient.</p>
<h2 id="how-does-ambient-mode-make-adoption-easier">Як режим Ambient полегшує адаптацію?</h2>
<p>Режим ambient Istio вводить легкі, спільні проксі рівня 4 (L4) та необовʼязкові проксі рівня 7 (L7), усуваючи необхідність традиційних sidecar проксі з панелі даних. Основна інновація за режимом ambient полягає в тому, що він розділяє обробку L4 і L7 на два окремі шари. Такий шаровий підхід дозволяє вам поступово впроваджувати Istio, забезпечуючи плавний перехід від відсутності мережі до безпечного накладення (L4), до необовʼязкової повної обробки L7, в основі простору імен, за необхідності, по всьому вашому флоту.</p>
<p>Режим ambient працює без будь-яких модифікацій ваших поточних розгортань Kubernetes. Ви можете позначити простір імен, щоб додати всі його навантаження до мережі або вибрати певні розгортання за потреби. Використовуючи режим ambient, користувачі оминають деякі з попередніх обмежувальних елементів моделі sidecar контейнерів. Протоколи &ldquo;server-send-first&rdquo; тепер працюють, більшість зарезервованих портів тепер доступні, і можливість для контейнерів оминати sidecar контейнер, або зловмисно, або ні, — усунена.</p>
<p>Легкий спільний L4 проксі називається <em><a href="/uk/docs/ambient/overview/#ztunnel">ztunnel</a></em> (тунель нульової довіри). Ztunnel радикально зменшує витрати на запуск мережі, усуваючи потребу в потенційному перевиділенню памʼяті та CPU в кластері для обробки очікуваних навантажень. У деяких випадках економія може перевищувати 90% і більше, при цьому забезпечуючи безпеку нульового рівня довіри за допомогою мTLS з криптографічною ідентичністю, простими політиками авторизації L4 та телеметрією.</p>
<p>Проксі L7 називаються <em><a href="/uk/docs/ambient/overview/#waypoint-proxies">waypoints</a></em>. Waypoints обробляють функції L7 такі як маршрутизація трафіку, докладний контроль політики авторизації та стійкість на промисловому рівні. Waypoints працюють поза вашими розгортаннями застосунків і можуть масштабуватися незалежно від ваших потреб, хай то для всього простору імен або для кількох сервісів у просторі імен. В порівнянні з sidecar, вам не потрібен waypoint на кожен pod застосунку, і ви можете ефективно масштабувати свій waypoint залежно від його обсягу, таким чином зберігаючи значні кількості CPU і памʼяті у більшості випадків.</p>
<p>Розділення між рівнем безпеки L4 і рівнем обробки L7 дозволяє поступову адаптацію панелі даних до режиму ambient, на відміну від ранньої бінарної &ldquo;все-разом&rdquo; інʼєкції sidecar контейнерів. Користувачі можуть почати з рівня безпеки L4, який пропонує більшість функцій, для яких люди впроваджують Istio (mTLS, політика авторизації та телеметрія). Складна обробка L7, така як повторні спроби, розподіл трафіку, балансування навантаження та збір спостережень, можна додати поступово у разі потреби в кожному конкретному випадку.</p>
<h2 id="what-is-in-the-scope-of-the-beta">Що в рамках бета-версії?</h2>
<p>Ми рекомендуємо вам дослідити наступні функції бета-версії режиму ambient у промисловому застосуванні з відповідними запобіжними заходами, після перевірки їх у тестових середовищах:</p>
<ul>
<li><a href="/uk/docs/ambient/install/">Інсталяція Istio з підтримкою режиму ambient</a>.</li>
<li><a href="/uk/docs/ambient/usage/add-workloads/">Додавання ваших навантажень до мережі</a> для отримання мTLS з криптографічною ідентичністю, <a href="/uk/docs/ambient/usage/l4-policy/">політик авторизації L4</a> та телеметрії.</li>
<li><a href="/uk/docs/ambient/usage/waypoint/">Конфігурація waypoints</a> для <a href="/uk/docs/ambient/usage/l7-features/">використання функцій L7</a> таких як перемикання трафіку, маршрутизація запитів та контроль докладної політики авторизації.</li>
<li>Підключення шлюзу вхідного трафіку Istio до навантажень у режимі ambient, підтримуючи всі наявні API Istio.</li>
<li>Використання <code>istioctl</code> для управління waypoint&rsquo;ами та усунення несправностей ztunnel і waypoint&rsquo;ів.</li>
</ul>
<h3 id="alpha-features">Альфа-функції</h3>
<p>Багато інших функцій, які ми хочемо включити в режим ambient, були реалізовані, але залишаються в статусі альфа у цьому випуску. Будь ласка, допоможіть перевірити їх, щоб вони могли бути підвищені до бета-версії в 1.23 або пізніше:</p>
<ul>
<li>Мільтикластерні встановлення</li>
<li>Проксіювання DNS</li>
<li>Взаємодія з sidecar</li>
<li>Підтримка IPv6/Двох стеків</li>
<li>Підтримка SOCKS5 (для виводу)</li>
<li>Класичні API Istio (<code>VirtualService</code> та <code>DestinationRule</code>)</li>
</ul>
<h3 id="roadmap">Плани</h3>
<p>У нас є кілька функцій, які ще не реалізовані в режимі ambient, але заплановані для майбутніх випусків:</p>
<ul>
<li>Контрольований вихідний трафік</li>
<li>Підтримка мультимереж</li>
<li>Покращення повідомлень <code>status</code> на ресурсах для допомоги в усуненні несправностей та розумінні мережі</li>
<li>Підтримка віртуальних машин</li>
</ul>
<h2 id="what-about-sidecars">Що з sidecar?</h2>
<p>Sidecar контейнери не зникають і залишаються в Istio. Ви можете продовжувати використовувати sidecar контейнери, і вони залишаться повністю підтримуваними. Для будь-якої функції поза межами альфа- або бета-версії режиму ambient, слід розглянути використання sidecar режиму до того, як функція буде додана до режиму ambient. Деякі випадки використання, такі як перемикання трафіку на основі міток джерел, все ще краще реалізовані за допомогою режиму sidecar. Хоча ми вважаємо, що більшість випадків використання будуть найкраще обслужені мережею в режимі ambient, проєкт Istio залишається відданим постійній підтримці sidecar режиму.</p>
<h2 id="try-ambient-mode-today">Спробуйте режим ambient сьогодні</h2>
<p>З випуском 1.22 Istio та бета-версією режиму ambient, тепер простіше ніж будь-коли спробувати Istio на ваших власних навантаженнях. Слідуйте <a href="/uk/docs/ambient/getting-started/">інструкції з початку роботи</a>, щоб дослідити режим ambient, або прочитайте наші нові <a href="/uk/docs/ambient/usage/">посібники користувача</a>, щоб дізнатися, як поступово впроваджувати ambient для mTLS та політики авторизації L4, управління трафіком, розширеної політики авторизації L7 та іншого. Ви можете спілкуватися з розробниками в каналі #ambient на <a href="https://slack.istio.io">Istio Slack</a>, або скористатися форумом discussion на <a href="https://github.com/istio/istio/discussions">GitHub</a> для будь-яких запитань, які можуть у вас виникнути.</p>
]]></description><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><link>/v1.25//uk/blog/2024/ambient-reaches-beta/</link><guid isPermaLink="true">/v1.25//uk/blog/2024/ambient-reaches-beta/</guid><category>ambient</category><category>sidecars</category></item></channel></rss>