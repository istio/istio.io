"use strict";var x=Object.defineProperty,y=Object.defineProperties;var z=Object.getOwnPropertyDescriptors;var p=Object.getOwnPropertySymbols;var S=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable;var v=(t,o,e)=>o in t?x(t,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[o]=e,d=(t,o)=>{for(var e in o||(o={}))S.call(o,e)&&v(t,e,o[e]);if(p)for(var e of p(o))P.call(o,e)&&v(t,e,o[e]);return t},u=(t,o)=>y(t,z(o));var w=(t,o,e)=>new Promise((a,s)=>{var l=n=>{try{m(e.next(n))}catch(i){s(i)}},r=n=>{try{m(e.throw(n))}catch(i){s(i)}},m=n=>n.done?a(n.value):Promise.resolve(n.value).then(l,r);m((e=e.apply(t,o)).next())});import*as f from"three";const C=`
      #define PI 3.14159265359
  
      // Uniform variables for time and point size, as well as parameters for two transformations
      uniform float u_time;
      uniform float u_pointsize;
      uniform float u_transformation_amp_1;
      uniform float u_transformation_freq_1;
      uniform float u_transformation_speed_1;
      uniform float u_transformation_amp_2;
      uniform float u_transformation_freq_2;
      uniform float u_transformation_speed_2;
  
      void main() {
        // Initialize position with the vertex's original position
        vec3 pos = position;
        
        // Apply two sinusoidal transformations to the z-coordinate of the position
        pos.z += sin(pos.x * u_transformation_freq_1 + u_time * u_transformation_speed_1) * u_transformation_amp_1;
        pos.z += cos(pos.y * u_transformation_freq_2 - u_time * u_transformation_speed_2 * 0.6) * u_transformation_amp_2;
        
        // Adjust the point size based on the absolute z-coordinate
        gl_PointSize = max(u_pointsize + abs(pos.z) * 6.0, 0.0);
        
        // Apply model-view and projection transformations to the position
        vec4 mvm = modelViewMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvm;
      }
    `,E=`
      // Uniform variable for time
      uniform float u_time;
      #ifdef GL_ES
      precision mediump float;
      #endif
  
      void main() {
        // Calculate the distance from the center of the point
        vec2 st = gl_PointCoord - vec2(0.5);
        float r = length(st);
  
        // Discard fragments outside a circular region
        if (r > 0.5) {
          discard;
        }
  
        // Calculate alpha (transparency) based on the depth of the fragment
        float alpha = 1.0 - gl_FragCoord.z * 1.095;
        alpha = clamp(alpha, 0.0, 1.0);

        // Set the final fragment color with a blue tone and transparency
        gl_FragColor = vec4(vec3(0.42, 0.635, 0.835), alpha);
      }
    `;function b(t=45,o=.1,e=100,a={x:0,y:0,z:0},s={x:0,y:0,z:0},l=window.innerWidth/window.innerHeight){const r=new f.PerspectiveCamera(t,l,o,e);return r.position.set(a.x,a.y,a.z),r.lookAt(s.x,s.y,s.z),r.updateProjectionMatrix(),r}function R(t={}){const o=document.getElementById("hero"),e=new f.WebGLRenderer(u(d({},t),{alpha:!0}));return e.domElement.id="hero-animation",e.setPixelRatio(window.devicePixelRatio),e.setSize(o.offsetWidth,o.offsetHeight),e.setClearColor(16777215,0),e.domElement.id="hero-animation",e}function q(t,o,e,a,s=!1,l=getDefaultUniforms()){const r=document.getElementById("hero");r.appendChild(e.domElement),window.addEventListener("resize",()=>{let i=document.getElementById("hero");a.aspect=i.offsetWidth/i.offsetHeight,a.updateProjectionMatrix(),e.setSize(i.offsetWidth,i.offsetHeight),l.u_resolution!==void 0&&(l.u_resolution.value.x=window.innerWidth*window.devicePixelRatio,l.u_resolution.value.y=window.innerHeight*window.devicePixelRatio)}),t.updateScene===void 0&&(t.updateScene=(i,_)=>{}),Object.assign(t,u(d({},t),{container:r}));const m=new f.Clock,n=()=>{s&&requestAnimationFrame(n);const i=m.getDelta(),_=m.getElapsedTime();l.u_time.value=_,t.updateScene(i,_),e.render(o,a)};t.initScene().then(n).then(()=>{e.info.reset()}).catch(i=>{console.log(i)})}let g=new f.Scene,H=R({antialias:!1}),c=b(60,1,100,{x:0,y:0,z:4.5});const h={u_time:{value:0},u_resolution:{value:{x:window.innerWidth*window.devicePixelRatio,y:window.innerHeight*window.devicePixelRatio}},u_pointsize:{value:3},u_transformation_freq_1:{value:3},u_transformation_amp_1:{value:.8},u_transformation_speed_1:{value:.25},u_transformation_freq_2:{value:2},u_transformation_amp_2:{value:.7},u_transformation_speed_2:{value:.2}};let W={vertexShader:C,fragmentShader:E,initScene(){return w(this,null,function*(){this.geometry=new f.PlaneGeometry(10,5,50,40);const t=new f.ShaderMaterial({uniforms:u(d({},h),{cameraPosition:{value:c.position}}),vertexShader:this.vertexShader,fragmentShader:this.fragmentShader,transparent:!0,depthTest:!1});this.mesh=new f.Points(this.geometry,t),g.add(this.mesh),this.mesh.rotation.x=3.1415/2,this.mesh.rotation.y=3.1415/4})},updateScene(t,o){h.u_time.value+=t*.001,this.mesh.material.uniforms.cameraPosition.value.copy(c.position)}};q(W,g,H,c,!0,h);
//# sourceMappingURL=headerAnimation.min.js.map
