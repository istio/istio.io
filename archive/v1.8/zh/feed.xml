<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Istio Blog and News</title><description>Connect, secure, control, and observe services.</description><link>/v1.8</link><image><url>/v1.8/favicons/android-192x192.png</url><link>/v1.8</link></image><category>Service mesh</category><item><title>Istio 1.4.5 发布公告</title><description>
&lt;p>此版本包含一些 bug 修复程序，可提高稳定性。此发行说明描述了 Istio 1.4.4 和 Istio 1.4.5 之间的区别。&lt;/p>
&lt;p>以下修复程序着重于节点重新启动期间发生的各种错误。如果您在使用 Istio CNI，或重启节点，则强烈建议您进行升级。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/1.4.5">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.4/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.4.4...1.4.5">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="improvements">改进&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> 节点重启触发的 bug，该 bug 会导致 Pod 接收到错误的配置（&lt;a href="https://github.com/istio/istio/issues/20676">Issue 20676&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;a href="/v1.8/zh/docs/setup/additional-setup/cni/">Istio CNI&lt;/a> 的健壮性。以前，当节点重新启动时，可能会在安装 CNI 之前就创建新的 Pod，从而导致在没有配置 &lt;code>iptables&lt;/code> 规则的情况下创建 Pod（&lt;a href="https://github.com/istio/istio/issues/14327">Issue 14327&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> MCP 指标，现在会包含 MCP 响应的大小，而不只是包含请求（&lt;a href="https://github.com/istio/istio/issues/21049">Issue 21049&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4.5/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4.5/</guid></item><item><title>对 Istio 1.3 的支持已终止</title><description>&lt;p>如&lt;a href="/v1.8/zh/news/support/announcing-1.3-eol/">先前宣布&lt;/a>的一样, 对 Istio 1.3 的支持现已正式终止。&lt;/p>
&lt;p>我们将不再为 1.3 提供针对安全问题和关键错误的修复程序，因此，如果您尚未升级，
我们建议您升级到最新版本的 Istio (1.8.3)。&lt;/p></description><pubDate>Fri, 14 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.3-eol-final/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.3-eol-final/</guid></item><item><title>ISTIO-SECURITY-2020-002</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8843">CVE-2020-8843&lt;/a>&lt;br>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td>7.4 &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV%3aN%2fAC%3aH%2fPR%3aN%2fUI%3aN%2fS%3aU%2fC%3aH%2fI%3aH%2fA%3aN">AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:N&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
1.3 to 1.3.6&lt;br>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Istio 1.3 到 1.3.6 包含了影响 Mixer 策略检查的漏洞。&lt;/p>
&lt;p>注意：我们在 Istio 1.4.0 以及 Istio 1.3.7 中默认地修复了该漏洞。
Istio 1.4.0 中的一个&lt;a href="https://github.com/istio/istio/issues/12063">问题&lt;/a>及其&lt;a href="https://github.com/istio/istio/pull/17692">修复&lt;/a>是一个非安全性问题。我们在 2019 年 12 月将该问题重新分类为漏洞。
&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8843">CVE-2020-8843&lt;/a>&lt;/strong>：在某些情况下，可以绕过特定配置的 Mixer 策略。Istio-proxy 在 ingress 处接受 &lt;code>x-istio-attributes&lt;/code> header，当 Mixer 策略有选择地应用至 source 时，等价于应用至 ingress，其可能会影响策略决策。
为了避免这种情况，Istio 必须启用并以指定方式使用 Mixer 策略。在 Istio 1.3 和 1.4 中，默认情况下未启用此功能。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>对于 Istio 1.3.x 部署: 请升级至 &lt;a href="/v1.8/zh/news/releases/1.3.x/announcing-1.3.7">Istio 1.3.7&lt;/a> 或更高的版本。&lt;/li>
&lt;/ul>
&lt;h2 id="credit">鸣谢&lt;/h2>
&lt;p>Istio 团队在此对 &lt;a href="https://www.splunk.com/">Splunk&lt;/a> 的 Krishnan Anantheswaran 和 Eric Zhang 提供的私人 bug 报告表示感谢。&lt;/p>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2020-002/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2020-002/</guid><category>CVE</category></item><item><title>ISTIO-SECURITY-2020-001</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8595">CVE-2020-8595&lt;/a>&lt;br>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td>9.0 &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV%3aN%2fAC%3aH%2fPR%3aN%2fUI%3aN%2fS%3aC%2fC%3aH%2fI%3aH%2fA%3aH">AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
1.3 to 1.3.7&lt;br>
1.4 to 1.4.3&lt;br>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Istio 1.3 到 1.3.7 以及 1.4 到 1.4.3 容易受到一个新发现漏洞的攻击，其会影响&lt;a href="/v1.8/zh/docs/reference/config/security/istio.authentication.v1alpha1/#Policy">认证策略&lt;/a>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8595">CVE-2020-8595&lt;/a>&lt;/strong>：Istio 身份认证策略精确路径匹配逻辑中的一个 bug，允许在没有有效 JWT 令牌的情况下，对资源进行未经授权的访问。此 bug 会影响所有支持基于路径触发规则的 JWT 身份验证策略的 Istio 版本。Istio JWT 过滤器中用于精确路径匹配的逻辑包括查询字符串或片段，而不是在匹配之前将其剥离。这意味着攻击者可以通过在受保护的路径之后添加 &lt;code>？&lt;/code> 或 &lt;code>##&lt;/code> 字符来绕过 JWT 验证。&lt;/li>
&lt;/ul>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>对于 Istio 1.3.x 部署: 请升级至 &lt;a href="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8">Istio 1.3.8&lt;/a> 或更高的版本。&lt;/li>
&lt;li>对于 Istio 1.4.x 部署: 请升级至 &lt;a href="/v1.8/zh/news/releases/1.4.x/announcing-1.4.4">Istio 1.4.4&lt;/a> 或更高的版本。&lt;/li>
&lt;/ul>
&lt;h2 id="credit">鸣谢&lt;/h2>
&lt;p>Istio 团队在此对 &lt;a href="https://aspenmesh.com/2H8qf3r">Aspen Mesh&lt;/a> 的原始错误报告和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8595">CVE-2020-8595&lt;/a> 的修复代码表示感谢。&lt;/p>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2020-001/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2020-001/</guid><category>CVE</category></item><item><title>Istio 1.4.4 发布公告</title><description>
&lt;p>此版本包含一些错误修复程序，以改善健壮性和用户体验，并修复了&lt;a href="/v1.8/zh/news/security/istio-security-2020-001">我们在 2020 年 2 月 11 日新闻&lt;/a>中描述的安全漏洞。&lt;a href="/v1.8/zh/news/security/istio-security-2020-001">我们在 2020 年 2 月 11 日新闻&lt;/a>中描述的安全漏洞的修复程序。此发行说明描述了 Istio 1.4.3 和 Istio 1.3.4 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.4.4"
data-downloadbuttontext="DOWNLOAD 1.4.4"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.4.4)'
data-updatebutton='了解 Istio 1.4.5'
data-updatehref="/v1.8/zh/news/releases/1.4.x/announcing-1.4.5/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.4/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.4.3...1.4.4">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2020-001&lt;/strong> 在 &lt;code>AuthenticationPolicy&lt;/code> 中发现了错误的输入验证。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8595">CVE-2020-8595&lt;/a>&lt;/strong>：Istio 的&lt;a href="/v1.8/zh/docs/reference/config/security/istio.authentication.v1alpha1/#Policy">认证策略&lt;/a>精确路径匹配逻辑中的一个 bug，允许在没有效的 JWT 令牌、未经授权的情况下访问资源。&lt;/p>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> Debian &lt;code>iptables&lt;/code> 脚本的包（&lt;a href="https://github.com/istio/istio/issues/19615">Issue 19615&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 当多次使用同一端口时 Pilot 会生成错误的 Envoy 配置的问题（&lt;a href="https://github.com/istio/istio/issues/19935">Issue 19935&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 运行多个 Pilot 实例可能导致崩溃的问题（&lt;a href="https://github.com/istio/istio/issues/20047">Issue 20047&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 将部署规模收缩为 0 时，一个潜在的从 Pilot 到 Envoy 配置推送洪流的问题（&lt;a href="https://github.com/istio/istio/issues/17957">Issue 17957&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 当 pod 名称中包含点 &lt;code>.&lt;/code> 时，Mixer 无法从 request/response 中获取正确信息的问题（&lt;a href="https://github.com/istio/istio/issues/20028">Issue 20028&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> Pilot 有时候不能正确的将 pod 配置发送至 Envoy 的问题（&lt;a href="https://github.com/istio/istio/issues/19025">Issue 19025&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 启用了 SDS 的 Sidecar 注入器，会覆盖 pod 的 &lt;code>securityContext&lt;/code> 部分，而不是仅对其进行修补的问题（&lt;a href="https://github.com/istio/istio/issues/20409">Issue 20409&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="improvements">改进&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong> 与 Google CA 有了更好的兼容性。（Issues &lt;a href="https://github.com/istio/istio/issues/20530">20530&lt;/a>, &lt;a href="https://github.com/istio/istio/issues/20560">20560&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 当没有正确配置使用 JWT 的策略时，添加了分析器错误消息（Issues &lt;a href="https://github.com/istio/istio/issues/20884">20884&lt;/a>, &lt;a href="https://github.com/istio/istio/issues/20767">20767&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4.4/</guid></item><item><title>Istio 1.3.8 发布公告</title><description>
&lt;p>此版本包含了&lt;a href="/v1.8/zh/news/security/istio-security-2020-001">我们在 2020 年 2 月 11 日的新闻&lt;/a>中描述的安全漏洞的修复程序。此发行说明描述了 Istio 1.3.7 和 Istio 1.3.8 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/1.3.8">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.7...1.3.8">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2020-001&lt;/strong> 在 &lt;code>AuthenticationPolicy&lt;/code> 中发现了错误的输入验证。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8595">CVE-2020-8595&lt;/a>&lt;/strong>：Istio 的&lt;a href="/v1.8/zh/docs/reference/config/security/istio.authentication.v1alpha1/#Policy">认证策略&lt;/a>精确路径匹配逻辑中的一个 bug，允许在没有效的 JWT 令牌、未经授权的情况下访问资源。&lt;/p></description><pubDate>Tue, 11 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/</guid></item><item><title>Istio 1.3.7 发布公告</title><description>
&lt;p>此版本发布了包含提高系统稳定性的 bug 修复程序，下面是 Istio 1.3.6 和 Istio 1.3.7 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.7"
data-downloadbuttontext="DOWNLOAD 1.3.7"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.7)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.6...1.3.7">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> 修复了 Citadel 中的根证书轮换的问题，以将 value 从过期的根证书复用到新的根证书中（&lt;a href="https://github.com/istio/istio/issues/19644">Issue 19644&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 修复了遥测的问题，以忽略网关转发属性。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 修复了 sidecar 注入到 pod 后，出口容器无端口的问题（&lt;a href="https://github.com/istio/istio/issues/18594">Issue 18594&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 添加了对包含点 &lt;code>.&lt;/code> 的 pod 名的遥测支持（&lt;a href="https://github.com/istio/istio/issues/19015">Issue 19015&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 在 Citadel 代理中，添加了对生成 &lt;code>PKCS＃8&lt;/code> 私钥的支持 (&lt;a href="https://github.com/istio/istio/issues/19948">Issue 19948&lt;/a>).&lt;/li>
&lt;/ul>
&lt;h2 id="minor-enhancements">次要改进&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Improved&lt;/strong> 改进注入模板，以完全指定 &lt;code>securityContext&lt;/code>，从而允许 &lt;code>PodSecurityPolicies&lt;/code> 正确地验证注入的 deployment（&lt;a href="https://github.com/istio/istio/issues/17318">Issue 17318&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 添加了对代理容器设置 &lt;code>lifecycle&lt;/code> 的支持。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 在 Stackdriver Mixer 适配器中，添加了设置网格 UID 的支持（&lt;a href="https://github.com/istio/istio/issues/17952">Issue 17952&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="/v1.8/zh/news/security/istio-security-2020-002">&lt;strong>ISTIO-SECURITY-2020-002&lt;/strong>&lt;/a> 由于不正确地接受某些请求 header，导致可绕过 Mixer 策略检查。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-8843">CVE-2020-8843&lt;/a>&lt;/strong>：在某些情况下，可以绕过特定配置的 Mixer 策略。Istio-proxy 在 ingress 处接受 &lt;code>x-istio-attributes&lt;/code> header，当 Mixer 策略有选择地应用至 source 时，等价于应用至 ingress，其可能会影响策略决策。Istio 1.3 到 1.3.6 容易受到攻击。&lt;/p></description><pubDate>Tue, 04 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.7/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.7/</guid></item><item><title>对 Istio 1.3 的支持将于 2020 年 2 月 14 日终止</title><description>&lt;p>根据 Istio 的&lt;a href="/v1.8/zh/about/release-cadence/">支持策略&lt;/a>，在下一个 LTS 版本发布后，1.3 版本会继续得到三个月的支持。由于 &lt;a href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/">1.4 版本已于 11 月 14 日发布&lt;/a>，因此对 1.3 版本的支持将于 2020 年 2 月 14 日终止。&lt;/p>
&lt;p>届时，我们将停止为 1.3 提供针对安全问题和关键错误的修复程序，因此我们建议您升级到最新版本的 Istio (1.8.3)。如果您不升级，可能会使自己处于必须在短时间内完成重大升级才能获取关键修复程序的地步。&lt;/p>
&lt;p>我们关心您和您的集群，因此请对自己好一点并进行升级。&lt;/p></description><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.3-eol/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.3-eol/</guid></item><item><title>Istio 1.4.3 发布</title><description>
&lt;p>此版本包含一些错误修复程序，以提高健壮性和用户体验。此发行说明描述了 Istio 1.4.2 和 Istio 1.4.3 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.4.3"
data-downloadbuttontext="DOWNLOAD 1.4.3"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.4.3)'
data-updatebutton='了解 Istio 1.4.5'
data-updatehref="/v1.8/zh/news/releases/1.4.x/announcing-1.4.5/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.4/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.4.2...1.4.3">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> Mixer 创建太多 watches，&lt;code>kube-apiserver&lt;/code> 超载的问题 (&lt;a href="https://github.com/istio/istio/issues/19481">Issue 19481&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> pod 包含多个没有暴露端口的容器时的注入问题 (&lt;a href="https://github.com/istio/istio/issues/18594">Issue 18594&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 对 &lt;code>regex&lt;/code> 字段验证过于严格的问题 (&lt;a href="https://github.com/istio/istio/pull/19212">Issue 19212&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 对 &lt;code>regex&lt;/code> 字段升级的问题 (&lt;a href="https://github.com/istio/istio/pull/19665">Issue 19665&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> &lt;code>istioctl&lt;/code> 安装以正确将日志发送到 &lt;code>stderr&lt;/code> 的问题 (&lt;a href="https://github.com/istio/istio/issues/17743">Issue 17743&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 无法为 &lt;code>istioctl&lt;/code> 安装指定文件和配置文件的问题 (&lt;a href="https://github.com/istio/istio/issues/19503">Issue 19503&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 阻止安装某些对象进行 &lt;code>istioctl&lt;/code> 安装的问题 (&lt;a href="https://github.com/istio/istio/issues/19371">Issue 19371&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 阻止在 JWT 策略中将某些 JWKS 与 EC 密钥一起使用的问题 (&lt;a href="https://github.com/istio/istio/issues/19424">Issue 19424&lt;/a>)。&lt;/li>
&lt;/ul>
&lt;h2 id="improvements">增强&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>增强&lt;/strong> 注入模板以完全指定 &lt;code>securityContext&lt;/code>，允许 &lt;code>PodSecurityPolicies&lt;/code> 正确验证注入的部署 (&lt;a href="https://github.com/istio/istio/issues/17318">Issue 17318&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>增强&lt;/strong> 遥测 v2 配置，以支持 Stackdriver 和向前兼容性 (&lt;a href="https://github.com/istio/installer/pull/591">Issue 591&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>增强&lt;/strong> &lt;code>istioctl&lt;/code> 安装的输出 (&lt;a href="https://github.com/istio/istio/issues/19451">Issue 19451&lt;/a>)。&lt;/li>
&lt;li>&lt;strong>增强&lt;/strong> &lt;code>istioctl&lt;/code> 安装，可以在发生故障时设置退出代码 (&lt;a href="https://github.com/istio/istio/issues/19747">Issue 19747&lt;/a>)。&lt;/li>
&lt;/ul></description><pubDate>Wed, 08 Jan 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4.3/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4.3/</guid></item><item><title>ISTIO-SECURITY-2019-007</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18801">CVE-2019-18801&lt;/a>&lt;br>
&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18802">CVE-2019-18802&lt;/a>&lt;br>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td>9.0 &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=CVSS%3a3.0%2fAV%3aN%2fAC%3aH%2fPR%3aN%2fUI%3aN%2fS%3aC%2fC%3aH%2fI%3aH%2fA%3aH">CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
1.2 to 1.2.9&lt;br>
1.3 to 1.3.5&lt;br>
1.4 to 1.4.1&lt;br>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Envoy 及 Istio 容易受到基于两个新发现的漏洞的攻击:&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18801">CVE-2019-18801&lt;/a>&lt;/strong>：此漏洞以处理带有大量 HTTP/2 header 下游请求的方式影响 Envoy 的 HTTP/1 编解码器。利用此漏洞可能会导致拒绝服务、特权升级或信息泄露。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18802">CVE-2019-18802&lt;/a>&lt;/strong>：HTTP/1 编解码器未能正确修剪 header 值的尾缀空格。这可能使攻击者可以绕开 Istio 的策略，导致特权升级或信息泄露。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="impact-and-detection">影响范围&lt;/h2>
&lt;p>Istio gateway 和 sidecar 都容易受到此问题的影响。如果您正在运行受影响的发行版之一，其中下游的请求为 HTTP/2，而上游的请求为 HTTP/1，则您的群集很容易受到攻击。我们估计很多集群都是这样。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>对于 Istio 1.2.x 部署: 请升级至 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10">Istio 1.2.10&lt;/a> 或更高的版本。&lt;/li>
&lt;li>对于 Istio 1.3.x 部署: 请升级至 &lt;a href="/v1.8/zh/news/releases/1.3.x/announcing-1.3.6">Istio 1.3.6&lt;/a> 或更高的版本。&lt;/li>
&lt;li>对于 Istio 1.4.x 部署: 请升级至 &lt;a href="/v1.8/zh/news/releases/1.4.x/announcing-1.4.2">Istio 1.4.2&lt;/a> 或更高的版本。&lt;/li>
&lt;/ul>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-007/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-007/</guid><category>CVE</category></item><item><title>Istio 1.4.2 发布公告</title><description>
&lt;p>此版本包含了&lt;a href="/v1.8/zh/news/security/istio-security-2019-007">我们在 2019 年 12 月 10 日新闻&lt;/a>中描述的安全漏洞的修复程序。此发行说明描述了 Istio 1.4.1 和 Istio 1.4.2 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.4.2"
data-downloadbuttontext="DOWNLOAD 1.4.2"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.4.2)'
data-updatebutton='了解 Istio 1.4.5'
data-updatehref="/v1.8/zh/news/releases/1.4.x/announcing-1.4.5/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.4/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.4.1...1.4.2">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2019-007&lt;/strong> 在 Envoy 中发现了堆溢出和不正确的输入验证。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18801">CVE-2019-18801&lt;/a>&lt;/strong>：修复了一个影响 Envoy 处理大型 HTTP/2 请求 header 的漏洞。成功利用此漏洞可能导致拒绝服务、特权提升或信息泄露。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18802">CVE-2019-18802&lt;/a>&lt;/strong>：修复了 HTTP/1 header 值后的空格引起的漏洞，该漏洞可能使攻击者绕过 Istio 的策略检查，从而可能导致信息泄露或特权提升。&lt;/p></description><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4.2/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4.2/</guid></item><item><title>Istio 1.3.6 发布公告</title><description>
&lt;p>此版本包含了&lt;a href="/v1.8/zh/news/security/istio-security-2019-007">我们在 2019 年 12 月 10 日新闻&lt;/a>中描述的安全漏洞的修复程序。此发行说明描述了 Istio 1.3.5 和 Istio 1.3.6 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.6"
data-downloadbuttontext="DOWNLOAD 1.3.6"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.6)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.5...1.3.6">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2019-007&lt;/strong> 在 Envoy 中发现了堆溢出和不正确的输入验证。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18801">CVE-2019-18801&lt;/a>&lt;/strong>：修复了一个影响 Envoy 处理大型 HTTP/2 请求 header 的漏洞。成功利用此漏洞可能导致拒绝服务、特权提升或信息泄露。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18802">CVE-2019-18802&lt;/a>&lt;/strong>：修复了 HTTP/1 header 值后的空格引起的漏洞，该漏洞可能使攻击者绕过 Istio 的策略检查，从而可能导致信息泄露或特权提升。&lt;/p>
&lt;h2 id="bug-fix">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>修复&lt;/strong> 使用 headless TCP 服务时，为代理的 IP 地址生成重复的侦听器的问题。（&lt;a href="https://github.com/istio/istio/issues/17748">Issue 17748&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>修复&lt;/strong> HTTP 相关指标中的 &lt;code>destination_service&lt;/code> 标签不正确地退回到 &lt;code>request.host&lt;/code>，可能导致 ingress 流量的指标基数激增的问题。（&lt;a href="https://github.com/istio/istio/issues/18818">Issue 18818&lt;/a>）&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="minor-enhancements">小的增强&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong> Mixer 的减载选项。增加了对 &lt;code>每秒请求数&lt;/code> 阈值的支持，以实现减少负载。该选项使运维人员可以在低流量情况下关闭 Mixer 的减载。&lt;/li>
&lt;/ul></description><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.6/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.6/</guid></item><item><title>Istio 1.2.10 发布公告</title><description>
&lt;p>此版本包含了&lt;a href="/v1.8/zh/news/security/istio-security-2019-007">我们在 2019 年 12 月 10 日新闻&lt;/a>中描述的安全漏洞的修复程序。此发行说明描述了 Istio 1.2.9 和 Istio 1.2.10 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/1.2.10">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.9...1.2.10">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2019-007&lt;/strong> 在 Envoy 中发现了堆溢出和不正确的输入验证。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18801">CVE-2019-18801&lt;/a>&lt;/strong>：修复了一个影响 Envoy 处理大型 HTTP/2 请求 header 的漏洞。成功利用此漏洞可能导致拒绝服务、特权提升或信息泄露。&lt;/p>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18802">CVE-2019-18802&lt;/a>&lt;/strong>：修复了 HTTP/1 header 值后的空格引起的漏洞，该漏洞可能使攻击者绕过 Istio 的策略检查，从而可能导致信息泄露或特权提升。&lt;/p>
&lt;h2 id="bug-fix">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>添加对 Citadel 的支持以自动轮转根证书。（&lt;a href="https://github.com/istio/istio/issues/17059">Issue 17059&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Tue, 10 Dec 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/</guid></item><item><title>Istio 1.4.1 发布</title><description>
&lt;p>此次发布包括了一些 bug 修复来提升健壮性。此次发布的注意事项描述了 Istio 1.4.0 和 Istio 1.4.1 之间的差异。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.4.1"
data-downloadbuttontext="DOWNLOAD 1.4.1"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.4.1)'
data-updatebutton='了解 Istio 1.4.5'
data-updatehref="/v1.8/zh/news/releases/1.4.x/announcing-1.4.5/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.4/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.4.0...1.4.1">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> Windows 安装 &lt;code>istioctl&lt;/code> 的问题 (&lt;a href="https://github.com/istio/istio/pull/19020">Issue 19020&lt;/a>).&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 当在 Kubernetes Ingress 中使用 cert-manager 的一个路由匹配顺序问题 (&lt;a href="https://github.com/istio/istio/pull/19000">Issue 19000&lt;/a>).&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 当 pod 名称包含 &lt;code>.&lt;/code> 时 Mixer 的 source namespace 属性配置错误的问题 (&lt;a href="https://github.com/istio/istio/issues/19015">Issue 19015&lt;/a>).&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> Galley 生成了过多的指标数据的问题 (&lt;a href="https://github.com/istio/istio/issues/19165">Issue 19165&lt;/a>).&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 使追踪服务的端口恢复为监听 80 (&lt;a href="https://github.com/istio/istio/issues/19227">Issue 19227&lt;/a>).&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 缺失 &lt;code>istioctl&lt;/code> 自动补齐文件的问题 (&lt;a href="https://github.com/istio/istio/issues/19297">Issue 19297&lt;/a>).&lt;/li>
&lt;/ul></description><pubDate>Thu, 05 Dec 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4.1/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4.1/</guid></item><item><title>对 Istio 1.2 的支持将于 2019 年 12 月 13 日终止</title><description>&lt;p>根据 Istio 的&lt;a href="/v1.8/zh/about/release-cadence/">支持策略&lt;/a>，在下一个 LTS 版本发布后，1.2 版本会继续得到三个月的支持。由于 &lt;a href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/">1.3 已经在 9 月 12 日发布&lt;/a>，对 1.2 版本的支持将于 2019 年 12 月 13 日终止。&lt;/p>
&lt;p>届时，我们将停止为 1.2 提供针对安全问题和关键错误的修复程序，因此我们建议您升级到最新版本的 Istio (1.8.3)。如果您不这样做，可能会使自己处于必须在短时间内完成重大升级才能获取关键修复程序的地步。&lt;/p>
&lt;p>我们非常关注您和您的集群，所以请参照我们的建议并进行升级。&lt;/p></description><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.2-eol/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.2-eol/</guid></item><item><title>Istio 1.3.5 发布公告</title><description>
&lt;p>此版本包含&lt;a href="/v1.8/zh/news/security/istio-security-2019-006">我们在 2019 年 11 月 11 日的新闻中&lt;/a>描述的安全漏洞修复程序以及提高健壮性的程序。此发行说明描述了 Istio 1.3.4 和 Istio 1.3.5 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.5"
data-downloadbuttontext="DOWNLOAD 1.3.5"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.5)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.4...1.3.5">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>ISTIO-SECURITY-2019-006&lt;/strong> 在 Envoy 中发现了一个 DoS 漏洞。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-18817">CVE-2019-18817&lt;/a>&lt;/strong>：在 Istio 中存在这种情况，如果将 &lt;code>continue_on_listener_filters_timeout&lt;/code> 选项设置为 True，则可导致 Envoy 陷入死循环。可以利用此漏洞进行 DoS 攻击。如果应用了&lt;a href="/v1.8/zh/news/security/istio-security-2019-006">我们在 2019 年 11 月 11 日的新闻中&lt;/a>提到的防范措施，则在升级到 Istio 1.3.5 或更高版本后，可以删除该防范措施。&lt;/p>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> TCP headless 服务的 Envoy 监听器配置。（&lt;a href="https://github.com/istio/istio/issues/17748">Issue #17748&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 即使将 deployment 缩放到 0 个副本，过时的 endpoint 也会保留的问题。（&lt;a href="https://github.com/istio/istio/issues/14336">Issue #14436&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 生成无效的 Envoy 配置时，Pilot 不会再崩溃。（&lt;a href="https://github.com/istio/istio/issues/17266">Issue 17266&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 没有为与 BlackHole/Passthrough 集群相关的 TCP 指标填充 &lt;code>destination_service_name&lt;/code> 标签的问题。（&lt;a href="https://github.com/istio/istio/issues/17271">Issue 17271&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 调用遥测过滤器链时遥测不报告 BlackHole/Passthrough 群集指标的问题。集群指标的问题。该问题会在为外部服务配置显示的 &lt;code>ServiceEntries&lt;/code> 时发生的。
（&lt;a href="https://github.com/istio/istio/issues/17759">Issue 17759&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="minor-enhancements">小的增强&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong> 支持 Citadel 定期检查根证书的剩余寿命并轮换即将到期的根证书。（&lt;a href="https://github.com/istio/istio/issues/17059">Issue 17059&lt;/a>）&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 为 Pilot 添加布尔型环境变量 &lt;code>PILOT_BLOCK_HTTP_ON_443&lt;/code>。如果启用，此标志将阻止 HTTP 服务在端口 443 上运行，以防止与外部 HTTP 服务发生冲突。默认情况下禁用此功能。（&lt;a href="https://github.com/istio/istio/issues/16458">Issue 16458&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Mon, 11 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.5/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.5/</guid></item><item><title>ISTIO-SECURITY-2019-006</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td> &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=">&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="context">内容&lt;/h2>
&lt;p>Envoy 以及随后的 Istio 容易受到以下 DoS 攻击。
如果选项 &lt;code>continue_on_listener_filters_timeout&lt;/code> 设置为 &lt;code>True&lt;/code>，则可以在 Envoy 中触发无限循环。自从 Istio 1.3 中引入协议检测功能以来，Istio 就是这种情况。
远程攻击者可能会轻易触发该漏洞，从而有效耗尽 Envoy 的 CPU 资源并造成拒绝服务攻击。&lt;/p>
&lt;h2 id="impact-and-detection">影响范围&lt;/h2>
&lt;p>Istio gateway 和 sidecar 都容易受到此问题的影响。如果您运行的 Istio 是受影响的发行版本，那么您的集群容易受到攻击。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>&lt;p>解决方法: 通过自定义安装 Istio 可以防止对该漏洞的利用(如&lt;a href="/v1.8/zh/docs/reference/config/installation-options/#pilot-options">安装选项&lt;/a>中所述)，在使用 Helm 时添加以下选项:&lt;/p>
&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >--set pilot.env.PILOT_INBOUND_PROTOCOL_DETECTION_TIMEOUT=0s --set global.proxy.protocolDetectionTimeout=0s
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>对于 Istio 1.3.x 部署: 更新至 &lt;a href="/v1.8/zh/news/releases/1.3.x/announcing-1.3.5">Istio 1.3.5&lt;/a> 或者更新的版本。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Thu, 07 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-006/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-006/</guid><category>CVE</category></item><item><title>发布 Istio 1.2.9</title><description>
&lt;p>我们很高兴地宣布 Istio 1.2.9 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.9"
data-downloadbuttontext="DOWNLOAD 1.2.9"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.9)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.8...1.2.9">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复代理启动的先决条件。&lt;/li>
&lt;/ul>
&lt;h2 id="features">特点&lt;/h2>
&lt;ul>
&lt;li>添加了对 &lt;code>Citadel&lt;/code> 自动更换根证书的支持 (&lt;a href="https://github.com/istio/istio/issues/17059">Issue 17059&lt;/a>)。&lt;/li>
&lt;/ul></description><pubDate>Wed, 06 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.9/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.9/</guid></item><item><title>Istio 1.3.4 发布公告</title><description>
&lt;p>此版本发布了包含提高系统稳定性的错误修复程序，下面是 Istio 1.3.3 和 Istio 1.3.4 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.4"
data-downloadbuttontext="DOWNLOAD 1.3.4"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.4)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.3...1.3.4">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> Google 节点代理提供程序中的崩溃错误。（&lt;a href="https://github.com/istio/istio/pull/18260">Pull Request #18296&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> Prometheus 注释，并将 Jaeger 更新为 1.14。（&lt;a href="https://github.com/istio/istio/pull/18274">Pull Request #18274&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 入站侦听器重载间隔为 5 分钟。(&lt;a href="https://github.com/istio/istio/issues/18088">Issue #18138&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 密钥和证书轮换的验证问题。（&lt;a href="https://github.com/istio/istio/issues/17718">Issue #17718&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 无效的内部资源垃圾回收问题。（&lt;a href="https://github.com/istio/istio/issues/16818">Issue #16818&lt;/a>）&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 在失败时不更新 webhook 的问题。（&lt;a href="https://github.com/istio/istio/pull/17820">Pull Request #17820&lt;/a>）&lt;/li>
&lt;li>&lt;strong>Improved&lt;/strong> OpenCensus 跟踪适配器的性能问题。(&lt;a href="https://github.com/istio/istio/issues/18042">Issue #18042&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="minor-enhancements">小的增强&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>增强&lt;/strong> SDS 服务的可靠性。（&lt;a href="https://github.com/istio/istio/issues/17409">Issue #17409&lt;/a>, &lt;a href="https://github.com/istio/istio/issues/17905">Issue #17905&lt;/a>）&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 稳定版本的故障域标签。（&lt;a href="https://github.com/istio/istio/pull/17755">Pull Request #17755&lt;/a>）&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong> 更新与升级相关的全局网格策略。（&lt;a href="https://github.com/istio/istio/pull/17033">Pull Request #17033&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Fri, 01 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.4/</guid></item><item><title>发布 Istio 1.2.8</title><description>
&lt;p>我们很高兴地宣布 Istio 1.2.8 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.8"
data-downloadbuttontext="DOWNLOAD 1.2.8"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.8)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.7...1.2.8">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;p>修复了我们在 &lt;a href="/v1.8/zh/news/security/istio-security-2019-005">10 月 8 日发布的安全性错误&lt;/a>，错误地计算了 &lt;code>HTTP header&lt;/code> 和 &lt;code>body sizes&lt;/code> (&lt;a href="https://github.com/istio/istio/issues/17735">Issue 17735&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了一个较小的错误，将部署减小到 0 个副本时，&lt;code>endpoint&lt;/code> 仍保留在 &lt;code>/clusters&lt;/code> 中 (&lt;a href="https://github.com/istio/istio/issues/14336">Issue 14336&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 &lt;code>Helm&lt;/code> 的升级过程，以正确的方式更新对 &lt;code>mutual TLS&lt;/code> 的网格策略 (&lt;a href="https://github.com/istio/istio/issues/16170">Issue 16170&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了在目标服务中对 &lt;code>TCP&lt;/code> 连接的打开和关闭度量标准的不一致性问题 (&lt;a href="https://github.com/istio/istio/issues/17234">Issue 17234&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 &lt;code>Istio&lt;/code> 的 &lt;code>secret&lt;/code> 清除机制 (&lt;a href="https://github.com/istio/istio/issues/17122">Issue 17122&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 &lt;code>Mixer Stackdriver&lt;/code> 适配器的编码过程，以处理无效的 &lt;code>UTF-8&lt;/code> (&lt;a href="https://github.com/istio/istio/issues/16966">Issue 16966&lt;/a>)。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="features">特点&lt;/h2>
&lt;ul>
&lt;li>新增了 &lt;code>pilot&lt;/code> 对新的故障域标签：&lt;code>zone&lt;/code> 和 &lt;code>region&lt;/code> 的支持。&lt;/li>
&lt;/ul></description><pubDate>Wed, 23 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.8/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.8/</guid></item><item><title>对 Istio 1.1 的支持已终止</title><description>&lt;p>正如&lt;a href="/v1.8/zh/news/support/announcing-1.1-eol/">之前宣布的&lt;/a>一样，对 Istio 1.1 的支持现已正式宣布终止。&lt;/p>
&lt;p>由于我们在 &lt;a href="/v1.8/zh/news/security/istio-security-2019-005">10 月 8 日发布之后&lt;/a>了解到该版本存在安全漏洞，而该漏洞仍处于 1.1 版本支持的期限内，因此我们决定将 1.1 支持期限延长至原始公告之后并发布 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.16">1.1.16&lt;/a>。然后，我们发现此版本引入了 &lt;a href="https://github.com/istio/istio/issues/17735">HTTP header 计算大小的错误&lt;/a>因此我们决定最后发布一个补丁程序 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17">1.1.17&lt;/a> 发布之后，将会彻底关闭 1.1 系列版本。&lt;/p>
&lt;p>届时，我们将不会再针对安全和关键错误的修复等问题移植回 1.1，因此，我们衷心希望您将现有集群升级到最新版本的 Istio (1.8.3)。&lt;/p></description><pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.1-eol-final/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.1-eol-final/</guid></item><item><title>Istio 1.1.17 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.17 已经可用。这将是最后一个 1.1.x 的补丁版本。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/1.1.17">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.16...1.1.17">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了一个由 &lt;a href="/v1.8/zh/news/security/istio-security-2019-005">10 月 8 日安全补丁&lt;/a>引入的 bug，它错误地计算 HTTP 头和请求体大小（&lt;a href="https://github.com/istio/istio/issues/17735">Issue 17735&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Mon, 21 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/</guid></item><item><title>Istio 1.3.3 发布公告</title><description>
&lt;p>此版本包含一些错误修复程序，以提高稳定性。此发行说明描述了 Istio 1.3.2 和 Istio 1.3.3 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.3"
data-downloadbuttontext="DOWNLOAD 1.3.3"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.3)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.2...1.3.3">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Fixed&lt;/strong> 当使用 &lt;code>istioctl x manifest apply&lt;/code> 时导致 Prometheus 安装不正确的问题。（&lt;a href="https://github.com/istio/istio/issues/16970">Issue 16970&lt;/a>）&lt;/li>
&lt;li>&lt;strong>Fixed&lt;/strong> 本地负载均衡不能从本地节点读取位置信息的错误。（&lt;a href="https://github.com/istio/istio/issues/17337">Issue 17337&lt;/a>）&lt;/li>
&lt;li>&lt;strong>Fixed&lt;/strong> 当侦听器在没有任何用户配置更改的情况下进行重新配置时，Envoy 代理会删除长连接。（&lt;a href="https://github.com/istio/istio/issues/17383">Issue 17383&lt;/a>，&lt;a href="https://github.com/istio/istio/issues/17139">Issue 17139&lt;/a>）&lt;/li>
&lt;li>&lt;strong>Fixed&lt;/strong> &lt;code>istioctl x analyze&lt;/code> 命令的崩溃问题。（&lt;a href="https://github.com/istio/istio/issues/17449">Issue 17449&lt;/a>）&lt;/li>
&lt;li>&lt;strong>Fixed&lt;/strong> &lt;code>istioctl x manifest diff&lt;/code> 命令中 ConfigMaps 中的差异文本块。（&lt;a href="https://github.com/istio/istio/issues/16828">Issue 16828&lt;/a>）&lt;/li>
&lt;li>&lt;strong>Fixed&lt;/strong> Envoy proxy 的分段错误崩溃问题。（&lt;a href="https://github.com/istio/istio/issues/17699">Issue 17699&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Mon, 14 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.3/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.3/</guid></item><item><title>ISTIO-SECURITY-2019-005</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15226">CVE-2019-15226&lt;/a>&lt;br>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td>7.5 &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=CVSS%3a3.0%2fAV%3aN%2fAC%3aL%2fPR%3aN%2fUI%3aN%2fS%3aU%2fC%3aN%2fI%3aN%2fA%3aH">CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
1.1 to 1.1.15&lt;br>
1.2 to 1.2.6&lt;br>
1.3 to 1.3.1&lt;br>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="context">内容&lt;/h2>
&lt;p>Envoy 和 Istio 容易受到以下 DoS 攻击。收到每个传入的请求后,Envoy 将遍历请求标头，以保证请求头的总大小保持在最大限制以下。远程攻击者可能会制作一个请求，该请求的 header 的大小不会超过最大限制，但包含成千上万个小的 header，来消耗 CPU 并导致拒绝服务攻击。&lt;/p>
&lt;h2 id="impact-and-detection">影响范围&lt;/h2>
&lt;p>Istio gateway 和 sidecar 都容易受到此问题的影响。如果您运行的 Istio 是受影响的发行版本，那么您的集群容易受到攻击。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>对于 Istio 1.1.x 部署: 更新所有控制平面组件(Pilot、Mixer、Citadel、和 Galley) 然后&lt;a href="/v1.8/zh/docs/setup/upgrade/cni-helm-upgrade/#sidecar-upgrade">更新数据平面&lt;/a>的版本不低于 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.16">Istio 1.1.16&lt;/a>。&lt;/li>
&lt;li>对于 Istio 1.2.x 部署: 更新所有控制平面组件(Pilot、Mixer、Citadel、和 Galley) 然后&lt;a href="/v1.8/zh/docs/setup/upgrade/cni-helm-upgrade/#sidecar-upgrade">更新数据平面&lt;/a>的版本不低于 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2.7">Istio 1.2.7&lt;/a>。&lt;/li>
&lt;li>对于 Istio 1.3.x 部署: 更新所有控制平面组件(Pilot、Mixer、Citadel、和 Galley) 然后&lt;a href="/v1.8/zh/docs/setup/upgrade/cni-helm-upgrade/#sidecar-upgrade">更新数据平面&lt;/a>的版本不低于 &lt;a href="/v1.8/zh/news/releases/1.3.x/announcing-1.3.2">Istio 1.3.2&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-005/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-005/</guid><category>CVE</category></item><item><title>Istio 1.3.2 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.3.2 发布，请查看下面的更改说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.2"
data-downloadbuttontext="DOWNLOAD 1.3.2"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.2)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.1...1.3.2">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>此版本包含我们 &lt;a href="/v1.8/zh/news/security/istio-security-2019-005">2019 年 10 月 8 日新闻发布&lt;/a>中所述的安全漏洞修复程序。特别：&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-005&lt;/strong>: Envoy 社区发现了一个 DoS 漏洞。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15226">CVE-2019-15226&lt;/a>&lt;/strong>: 经过调查，Istio 团队发现，如果攻击者使用大量非常小的标头，则可以利用此问题进行 Istio 的 DoS 攻击。&lt;/p>
&lt;p>除上述安全修复程序外，此版本中不包含其他任何内容。几天后将发布 Distroless 镜像。&lt;/p></description><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.2/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.2/</guid></item><item><title>发布 Istio 1.2.7</title><description>
&lt;p>我们很高兴地宣布 Istio 1.2.7 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.7"
data-downloadbuttontext="DOWNLOAD 1.2.7"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.7)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.6...1.2.7">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>此版本包含我们在 &lt;a href="/v1.8/zh/news/security/istio-security-2019-005">2019 年 10 月 8 日&lt;/a>的新闻中所阐述的安全漏洞程序的修复。特别是：&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-005&lt;/strong>: &lt;code>Envoy&lt;/code> 社区发现的一个 &lt;code>DoS&lt;/code> 漏洞。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15226">CVE-2019-15226&lt;/a>&lt;/strong>: 经过调查，&lt;code>Istio&lt;/code> 团队发现，如果攻击者使用大量非常小的 &lt;code>header&lt;/code>，则可以利用此问题在 &lt;code>Istio&lt;/code> 中进行 &lt;code>DoS&lt;/code> 攻击。&lt;/p>
&lt;h2 id="bug-fix">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了 &lt;code>nodeagent&lt;/code> 在使用 &lt;code>citadel&lt;/code> 时启动失败的错误 (&lt;a href="https://github.com/istio/istio/issues/17108">Issue 15876&lt;/a>)&lt;/li>
&lt;/ul></description><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.7/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.7/</guid></item><item><title>Istio 1.1.16 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.1.16 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.16"
data-downloadbuttontext="DOWNLOAD 1.1.16"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.16)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.15...1.1.16">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>此版本包含了我们在 &lt;a href="/v1.8/zh/news/security/istio-security-2019-005">2019 年 10 月 8 日&lt;/a>的新闻中所阐述的修复程序的安全漏洞。特别是：&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-005&lt;/strong>: &lt;code>Envoy&lt;/code> 社区发现了一个 &lt;code>DoS&lt;/code> 漏洞。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15226">CVE-2019-15226&lt;/a>&lt;/strong>: 经过调查，&lt;code>Istio&lt;/code> 团队发现，如果攻击者使用大量非常小的 &lt;code>header&lt;/code>，则可以利用此问题进行对 &lt;code>Istio&lt;/code> 的 &lt;code>DoS&lt;/code> 攻击。&lt;/p>
&lt;p>除了对上述程序的安全修复以外，此版本中不包含其他任何内容。&lt;/p></description><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.16/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.16/</guid></item><item><title>Istio 1.3.1 发布公告</title><description>
&lt;p>此版本包含一些错误修复程序，以提高稳定性。此发行说明描述了 Istio 1.3.0 和 Istio 1.3.1 之间的区别。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.3.1"
data-downloadbuttontext="DOWNLOAD 1.3.1"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.3.1)'
data-updatebutton='了解 Istio 1.3.8'
data-updatehref="/v1.8/zh/news/releases/1.3.x/announcing-1.3.8/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.3.0...1.3.1">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> 在升级过程中错误的导致 secret 清理任务执行错误的问题（&lt;a href="https://github.com/istio/istio/issues/16873">Issue 16873&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 默认配置禁用 Kubernetes Ingress 支持的问题（&lt;a href="https://github.com/istio/istio/issues/17148">Issue 17148&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 在 Stackdriver 日志记录适配器中处理无效 &lt;code>UTF-8&lt;/code> 字符的问题（&lt;a href="https://github.com/istio/istio/issues/16966">Issue 16966&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> HTTP 指标中没有为 &lt;code>BlackHoleCluster&lt;/code> 和 &lt;code>PassThroughCluster&lt;/code> 设置 &lt;code>destination_service&lt;/code> 标签的问题（&lt;a href="https://github.com/istio/istio/issues/16629">Issue 16629&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 由于 &lt;code>destination_service&lt;/code> 标签问题导致 &lt;code>istio_tcp_connections_closed_total&lt;/code> 和 &lt;code>istio_tcp_connections_opened_total&lt;/code> 指标不能被正确设置（&lt;a href="https://github.com/istio/istio/issues/17234">Issue 17234&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> Istio 1.2.4 引入的 Envoy 崩溃问题（&lt;a href="https://github.com/istio/istio/issues/16357">Issue 16357&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 在节点上禁用 IPv6 时，Istio CNI Sidecar 初始化的问题（&lt;a href="https://github.com/istio/istio/issues/15895">Issue 15895&lt;/a>）。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 影响 JWT 中 RS384 和 RS512 算法支持问题（&lt;a href="https://github.com/istio/istio/issues/15380">Issue 15380&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="minor-enhancements">小的增强&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>.Values.global.priorityClassName&lt;/code> 对遥测部署的支持。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 对 Datadog 的支持。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>pilot_xds_push_time&lt;/code> 指标以报告 Pilot xDS 推送时间。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>istioctl experimental analyze&lt;/code> 以支持多资源分析和验证。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 对在 WebAssembly 沙箱中运行元数据交换和统计信息扩展的支持。请按照&lt;a href="/v1.8/zh/docs/ops/configuration/telemetry/in-proxy-service-telemetry/">以下&lt;/a>说明进行尝试。&lt;/li>
&lt;li>&lt;strong>删除&lt;/strong> proxy-status 命令中的时间差异信息。&lt;/li>
&lt;/ul></description><pubDate>Fri, 27 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3.1/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3.1/</guid></item><item><title>Istio 1.2.6 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.2.6 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.6"
data-downloadbuttontext="DOWNLOAD 1.2.6"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.6)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.5...1.2.6">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了 &lt;code>redisquota&lt;/code> 有关 &lt;code>memquota&lt;/code> 的计数不一致问题 (&lt;a href="https://github.com/istio/istio/issues/15543">Issue 15543&lt;/a>)。&lt;/li>
&lt;li>修复了在 Istio 1.2.5 中引入的 Envoy 崩溃问题 (&lt;a href="https://github.com/istio/istio/issues/16357">Issue 16357&lt;/a>)。&lt;/li>
&lt;li>修复了在插件证书（带有中间证书）的上下文中损坏的 &lt;code>Citadel&lt;/code> 的运行状况的检查 (&lt;a href="https://github.com/istio/istio/issues/16593">Issue 16593&lt;/a>)。&lt;/li>
&lt;li>修复了 Stackdriver Mixer Adapter 的错误日志的详细程度 (&lt;a href="https://github.com/istio/istio/issues/16782">Issue 16782&lt;/a>)。&lt;/li>
&lt;li>修复了一个错误，该错误将删除具有多个端口的服务主机上的账户映射。&lt;/li>
&lt;li>修复了由 Pilot 产生的不正确的通配符 &lt;code>filterChainMatch&lt;/code> 导致的主机重复的问题 (&lt;a href="https://github.com/istio/istio/issues/16573">Issue 16573&lt;/a>)。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>当与 Stackdriver 等服务进行会话连接时，会暴露 &lt;code>sidecarToTelemetrySessionAffinity&lt;/code> (Mixer V1 需要) (&lt;a href="https://github.com/istio/istio/issues/16862">Issue 16862&lt;/a>)。&lt;/li>
&lt;li>暴露 &lt;code>HTTP/2&lt;/code> 窗口大小作为 Pilot 的环境变量 (&lt;a href="https://github.com/istio/istio/issues/17117">Issue 17117&lt;/a>)。&lt;/li>
&lt;/ul></description><pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.6/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.6/</guid></item><item><title>Istio 1.1.15 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.1.15 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.15"
data-downloadbuttontext="DOWNLOAD 1.1.15"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.15)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.14...1.1.15">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;p>Bug 修复{#bug-fixes}&lt;/p>
&lt;ul>
&lt;li>修复 Istio 1.1.14 中引入的 Envoy 崩溃 bug (&lt;a href="https://github.com/istio/istio/issues/16357">Issue 16357&lt;/a>)。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>暴露 &lt;code>HTTP/2&lt;/code> 窗口大小作为 Pilot 环境变量 (&lt;a href="https://github.com/istio/istio/issues/17117">Issue 17117&lt;/a>)。&lt;/li>
&lt;/ul></description><pubDate>Mon, 16 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.15/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.15/</guid></item><item><title>Istio 1.2.4 sidecar 镜像漏洞</title><description>
&lt;p>致 Istio 用户社区，&lt;/p>
&lt;p>在太平洋标准时间 2019 年 8 月 23 日下午 9:16 至太平洋标准时间 2019 年 9 月 6 日上午 09:26 之间，Istio &lt;code>proxyv2&lt;/code> 1.2.4（参见 &lt;a href="https://hub.docker.com/r/istio/proxyv2">https://hub.docker.com/r/istio/proxyv2&lt;/a>）的 Docker 映像包含了错误的针对 &lt;a href="/v1.8/zh/news/security/istio-security-2019-003/">ISTIO-SECURITY-2019-003&lt;/a> 和 &lt;a href="/v1.8/zh/news/security/istio-security-2019-004/">ISTIO-SECURITY-2019-004&lt;/a> 漏洞的代理版本。&lt;/p>
&lt;p>如果在此期间安装了 Istio 1.2.4，请考虑升级到还包含其他安全修复程序的 Istio 1.2.5。&lt;/p>
&lt;h2 id="detailed-explanation">详细说明&lt;/h2>
&lt;p>由于在修复最近的 HTTP2 DoS 漏洞时我们已经执行了通信禁令，因此对于这种类型的发布来说很常见：我们预先私下构建了 Sidecar 的映像，在公开披露的同时，我们在 Docker Hub 上手动推送了该映像。&lt;/p>
&lt;p>对于无法修复安全漏洞的秘密披露版本，该 Docker 映像通常会通过我们的发行渠道作业完全自动的完成 push。&lt;/p>
&lt;p>我们的自动发布流程无法与漏洞披露禁令所要求的手动交互一起正常工作：发布管道保留了对 Istio 仓库旧版本代码的引用。&lt;/p>
&lt;p>出现的问题，自动构建需要基于旧版本构建，这是在 Istio 1.2.5 发行期间的事情：我们遇到了一个需要 &lt;a href="https://github.com/istio-releases/pipeline/commit/635d276ad7eac01bef9c3f195520a0f722626c0f">revert commit&lt;/a> 的问题，该问题触发了基于旧版本 Istio 1.2.4 代码的重建。&lt;/p>
&lt;p>此 revert commit 发生在太平洋标准时间 2019 年 8 月 23 日下午 09:16。我们已经注意到该问题，并于太平洋标准时间 2019 年 9 月 6 日上午 09:26 回推了该镜像。&lt;/p>
&lt;p>对于由于此事件给您带来的不便，我们感到抱歉，并且我们&lt;a href="https://github.com/istio/istio/issues/16887">正在努力建立更好的发布系统&lt;/a>，以及一种更有效的方式来处理漏洞报告。&lt;/p>
&lt;ul>
&lt;li>1.2 的发布管理器&lt;/li>
&lt;/ul></description><pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/incorrect-sidecar-image-1.2.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/incorrect-sidecar-image-1.2.4/</guid><category>community</category><category>blog</category><category>security</category></item><item><title>Istio 1.2.5 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.2.5 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.5"
data-downloadbuttontext="DOWNLOAD 1.2.5"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.5)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.4...1.2.5">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>遵循 &lt;a href="/v1.8/zh/news/security/istio-security-2019-003/">ISTIO-SECURITY-2019-003&lt;/a>
和 &lt;a href="/v1.8/zh/news/security/istio-security-2019-004">ISTIO-SECURITY-2019-004&lt;/a> 中描述的安全漏洞的修复，我们现在解决内部控制平面的通信问题。这些修复在我们之前的安全版本中不可用，并且我们认为控制平面 &lt;code>gRPC&lt;/code> 表面更难以开发。&lt;/p>
&lt;p>您可以在它们的邮件列表中找到 &lt;code>gRPC&lt;/code> 的漏洞修复说明，详情参见 &lt;a href="https://groups.google.com/forum/#!topic/grpc-io/w5jPamxdda4">HTTP/2 Security Vulnerabilities&lt;/a>。&lt;/p>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;p>修复了一个 Envoy 错误，打破 &lt;code>java.net.http.HttpClient&lt;/code> 和其他客户端试图使用 &lt;code>Upgrade: h2c&lt;/code> 的 header 从 &lt;code>HTTP/1.1&lt;/code> 到 &lt;code>HTTP/2&lt;/code> 进行升级，详情参见 (&lt;a href="https://github.com/istio/istio/issues/16391">Issue 16391&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了一个在发送超时时出现内存泄漏的问题 (&lt;a href="https://github.com/istio/istio/issues/15876">Issue 15876&lt;/a>)。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.5/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.5/</guid></item><item><title>Istio 1.1.14 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.1.14 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.14"
data-downloadbuttontext="DOWNLOAD 1.1.14"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.14)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.13...1.1.14">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>遵循 &lt;a href="/v1.8/zh/news/security/istio-security-2019-003/">ISTIO-SECURITY-2019-003&lt;/a>
和 &lt;a href="/v1.8/zh/news/security/istio-security-2019-004/">ISTIO-SECURITY-2019-004&lt;/a> 中描述的安全漏洞的修复，我们现在解决内部控制平面的通信问题。这些修复在我们之前的安全版本中不可用，并且我们认为控制平面 &lt;code>gRPC&lt;/code> 表面更难以开发。&lt;/p>
&lt;p>您可以在它们的邮件列表中找到 &lt;code>gRPC&lt;/code> 的漏洞修复说明，详情参见 &lt;a href="https://groups.google.com/forum/#!topic/grpc-io/w5jPamxdda4">HTTP/2 Security Vulnerabilities&lt;/a>。&lt;/p>
&lt;p>Bug 修复{#bug-fixes}&lt;/p>
&lt;ul>
&lt;li>修正了一个 Envoy 错误，打破 &lt;code>java.net.http.HttpClient&lt;/code> 和其他客户端试图使用 &lt;code>Upgrade: h2c&lt;/code> 的 header 从 &lt;code>HTTP/1.1&lt;/code> 到 &lt;code>HTTP/2&lt;/code> 进行升级，详情参见 (&lt;a href="https://github.com/istio/istio/issues/16391">Issue 16391&lt;/a>)。&lt;/li>
&lt;/ul></description><pubDate>Mon, 26 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.14/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.14/</guid></item><item><title>对 Istio 1.1 的支持将于 2019 年 9 月 19 日终止</title><description>&lt;p>根据 Istio 的&lt;a href="/v1.8/zh/about/release-cadence/">支持策略&lt;/a>，在下一个 LTS 版本发布后的三个月内，将支持 1.1 LTS 版本。由于 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/">1.2 在 6 月 18 日发布&lt;/a>，对 1.1 的支持将于 2019 年 9 月 19 日终止。&lt;/p>
&lt;p>届时，我们将会把针对安全问题和关键性错误修复后的程序反向合并到 1.1，因此我们建议您升级到最新版本的 Istio（1.8.3。如果您不这样做，可能会在短时间内为了修复关键性错误程序而进行频繁的重大升级。&lt;/p>
&lt;p>我们非常关注您和您的集群，所以请参照我们的建议并进行升级。&lt;/p></description><pubDate>Thu, 15 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.1-eol/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.1-eol/</guid></item><item><title>ISTIO-SECURITY-2019-004</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td> &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=">&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="context">内容&lt;/h2>
&lt;p>Envoy 和 Istio 容易受到一系列基于 HTTP/2 的 DoS 攻击：&lt;/p>
&lt;ul>
&lt;li>利用 HTTP/2 的 PING 帧及 PING ACK 帧响应队列发起的洪水攻击，这会导致内存的无限制增长(可能导致内存不足的情况)。&lt;/li>
&lt;li>利用 HTTP/2 的 PRIORITY 帧发起的洪水攻击，这会导致 CPU 使用率过高、不能及时响应其它正常的客户端。&lt;/li>
&lt;li>利用 HTTP/2 的 HEADERS 帧(带有无效 HTTP header) 和 &lt;code>RST_STREAM&lt;/code> 帧响应队列发起的洪水攻击，这会导致内存的无限制增长(可能导致内存不足的情况)。&lt;/li>
&lt;li>利用 HTTP/2 的 SETTINGS 帧及 SETTINGS ACK 帧响应队列发起的洪水攻击，这会导致内存的无限制增长(可能导致内存不足的情况)。&lt;/li>
&lt;li>利用 HTTP/2 的 空荷载帧发起的洪水攻击，这会导致 CPU 使用率过高、不能及时响应其它正常的客户端。&lt;/li>
&lt;/ul>
&lt;p>这些漏洞是从外部报告的，并影响多个代理的实现。更多信息请查看&lt;a href="https://github.com/Netflix/security-bulletins/blob/master/advisories/third-party/2019-002.md">安全公告&lt;/a>。&lt;/p>
&lt;h2 id="impact-and-detection">影响范围&lt;/h2>
&lt;p>如果 Istio 终止来自外部的 HTTP，则 Istio 会变得很脆弱。如果终止 HTTP 的是 Istio 前面的 Intermediary (例: HTTP 负载均衡)，那 Intermediary 就可以保护 Istio，前提是 Intermediary 本身不容易受到相同的 HTTP/2 攻击。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>对于 Istio 1.1.x 部署：更新至 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.13">Istio 1.1.13&lt;/a> 或者更新的版本。&lt;/li>
&lt;li>对于 Istio 1.2.x 部署：更新至 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2.4">Istio 1.2.4&lt;/a> 或者更新的版本。&lt;/li>
&lt;/ul>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-004/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-004/</guid><category>CVE</category></item><item><title>ISTIO-SECURITY-2019-003</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14993">CVE-2019-14993&lt;/a>&lt;br>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td>7.5 &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=CVSS%3a3.0%2fAV%3aN%2fAC%3aL%2fPR%3aN%2fUI%3aN%2fS%3aU%2fC%3aN%2fI%3aN%2fA%3aH">CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
1.1 to 1.1.12&lt;br>
1.2 to 1.2.3&lt;br>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="context">内容&lt;/h2>
&lt;p>一位 Envoy 用户报告了一个 (c.f. &lt;a href="https://github.com/envoyproxy/envoy/issues/7728">Envoy Issue 7728&lt;/a>) 关于非常大的 URI 的正则表达式会导致 Envoy 崩溃的问题。通过调查，Istio 团队发现如果用户正在这些 Istio API（&lt;code>JWT&lt;/code>, &lt;code>VirtualService&lt;/code>, &lt;code>HTTPAPISpecBinding&lt;/code>, &lt;code>QuotaSpecBinding&lt;/code>）中使用正则表达式，那么这个问题可能在 Istio 中引发 Dos 攻击。&lt;/p>
&lt;h2 id="impact-and-detection">影响范围&lt;/h2>
&lt;p>运行下面的命令可以打印下面的输出，检测在你的集群中是否使用了 Istio 正则表达式相关的 API。&lt;/p>
&lt;ul>
&lt;li>YOU ARE AFFECTED: found regex used in &lt;code>AuthenticationPolicy&lt;/code> or &lt;code>VirtualService&lt;/code>&lt;/li>
&lt;li>YOU ARE NOT AFFECTED: did not find regex usage&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; | bash -
set -e
set -u
set -o pipefail
red=`tput setaf 1`
green=`tput setaf 2`
reset=`tput sgr0`
echo &amp;#34;Checking regex usage in Istio API ...&amp;#34;
AFFECTED=()
JWT_REGEX=()
JWT_REGEX+=($(kubectl get Policy --all-namespaces -o jsonpath=&amp;#39;{..regex}&amp;#39;))
JWT_REGEX+=($(kubectl get MeshPolicy --all-namespaces -o jsonpath=&amp;#39;{..regex}&amp;#39;))
if [ &amp;#34;${#JWT_REGEX[@]}&amp;#34; != 0 ]; then
AFFECTED+=(&amp;#34;AuthenticationPolicy&amp;#34;)
fi
VS_REGEX=()
VS_REGEX+=($(kubectl get VirtualService --all-namespaces -o jsonpath=&amp;#39;{..regex}&amp;#39;))
if [ &amp;#34;${#VS_REGEX[@]}&amp;#34; != 0 ]; then
AFFECTED+=(&amp;#34;VirtualService&amp;#34;)
fi
HTTPAPI_REGEX=()
HTTPAPI_REGEX+=($(kubectl get HTTPAPISpec --all-namespaces -o jsonpath=&amp;#39;{..regex}&amp;#39;))
if [ &amp;#34;${#HTTPAPI_REGEX[@]}&amp;#34; != 0 ]; then
AFFECTED+=(&amp;#34;HTTPAPISpec&amp;#34;)
fi
QUOTA_REGEX=()
QUOTA_REGEX+=($(kubectl get QuotaSpec --all-namespaces -o jsonpath=&amp;#39;{..regex}&amp;#39;))
if [ &amp;#34;${#QUOTA_REGEX[@]}&amp;#34; != 0 ]; then
AFFECTED+=(&amp;#34;QuotaSpec&amp;#34;)
fi
if [ &amp;#34;${#AFFECTED[@]}&amp;#34; != 0 ]; then
echo &amp;#34;${red}YOU ARE AFFECTED: found regex used in ${AFFECTED[@]}${reset}&amp;#34;
exit 1
fi
echo &amp;#34;${green}YOU ARE NOT AFFECTED: did not find regex usage${reset}&amp;#34;
EOF
&lt;/code>&lt;/pre>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>Istio 1.1.x: 升级到 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.13">Istio 1.1.13&lt;/a> 或者更高&lt;/li>
&lt;li>Istio 1.2.x: 升级到 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2.4">Istio 1.2.4&lt;/a> 或者更高&lt;/li>
&lt;/ul>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-003/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-003/</guid><category>CVE</category></item><item><title>Istio 1.2.4 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.2.4 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.4"
data-downloadbuttontext="DOWNLOAD 1.2.4"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.4)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.3...1.2.4">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>此版本包含了在 &lt;a href="/v1.8/zh/news/security/istio-security-2019-003/">ISTIO-SECURITY-2019-003&lt;/a>] 和 &lt;a href="/v1.8/zh/news/security/istio-security-2019-004/">ISTIO-SECURITY-2019-004&lt;/a> 中所阐述的安全漏洞程序的修复。特别是：&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-003&lt;/strong>: 一位 Envoy 用户公开报告了一个正则表达式的匹配问题 (c.f. &lt;a href="https://github.com/envoyproxy/envoy/issues/7728">Envoy Issue 7728&lt;/a>)，该问题可使 Envoy 出现非常严重的 URI 崩溃。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14993">CVE-2019-14993&lt;/a>&lt;/strong>: 经调查，Istio 小组发现，当用户正在使用 &lt;code>Istio Api&lt;/code> 中一些像 &lt;code>JWT&lt;/code>, &lt;code>VirtualService&lt;/code>, &lt;code>HTTPAPISpecBinding&lt;/code>, &lt;code>QuotaSpecBinding&lt;/code> 的正则表达式时，会被利用而发起 &lt;code>Istio DoS&lt;/code> 攻击。&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-004&lt;/strong>: Envoy 和之后的 Istio 更容易受到一系列基于 HTTP/2 的 DoS 攻击：
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9512">CVE-2019-9512&lt;/a>&lt;/strong>: 使用 &lt;code>PING&lt;/code> 帧和响应 &lt;code>PING&lt;/code> ACK 帧的 HTTP/2 流，会导致无限的内存增长（这可能导致内存不足的原因）。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9513">CVE-2019-9513&lt;/a>&lt;/strong>: 使用 PRIORITY 帧的 HTTP/2 流会导致其他客户端的 CPU 使用率过低。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9514">CVE-2019-9514&lt;/a>&lt;/strong>: 使用具有无效的 HTTP header 的 &lt;code>HEADERS&lt;/code> 帧和 &lt;code>RST_STREAM&lt;/code> 帧的 HTTP/2 流，会导致无限的内存增长（这可能导致内存不足的原因）。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9515">CVE-2019-9515&lt;/a>&lt;/strong>: 使用 &lt;code>SETTINGS&lt;/code> 帧和 &lt;code>SETTINGS&lt;/code> ACK 帧的 HTTP/2 流，会导致无限的内存增长（这可能导致内存不足的原因）。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9518">CVE-2019-9518&lt;/a>&lt;/strong>: 使用具有空负载帧的 HTTP/2 流会导致其他客户端的 CPU 使用率过低。&lt;/p>
&lt;p>除上述修复的程序之外，此版本中不包含其他任何内容。&lt;/p></description><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.4/</guid></item><item><title>Istio 1.1.13 发布公告</title><description>
&lt;p>我们很高兴地宣布 Istio 1.1.13 现在是可用的，详情请查看如下更改。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.13"
data-downloadbuttontext="DOWNLOAD 1.1.13"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.13)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.12...1.1.13">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>此版本包含了在 &lt;a href="/v1.8/zh/news/security/istio-security-2019-003/">ISTIO-SECURITY-2019-003&lt;/a>] 和 &lt;a href="/v1.8/zh/news/security/istio-security-2019-004/">ISTIO-SECURITY-2019-004&lt;/a> 中所阐述的安全漏洞程序的修复。特别是：&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-003&lt;/strong>: 一位 Envoy 用户公开报告了一个正则表达式的匹配问题 (c.f. &lt;a href="https://github.com/envoyproxy/envoy/issues/7728">Envoy Issue 7728&lt;/a>)，该问题可使 Envoy 出现非常严重的 URI 崩溃。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-14993">CVE-2019-14993&lt;/a>&lt;/strong>: 经调查，Istio 小组发现，当用户正在使用 &lt;code>Istio Api&lt;/code> 中一些像 &lt;code>JWT&lt;/code>, &lt;code>VirtualService&lt;/code>, &lt;code>HTTPAPISpecBinding&lt;/code>, &lt;code>QuotaSpecBinding&lt;/code> 的正则表达式时，会被利用而发起 &lt;code>Istio DoS&lt;/code> 攻击。&lt;/p>
&lt;p>&lt;strong>ISTIO-SECURITY-2019-004&lt;/strong>: Envoy 和之后的 Istio 更容易受到一系列基于 HTTP/2 的 DoS 攻击：
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9512">CVE-2019-9512&lt;/a>&lt;/strong>: 使用 &lt;code>PING&lt;/code> 帧和响应 &lt;code>PING&lt;/code> ACK 帧的 HTTP/2 流，会导致无限的内存增长（这可能导致内存不足的原因）。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9513">CVE-2019-9513&lt;/a>&lt;/strong>: 使用 PRIORITY 帧的 HTTP/2 流会导致其他客户端的 CPU 使用率过低。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9514">CVE-2019-9514&lt;/a>&lt;/strong>: 使用具有无效的 HTTP header 的 &lt;code>HEADERS&lt;/code> 帧和 &lt;code>RST_STREAM&lt;/code> 帧的 HTTP/2 流，会导致无限的内存增长（这可能导致内存不足的原因）。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9515">CVE-2019-9515&lt;/a>&lt;/strong>: 使用 &lt;code>SETTINGS&lt;/code> 帧和 &lt;code>SETTINGS&lt;/code> ACK 帧的 HTTP/2 流，会导致无限的内存增长（这可能导致内存不足的原因）。
* &lt;strong>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9518">CVE-2019-9518&lt;/a>&lt;/strong>: 使用具有空负载帧的 HTTP/2 流会导致其他客户端的 CPU 使用率过低。&lt;/p>
&lt;p>除上述修复的程序之外，此版本中不包含其他任何内容。&lt;/p></description><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.13/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.13/</guid></item><item><title>Istio 1.2.3 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.2.3 现在是可用的，具体更新内容如下。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.3"
data-downloadbuttontext="DOWNLOAD 1.2.3"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.3)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.2...1.2.3">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了一个错误，当 pod 定义了一个端口，而服务未定义该端口时，sidecar 会将请求无限转发给自身（&lt;a href="https://github.com/istio/istio/issues/14443">Issue 14443&lt;/a>）和（&lt;a href="https://github.com/istio/istio/issues/14242">Issue 14242&lt;/a>）&lt;/li>
&lt;li>修复了启动遥测后 Stackdriver 适配器会关闭的 bug。&lt;/li>
&lt;li>修复 Redis 连接问题。&lt;/li>
&lt;li>修复虚拟服务基于正则表达式匹配 HTTP URI 区分大小写的问题（&lt;a href="https://github.com/istio/istio/issues/14983">Issue 14983&lt;/a>）&lt;/li>
&lt;li>修复 demo 配置文件的 HPA 和 CPU 设置（&lt;a href="https://github.com/istio/istio/issues/15338">Issue 15338&lt;/a>）&lt;/li>
&lt;li>放宽 Keep-Alive 实施策略，避免在轻负载下断开连接（&lt;a href="https://github.com/istio/istio/issues/15088">Issue 15088&lt;/a>）&lt;/li>
&lt;li>当未使用 SDS 时，跳过 Kubernetes JWT 身份验证，以降低使用受损（不可信）JWT 的风险。&lt;/li>
&lt;/ul>
&lt;h2 id="tests-upgrade">测试升级&lt;/h2>
&lt;ul>
&lt;li>更新 Bookinfo 评论示例应用程序的基础镜像版本（&lt;a href="https://github.com/istio/istio/issues/15477">Issue 15477&lt;/a>）&lt;/li>
&lt;li>Bookinfo 示例镜像鉴定（&lt;a href="https://github.com/istio/istio/issues/14237">Issue 14237&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.3/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.3/</guid></item><item><title>Istio 1.1.12 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.12 已经可用。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.12"
data-downloadbuttontext="DOWNLOAD 1.1.12"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.12)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.11...1.1.12">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了一个错误，当 &lt;code>Pod&lt;/code> 资源定义了一个端口，但 service 中未定义时，sidecar 可以将请求无限转发给自己（&lt;a href="https://github.com/istio/istio/issues/14443">Issue 14443&lt;/a>）和（&lt;a href="https://github.com/istio/istio/issues/14242">Issue 14242&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.12/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.12/</guid></item><item><title>Istio 1.1.11 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.1.11 现在是可用的。更新详情如下。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.11"
data-downloadbuttontext="DOWNLOAD 1.1.11"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.11)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.10...1.1.11">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>添加了一个功能，以在入口网关启用 &lt;code>HTTP/1.0&lt;/code> 支持（&lt;a href="https://github.com/istio/istio/issues/13085">Issue 13085&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Wed, 03 Jul 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.11/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.11/</guid></item><item><title>ISTIO-SECURITY-2019-002</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td> &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=">&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="context">内容&lt;/h2>
&lt;p>当请求包含格式错误的 JWT 令牌时，Istio JWT 认证过滤器中的 BUG 会导致 Envoy 在某些情况下崩溃。该 BUG 已由一个用户在 &lt;a href="https://github.com/istio/istio/issues/15084">GitHub&lt;/a> 上于 2019 年 6 月 23 日发现并报告。&lt;/p>
&lt;p>此 BUG 会影响所有正在使用 JWT 身份认证策略的 Istio 版本。&lt;/p>
&lt;p>此 BUG 会导致客户端收到 HTTP 503 错误，并且 Envoy 会有以下日志。&lt;/p>
&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >Epoch 0 terminated with an error: signal: segmentation fault (core dumped)
&lt;/code>&lt;/pre>
&lt;p>无论 JWT 规范中的 &lt;code>trigger_rules&lt;/code> 如何设置，Envoy 都可能因为格式错误的 JWT token (没有有效的签名) 崩溃，导致所有 URI 访问不受限制。因此，这个 BUG 使 Envoy 容易受到潜在的 DoS 攻击。&lt;/p>
&lt;h2 id="impact-and-detection">影响范围&lt;/h2>
&lt;p>如果满足以下两个条件，则 Envoy 将很容易受到攻击：&lt;/p>
&lt;ul>
&lt;li>使用了 JWT 身份认证策略。&lt;/li>
&lt;li>使 JWT issuer(由 &lt;code>jwksUri&lt;/code> 发行) 使用 RSA 算法进行签名认证。&lt;/li>
&lt;/ul>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">用于签名认证的 RSA 算法不包含任何已知的安全漏洞。仅当使用此算法时才触发此 CVE，但与系统的安全性无关。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>如果将 JWT 策略应用于 Istio ingress gateway。请注意，有权访问 Ingress gateway 的任何外部用户都可以通过单个 HTTP 请求导致它崩溃。&lt;/p>
&lt;p>如果仅将 JWT 策略应用 Sidecar，请记住它仍然可能受到攻击。例如，Istio ingress gateway 可能会将 JWT token 转发到 Sidecar，这可能是格式错误的 JWT token ，该 token 可能让 Sidecar 崩溃。&lt;/p>
&lt;p>易受攻击的 Envoy 将在处理 JWT token 格式错误的 HTTP 请求上崩溃。当 Envoy 崩溃时，所有现有连接将立即断开连接。&lt;code>pilot-agent&lt;/code> 将自动重启崩溃的 Envoy，重启可能需要几秒钟到几分钟的时间。崩溃超过十次后，pilot-agent 将停止重新启动 Envoy。在这种情况下，Kubernetes 将重新部署 Pod，包括 Envoy 的工作负载。&lt;/p>
&lt;p>要检测集群中是否应用了任何 JWT 身份认证策略，请运行以下命令，该命令将显示以下任一输出：&lt;/p>
&lt;ul>
&lt;li>在身份认证策略中找到了 JWT, &lt;strong>你会收到影响&lt;/strong>&lt;/li>
&lt;li>未在身份认证策略中找到 JWT, &lt;em>你不会会收到影响&lt;/em>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;&amp;#39;EOF&amp;#39; | bash -
set -e
set -u
set -o pipefail
red=`tput setaf 1`
green=`tput setaf 2`
reset=`tput sgr0`
echo &amp;#34;Checking authentication policy...&amp;#34;
JWKS_URI=()
JWKS_URI+=($(kubectl get policy --all-namespaces -o jsonpath=&amp;#39;{range .items[*]}{.spec.origins[*].jwt.jwksUri}{&amp;#34; &amp;#34;}{end}&amp;#39;))
JWKS_URI+=($(kubectl get meshpolicy --all-namespaces -o jsonpath=&amp;#39;{range .items[*]}{.spec.origins[*].jwt.jwksUri}{&amp;#34; &amp;#34;}{end}&amp;#39;))
if [ &amp;#34;${#JWKS_URI[@]}&amp;#34; != 0 ]; then
echo &amp;#34;${red}在身份认证策略中找到了 JWT, 你会收到影响${reset}&amp;#34;
exit 1
fi
echo &amp;#34;${green}未在身份认证策略中找到 JWT, 你不会受到影响${reset}&amp;#34;
EOF
&lt;/code>&lt;/pre>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;p>在以下 Istio 发行版中已修复此 BUG：&lt;/p>
&lt;ul>
&lt;li>Istio 1.0.x: 升级到 &lt;a href="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9">Istio 1.0.9&lt;/a> 或者更新高版本。&lt;/li>
&lt;li>Istio 1.1.x: 升级到 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.10">Istio 1.1.10&lt;/a> 或者更新高版本。&lt;/li>
&lt;li>Istio 1.2.x: 升级到 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2.2">Istio 1.2.2&lt;/a> 或者更新高版本。&lt;/li>
&lt;/ul>
&lt;p>如果您无法立即升级到以下版本之一，则可以选择注入一个 &lt;a href="https://github.com/istio/tools/tree/master/examples/luacheck">Lua filter&lt;/a> 到老的 Istio 版本中。Istio 1.1.9、1.0.8、1.0.6、和 1.1.3 将会进行该认证。&lt;/p>
&lt;p>Lua 过滤器是在 Istio &lt;code>jwt-auth&lt;/code> 过滤器 &lt;em>之前&lt;/em> 注入的。如果在 HTTP 请求中提供了 JWT 令牌，则 &lt;code>Lua&lt;/code> 过滤器将检查 JWT 令牌头是否包含 alg:ES256 。如果过滤器找到了这样的 JWT 令牌，则该请求将被拒绝。&lt;/p>
&lt;p>要安装 Lua 过滤器，请执行以下命令：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ git clone git@github.com:istio/tools.git
$ cd tools/examples/luacheck/
$ ./setup.sh
&lt;/code>&lt;/pre>
&lt;p>安装脚本使用 Helm 模板来生成一个 &lt;code>envoyFilter&lt;/code> 资源，该资源将部署到 Gateway。您可以将 Listener 类型更改为 &lt;code>ANY&lt;/code>，以将其也应用到 Sidecar。只有当您在 Sidecar 上强制使用 JWT 身份认证策略，并在直接接收外部的请求，才应该这样做。&lt;/p>
&lt;h2 id="credit">致谢&lt;/h2>
&lt;p>Istio 团队非常感谢 Divya Raj 的原始 BUG 报告。&lt;/p>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-002/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-002/</guid><category>CVE</category></item><item><title>Istio 1.2.2 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.2.2 现在是可用的，具体更新内容如下。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.2"
data-downloadbuttontext="DOWNLOAD 1.2.2"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.2)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.1...1.2.2">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复由 JWT 格式错误导致的 Istio JWT Envoy 过滤器崩溃（&lt;a href="https://github.com/istio/istio/issues/15084">Issue 15084&lt;/a>）&lt;/li>
&lt;li>修复 x-forward-proto header 的错误覆盖（&lt;a href="https://github.com/istio/istio/issues/15124">Issue 15124&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.2/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.2/</guid></item><item><title>Istio 1.1.10 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.1.10 现在是可用的。更新详情如下。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.10"
data-downloadbuttontext="DOWNLOAD 1.1.10"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.10)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.9...1.1.10">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>消除因 Envoy 重新启动后无法与 SDS 节点代理对话而导致的 503 错误（&lt;a href="https://github.com/istio/istio/issues/14853">Issue 14853&lt;/a>）。&lt;/li>
&lt;li>解决升级过程中由于 &amp;lsquo;TLS error: Secret is not supplied by SDS&amp;rsquo; 导致的错误（&lt;a href="https://github.com/istio/istio/issues/15020">Issue 15020&lt;/a>）。&lt;/li>
&lt;li>修复由 JWT 格式错误导致的 Istio JWT Envoy 过滤器崩溃（&lt;a href="https://github.com/istio/istio/issues/15084">Issue 15084&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.10/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.10/</guid></item><item><title>Announcing Istio 1.0.9</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.9 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/1.0.9">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.8...1.0.9">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了由格式错误的 JWT 导致 Istio JWT Envoy 过滤器崩溃的问题（&lt;a href="https://github.com/istio/istio/issues/15084">Issue 15084&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/</guid></item><item><title>Istio 1.2.1 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.2.1 现在是可用的，具体更新内容如下。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.2.1"
data-downloadbuttontext="DOWNLOAD 1.2.1"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.2.1)'
data-updatebutton='了解 Istio 1.2.10'
data-updatehref="/v1.8/zh/news/releases/1.2.x/announcing-1.2.10/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.2/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.2.0...1.2.1">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复在安装中生成重复 CRD 的问题（&lt;a href="https://github.com/istio/istio/issues/14976">Issue 14976&lt;/a>）&lt;/li>
&lt;li>修复禁用 Galley 时无法启动 Mixer 的问题（&lt;a href="https://github.com/istio/istio/issues/14841">Issue 14841&lt;/a>）&lt;/li>
&lt;li>修复环境变量遮蔽的问题（NAMESPACE 用于监控的命名空间覆盖了 Citadel 的存储命名空间（istio-system）&lt;/li>
&lt;li>修复升级过程中的 &amp;lsquo;TLS error: Secret is not supplied by SDS&amp;rsquo; 错误（&lt;a href="https://github.com/istio/istio/issues/15020">Issue 15020&lt;/a>）&lt;/li>
&lt;/ul>
&lt;h2 id="minor-enhancements">次要改进&lt;/h2>
&lt;ul>
&lt;li>通过将重试设置为 0，允许用户禁用 Istio 的默认重试（&lt;a href="https://github.com/istio/istio/issues/14900">Issue 14900&lt;/a>）&lt;/li>
&lt;li>引入 Redis 过滤器（此功能由环境特性标志 &lt;code>PILOT_ENABLE_REDIS_FILTER&lt;/code> 保护，默认情况下处于禁用状态）&lt;/li>
&lt;li>将 HTTP/1.0 支持添加到网关配置生成（&lt;a href="https://github.com/istio/istio/issues/13085">Issue 13085&lt;/a>）&lt;/li>
&lt;li>为 Istio 组件添加了&lt;a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">容忍&lt;/a>（&lt;a href="https://github.com/istio/istio/pull/15081">Pull Request 15081&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Thu, 27 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2.1/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2.1/</guid></item><item><title>对 Istio 1.0 的支持已结束</title><description>&lt;p>如&lt;a href="/v1.8/zh/news/support/announcing-1.0-eol/">先前宣布&lt;/a>的一样，对 Istio 1.0 的支持现已正式终止。&lt;/p>
&lt;p>我们将不再为 1.0 提供针对安全问题和关键错误的修复程序，因此，如果您尚未升级，我们建议您升级到最新版本的 Istio (1.8.3)。&lt;/p></description><pubDate>Wed, 19 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.0-eol-final/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.0-eol-final/</guid></item><item><title>Istio 1.1.9 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.9 已经可用。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.9"
data-downloadbuttontext="DOWNLOAD 1.1.9"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.9)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.8...1.1.9">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>防止将太大的字符串发送到 Prometheus（&lt;a href="https://github.com/istio/istio/issues/14642">Issue 14642&lt;/a>）。&lt;/li>
&lt;li>如果在续订期间遇到传输错误，将重用先前缓存的 JWT 公共密钥（&lt;a href="https://github.com/istio/istio/issues/14638">Issue 14638&lt;/a>）。&lt;/li>
&lt;li>绕过 HTTP OPTIONS 方法的 JWT 身份验证以支持 CORS 请求。&lt;/li>
&lt;li>修复 Mixer 过滤器导致的 Envoy 崩溃（&lt;a href="https://github.com/istio/istio/issues/14707">Issue 14707&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>将加密签名验证功能公开给 Envoy 的 &lt;code>Lua&lt;/code> 过滤器（&lt;a href="https://github.com/envoyproxy/envoy/issues/7009">Envoy Issue 7009&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.9/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.9/</guid></item><item><title>Istio 1.0.8 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.8 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.8"
data-downloadbuttontext="DOWNLOAD 1.0.8"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.8)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.7...1.0.8">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了 Citadel 如果无法联系 Kubernetes API 服务器可能会生成新的根 CA 的问题，该问题会导致双向 TLS 验证失败（&lt;a href="https://github.com/istio/istio/issues/14512">Issue 14512&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小的改进&lt;/h2>
&lt;ul>
&lt;li>将 Citadel 默认根 CA 证书的 TTL 从 1 年更新为 10 年。&lt;/li>
&lt;/ul></description><pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.8/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.8/</guid></item><item><title>Istio 1.1.8 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.8 已经可用。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.8"
data-downloadbuttontext="DOWNLOAD 1.1.8"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.8)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.7...1.1.8">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复 CDS 集群的 &lt;code>PASSTHROUGH&lt;/code> &lt;code>DestinationRules&lt;/code>（&lt;a href="https://github.com/istio/istio/issues/13744">Issue 13744&lt;/a>）。&lt;/li>
&lt;li>使 Helm charts 中的 &lt;code>appVersion&lt;/code> 和 &lt;code>version&lt;/code> 字段显示正确的 Istio 版本（&lt;a href="https://github.com/istio/istio/issues/14290">Issue 14290&lt;/a>）。&lt;/li>
&lt;li>修复 Mixer 崩溃同时影响策略和遥测服务（&lt;a href="https://github.com/istio/istio/issues/14235">Issue 14235&lt;/a>）。&lt;/li>
&lt;li>修复多集群时不同集群中的两个 pod 无法共享同一个 IP 地址的问题（&lt;a href="https://github.com/istio/istio/issues/14066">Issue 14066&lt;/a>）。&lt;/li>
&lt;li>修复当 Citadel 无法连接 Kubernetes API 服务时重新生成新的根 CA 导致双向 TLS 验证失败的问题（&lt;a href="https://github.com/istio/istio/issues/14512">Issue 14512&lt;/a>）。&lt;/li>
&lt;li>改进 Pilot 验证以拒绝相同域名的不同 &lt;code>VirtualServices&lt;/code>，因为 Envoy 不会接受（&lt;a href="https://github.com/istio/istio/issues/13267">Issue 13267&lt;/a>）。&lt;/li>
&lt;li>修复了本地负载均衡问题，即本地中只有一个副本会接收流量（&lt;a href="https://github.com/istio/istio/issues/13994">13994&lt;/a>）。&lt;/li>
&lt;li>修复了 Pilot Agent 可能不会注意到 TLS 证书轮换的问题（&lt;a href="https://github.com/istio/istio/issues/14539">Issue 14539&lt;/a>）。&lt;/li>
&lt;li>修复 Envoy 中一个 &lt;code>LuaJIT&lt;/code> 崩溃问题（&lt;a href="https://github.com/envoyproxy/envoy/pull/6994">Envoy Issue 6994&lt;/a>）。&lt;/li>
&lt;li>修复一个资源竞争问题：Envoy 可能在下游连接已经关闭 TCP 连接后重用 HTTP/1.1 连接，从而导致 503 错误和重试（&lt;a href="https://github.com/istio/istio/issues/14037">Issue 14037&lt;/a>）。&lt;/li>
&lt;li>修复了 Mixer 的 Zipkin 适配器中的跟踪问题，该问题导致 spans 丢失（&lt;a href="https://github.com/istio/istio/issues/13391">Issue 13391&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>通过在 &lt;code>DEBUG&lt;/code> 模式下记录 &lt;code>the endpoints within network ... will be ignored for no network configured&lt;/code> 消息减少 Pilot 日志信息。&lt;/li>
&lt;li>使 pilot-agent 忽略未知标记以更容易回滚。&lt;/li>
&lt;li>将 Citadel 的默认根 CA 证书 TTL 从 1 年更新为 10 年。&lt;/li>
&lt;/ul></description><pubDate>Thu, 06 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.8/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.8/</guid></item><item><title>ISTIO-SECURITY-2019-001</title><description>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th colspan="2">安全漏洞详情&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>CVE(s)&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CVSS 影响评分&lt;/td>
&lt;td> &lt;a href="https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=">&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>受影响的版本&lt;/td>
&lt;td>
&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="context">内容&lt;/h2>
&lt;p>在检视 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.7">Istio 1.1.7&lt;/a> 发布公告时我们发现已修复的缺陷 &lt;a href="https://github.com/istio/istio/issues/13868">issue 13868&lt;/a> 隐含一个安全漏洞。&lt;/p>
&lt;p>起初我们认为该缺陷仅影响 alpha 特性 &lt;a href="/v1.8/zh/about/feature-stages/#security-and-policy-enforcement">TCP Authorization&lt;/a>，这样就不需要安全公告。但后来我们发现稳定特性
&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/denier/">Deny Checker&lt;/a>、
&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/list/">List Checker&lt;/a> 也受到影响。
我们正在重新评估标识缺陷为安全漏洞的流程而不是通过
&lt;a href="/v1.8/zh/about/security-vulnerabilities/">private disclosure process&lt;/a>。&lt;/p>
&lt;p>该缺陷源于 Istio 1.1 中引入的一个代码变更，影响至 1.1.6 的所有版本。&lt;/p>
&lt;h2 id="impact-and-detection">影响与检测&lt;/h2>
&lt;p>从 Istio 1.1 版本起，Istio 默认安装时策略增强是关闭的。&lt;/p>
&lt;p>您可以通过以下命令来检测服务网格策略增强状态：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n istio-system get cm istio -o jsonpath=&amp;#34;{@.data.mesh}&amp;#34; | grep disablePolicyChecks
disablePolicyChecks: true
&lt;/code>&lt;/pre>
&lt;p>如果 &lt;code>disablePolicyChecks&lt;/code> 状态为 true 那意味着该漏洞对您没有影响。&lt;/p>
&lt;p>如果以下条件都是 true 那意味着该漏洞对您有影响：&lt;/p>
&lt;ul>
&lt;li>您在使用受影响的 Istio 版本&lt;/li>
&lt;li>&lt;code>disablePolicyChecks&lt;/code> 设置为 false（请使用上述命令检查）&lt;/li>
&lt;li>您的工作负载未使用 HTTP、HTTP/2 或 gRPC 协议&lt;/li>
&lt;li>使用 Mixer 适配器（比如 Deny Checker、List Checker）来为您的后端 TCP 服务提供授权。&lt;/li>
&lt;/ul>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;ul>
&lt;li>Istio 1.0.x 用户未受影响。&lt;/li>
&lt;li>对 Istio 1.1.x 部署请升级至 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.7">Istio 1.1.7&lt;/a> 或后续版本。&lt;/li>
&lt;/ul>
&lt;h2 id="credit">致谢&lt;/h2>
&lt;p>Istio 团队非常感谢 &lt;code>Haim Helman&lt;/code> 报告该缺陷。&lt;/p>
&lt;h2 id="漏洞报告">漏洞报告&lt;/h2>
&lt;p>希望大家遵循&lt;a href="/v1.8/zh/about/security-vulnerabilities/">漏洞报告步骤&lt;/a>，以报告任何可能会导致安全漏洞的 bug。</description><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/security/istio-security-2019-001/</link><author/><guid isPermaLink="true">/v1.8/zh/news/security/istio-security-2019-001/</guid><category>CVE</category></item><item><title>对 Istio 1.0 的支持将于 2019 年 6 月 19 日终止</title><description>&lt;p>根据 Istio 的&lt;a href="/v1.8/zh/about/release-cadence/">支持策略&lt;/a>，在下一个 LTS 版本发布后，1.0 会继续得到三个月的支持。由于 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/">1.1 已于 3 月 19 日发布&lt;/a>，因此对 1.0 的支持将于 2019 年 6 月 19 日终止。&lt;/p>
&lt;p>届时，我们将停止为 1.0 提供针对安全问题和关键错误的修复程序，因此我们建议您升级到最新版本的 Istio (1.8.3)。如果您不升级，可能会使自己处于必须在短时间内完成重大升级才能获取关键修复程序的地步。&lt;/p>
&lt;p>我们关心您和您的集群，请对自己好点，升吧。&lt;/p></description><pubDate>Thu, 23 May 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.0-eol/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.0-eol/</guid></item><item><title>Istio 1.1.7 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.7 已经可用。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.7"
data-downloadbuttontext="DOWNLOAD 1.1.7"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.7)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.6...1.1.7">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>该版本修复了 &lt;a href="/v1.8/zh/news/security/istio-security-2019-001">CVE 2019-12243&lt;/a>。&lt;/p>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复了在同一秒创建的具有重叠主机的两个网关可能导致 Pilot 无法正确生成路由并导致 Envoy 侦听器在启动时无限期卡死的问题。&lt;/li>
&lt;li>提高 SDS 节点代理的健壮性：如果 Envoy 发送带有空的 &lt;code>ResourceNames&lt;/code> 的 SDS 请求，请忽略它并等待下一个请求，而不是关闭连接（&lt;a href="https://github.com/istio/istio/issues/13853">Issue 13853&lt;/a>）。&lt;/li>
&lt;li>在以前的版本中，如果服务端口名称是 &lt;code>mysql&lt;/code>，Pilot 会自动将实验性的 &lt;code>envoy.filters.network.mysql_proxy&lt;/code> 过滤器注入到出站过滤器链中。这是令人惊讶的，并给某些运维人员造成了问题，因此，现在仅当将 &lt;code>PILOT_ENABLE_MYSQL_FILTER&lt;/code> 环境变量设置为 &lt;code>1&lt;/code> 时，Pilot 才会自动注入 &lt;code>envoy.filters.network.mysql_proxy&lt;/code> 过滤器（&lt;a href="https://github.com/istio/istio/issues/13998">Issue 13998&lt;/a>）。&lt;/li>
&lt;li>解决了错误地为 TCP 禁用 Mixer 策略检查的问题（&lt;a href="https://github.com/istio/istio/issues/13868">Issue 13868&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>新增 &lt;code>--applicationPorts&lt;/code> 选项到 &lt;code>ingressgateway&lt;/code> Helm charts。当设置为以逗号分隔的端口列表时，就绪检查将失败，直到所有端口都变为活动状态为止。配置后，流量将不会发送到处于预热状态的 Envoy。&lt;/li>
&lt;li>将 &lt;code>ingressgateway&lt;/code> Helm chart 中的内存限制增加到 1GB，并向 SDS 节点代理容器添加资源 &lt;code>request&lt;/code> 和 &lt;code>limits&lt;/code> 以支持 HPA 自动缩放。&lt;/li>
&lt;/ul></description><pubDate>Fri, 17 May 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.7/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.7/</guid></item><item><title>发布公告 Istio 1.1.6</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.6 已经可用。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.6"
data-downloadbuttontext="DOWNLOAD 1.1.6"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.6)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.5...1.1.6">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复 Galley Helm charts 使得 &lt;code>validatingwebhookconfiguration&lt;/code> 可以部署到其它命名空间（非 &lt;code>istio-system&lt;/code>）中（&lt;a href="https://github.com/istio/istio/issues/13625">Issue 13625&lt;/a>）。&lt;/li>
&lt;li>为反亲和性支持提供额外的 Helm chart 修复：修复 &lt;code>gatewaypodAntiAffinityRequiredDuringScheduling&lt;/code> 和 &lt;code>podAntiAffinityLabelSelector&lt;/code> 匹配表达式以及修复 &lt;code>podAntiAffinityLabelSelector&lt;/code> 的默认值（&lt;a href="https://github.com/istio/istio/issues/13892">Issue 13892&lt;/a>）。&lt;/li>
&lt;li>使 Pilot 处理以下情况：在侦听器还在回收时，Envoy 持续请求已删除网关的路由（&lt;a href="https://github.com/istio/istio/issues/13739">Issue 13739&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>如果启用了访问日志，&lt;code>passthrough&lt;/code> 侦听器的请求将被记录。&lt;/li>
&lt;li>使 Pilot 容忍未知的 JSON 字段，以便在升级过程中更轻松地回滚到旧版本。&lt;/li>
&lt;li>&lt;code>SDS&lt;/code> 增加对后备 secrets 的支持，使得 Envoy 可以使用它而不是在启动过程中无限期地等待最新或不存在的 secret（&lt;a href="https://github.com/istio/istio/issues/13853">Issue 13853&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Sat, 11 May 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.6/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.6/</guid></item><item><title>Istio 1.1.5 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.5 已经可用。请浏览下面的变更说明。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.5"
data-downloadbuttontext="DOWNLOAD 1.1.5"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.5)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.4...1.1.5">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>向 Pilot 增加额外的验证以拒绝网关配置中主机匹配重叠的问题（&lt;a href="https://github.com/istio/istio/issues/13717">Issue 13717&lt;/a>）。&lt;/li>
&lt;li>根据最新稳定版本的 &lt;code>istio-cni&lt;/code> 构建，而不是最新的每日构建（&lt;a href="https://github.com/istio/istio/issues/13171">Issue 13171&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>添加日志以帮助诊断主机名解析失败问题（&lt;a href="https://github.com/istio/istio/issues/13581">Issue 13581&lt;/a>）。&lt;/li>
&lt;li>通过移除对 &lt;code>busybox&lt;/code> 镜像的不必要依赖，提高安装 &lt;code>prometheus&lt;/code> 的简便性（&lt;a href="https://github.com/istio/istio/issues/13501">Issue 13501&lt;/a>）。&lt;/li>
&lt;li>使 Pilot Agent 的证书路径可配置（&lt;a href="https://github.com/istio/istio/issues/11984">Issue 11984&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Fri, 03 May 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.5/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.5/</guid></item><item><title>Istio 1.1.4 发布</title><description>
&lt;p>我们很高心的宣布最新的 Istio 1.1.4 版本已经发布 ，具体更改如下。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.4"
data-downloadbuttontext="DOWNLOAD 1.1.4"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.4)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.3...1.1.4">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="behavior-change">行为变更&lt;/h2>
&lt;ul>
&lt;li>更改了 Pilot 的默认行为，以允许流量流向网格外部，即使该流量与内部服务位于同一端口上也是如此，此行为可由 &lt;code>PILOT_ENABLE_FALLTHROUGH_ROUTE&lt;/code> 环境变量控制。&lt;/li>
&lt;/ul>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;p>修复了 &lt;code>ExternalName&lt;/code> 类型服务的出口路由的生成。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加了对配置 Envoy 的空闲连接超时的支持，预防内存或者 IP 端口耗尽 (&lt;a href="https://github.com/istio/istio/issues/13355">Issue 13355&lt;/a>).&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了基于本地负载均衡的故障转移处理中的 Pilot 崩溃错误。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了在 Pilot 获得自定义证书路径时崩溃的错误。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 Pilot 中的一个错误，该错误忽略了用作服务条目主机的短名称 (&lt;a href="https://github.com/istio/istio/issues/13436">Issue 13436&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>向 envoy-metrics-service 集群配置中添加了缺失的 &lt;code>https_protocol_options&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 Pilot 中的一个错误，当路由 fall through 时，Pilot 无法正确处理 https 流量 (&lt;a href="https://github.com/istio/istio/issues/13386">Issue 13386&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了之前遗留的一个问题，从 Kubernetes 移除端点后，Pilot 并未从 Envoy 移除端点 (&lt;a href="https://github.com/istio/istio/issues/13402">Issue 13402&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了节点代理中的崩溃错误 (&lt;a href="https://github.com/istio/istio/issues/13325">Issue 13325&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加了缺少的验证，以防止网关名称包含点（.）(&lt;a href="https://github.com/istio/istio/issues/13211">Issue 13211&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 &lt;a href="/v1.8/zh/docs/reference/config/networking/destination-rule#LoadBalancerSettings-ConsistentHashLB">&lt;code>ConsistentHashLB.minimumRingSize&lt;/code>&lt;/a>
默认为 0 而不是记录的 1024 (&lt;a href="https://github.com/istio/istio/issues/13261">Issue 13261&lt;/a>)。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小改进&lt;/h2>
&lt;ul>
&lt;li>&lt;p>更新了 &lt;a href="https://www.kiali.io">Kiali&lt;/a> 附加组件的最新版本。&lt;/p>&lt;/li>
&lt;li>&lt;p>更新了最新版本的 &lt;a href="https://grafana.com">Grafana&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加了验证以确保仅使用单个副本部署 Citadel (&lt;a href="https://github.com/istio/istio/issues/13383">Issue 13383&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加了对配置代理和 Istio 控制平面的日志记录级别的支持 ((&lt;a href="https://github.com/istio/istio/issues/11847">Issue 11847&lt;/a>)。&lt;/p>&lt;/li>
&lt;li>&lt;p>允许 Sidecar 绑定到任何环回地址，而不仅限于 127.0.0.1 (&lt;a href="https://github.com/istio/istio/issues/13201">Issue 13201&lt;/a>)。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.4/</guid></item><item><title>Istio 1.1.3 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.1.3 发布，下面介绍相关更新信息。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.3"
data-downloadbuttontext="DOWNLOAD 1.1.3"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.3)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.2...1.1.3">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="known-issues-with-1-1-3">1.1.3 版本已知问题&lt;/h2>
&lt;ul>
&lt;li>在启用了 alpha-quality SDS 证书轮换功能的集群中，存在&lt;a href="https://github.com/istio/istio/issues/13325">节点代理恐慌&lt;/a>问题。
由于这是我们首次将 SDS 证书轮换纳入长期运行的测试版本，因此我们不知道这是潜在的错误还是新的回归。
考虑到 SDS 证书轮换为 alpha 版本，我们决定带着这个问题发布 1.1.3 版本，在 1.1.4 版本中我们将解决此问题。&lt;/li>
&lt;/ul>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>&lt;p>删除了 Istio 1.1.2 对 Envoy 某个补丁的反向移植，该补丁用于修复 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9900">&lt;code>CVE-2019-9900&lt;/code>&lt;/a> 和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9901">&lt;code>CVE-2019-9901&lt;/code>&lt;/a>。以便更新包含了最终版本补丁的 Envoy。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复分割水平 &lt;code>EDS&lt;/code> 的负载均衡权重设置。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 Envoy 默认日志格式中的错字。（&lt;a href="https://github.com/istio/istio/issues/12232">Issue 12232&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>在配置更改时正确地重新加载进程外适配器地址。（&lt;a href="https://github.com/istio/istio/issues/12488">Issue 12488&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>恢复意外删除的 Kiali 设置。（&lt;a href="https://github.com/istio/istio/issues/3660">Issue 3660&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>修复当具有相同目标端口的服务存在时导致的重复入站侦听问题。（&lt;a href="https://github.com/istio/istio/issues/9504">Issue 9504&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>通过自动绑定到 &lt;code>Sidecar&lt;/code> 侦听器的服务，解决为 &lt;code>istio-system&lt;/code> 以外命名空间配置 &lt;code>Sidecar&lt;/code> &lt;code>egress&lt;/code> 端口的问题，从而生成 &lt;code>BlackHoleCluster&lt;/code> 的 &lt;code>envoy.tcp_proxy&lt;/code> 过滤器。（&lt;a href="https://github.com/istio/istio/issues/12536">Issue 12536&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>通过支持更准确的主机匹配来修正网关 &lt;code>vhost&lt;/code> 配置生成问题。（&lt;a href="https://github.com/istio/istio/issues/12655">Issue 12655&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 &lt;code>ALLOW_ANY&lt;/code>，如果端口上已经存在 http 服务，现在允许外部流量。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复验证逻辑，现在 &lt;code>port.name&lt;/code> 不再是有效的 &lt;code>PortSelection&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-proxy-config-cluster">&lt;code>istioctl proxy-config cluster&lt;/code>&lt;/a> 命令输出结果中集群类型列的渲染问题。（&lt;a href="https://github.com/istio/istio/issues/12455">Issue 12455&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 SDS secret 的挂载配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 Helm chart 中错误的 Istio 版本。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复当存在重叠端口时出现的 DNS 故障。（&lt;a href="https://github.com/istio/istio/issues/11658">Issue 11658&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 Helm &lt;code>podAntiAffinity&lt;/code> 模板错误。（&lt;a href="https://github.com/istio/istio/issues/12790">Issue 12790&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>修复源目标服务发现不使用源目标负载均衡器的问题。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复当存在无效或丢失密钥时出现的 SDS 内存泄漏问题。（&lt;a href="https://github.com/istio/istio/issues/13197">Issue 13197&lt;/a>）&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小的增强&lt;/h2>
&lt;ul>
&lt;li>&lt;p>从 &lt;code>PushContext&lt;/code> 日志中隐藏 &lt;code>ServiceAccounts&lt;/code> 以缩小日志。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过 &lt;code>values.yaml&lt;/code> 的 &lt;code>localityLbSetting&lt;/code> 字段配置网格。&lt;/p>&lt;/li>
&lt;li>&lt;p>从 Helm 图表中删除即将弃用的 &lt;code>critical-pod&lt;/code> 注释。（&lt;a href="https://github.com/istio/istio/issues/12650">Issue 12650&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>支持 Pod 反亲和性注释以提高控制平面的可用性。（&lt;a href="https://github.com/istio/istio/issues/11333">Issue 11333&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>访问日志中优化 &lt;code>IP&lt;/code> 地址打印。&lt;/p>&lt;/li>
&lt;li>&lt;p>删除冗余的 write header，以进一步减小日志。&lt;/p>&lt;/li>
&lt;li>&lt;p>改进 Pilot 的目标主机验证。&lt;/p>&lt;/li>
&lt;li>&lt;p>显式的配置 &lt;code>istio-init&lt;/code> 以 root 身份运行，以免使用 Pod-level 的 &lt;code>securityContext.runAsUser&lt;/code> 破坏它。（&lt;a href="https://github.com/istio/istio/issues/5453">Issue 5453&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>添加用于 Vault 集成的配置示例。&lt;/p>&lt;/li>
&lt;li>&lt;p>从 &lt;code>ServiceEntry&lt;/code> 执行局部负载均衡权重。&lt;/p>&lt;/li>
&lt;li>&lt;p>使由 Pilot Agent 监视的 TLS 证书位置可配置。（&lt;a href="https://github.com/istio/istio/issues/11984">Issue 11984&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>添加对 Datadog 追踪的支持。&lt;/p>&lt;/li>
&lt;li>&lt;p>为 &lt;code>istioctl&lt;/code> 添加别名，可以使用 &amp;ldquo;x&amp;rdquo; 代替 &amp;ldquo;experimental&amp;rdquo;。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过在 CSR 请求中添加抖动来提供改进的 Sidecar certificate。&lt;/p>&lt;/li>
&lt;li>&lt;p>允许配置权重负载平衡注册表的位置。&lt;/p>&lt;/li>
&lt;li>&lt;p>为内置的 Mixer 适配器添加对标准 CRD 的支持。&lt;/p>&lt;/li>
&lt;li>&lt;p>减少用于演示配置的 Pilot 的资源需求。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过添加数据源完全填充 Galley 仪表盘。（&lt;a href="https://github.com/istio/istio/issues/13040">Issue 13040&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>将 Istio 1.1 &lt;code>sidecar&lt;/code> 的性能调整覆盖到 &lt;code>istio-gateway&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过拒绝 &lt;code>*&lt;/code> 主机来改善目标主机的验证。（&lt;a href="https://github.com/istio/istio/issues/12794">Issue 12794&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>在集群定义中暴露上游的 &lt;code>idle_timeout&lt;/code>，以便可以在使用前从连接池中删除死连接。（&lt;a href="https://github.com/istio/istio/issues/9113">Issue 9113&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>注册 &lt;code>Sidecar&lt;/code> 资源以限制 Pod 可以看到的内容时，如果规范包含一个 &lt;code>workloadSelector&lt;/code>，这些限制将被应用。（&lt;a href="https://github.com/istio/istio/issues/11818">Issue 11818&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>更新 Bookinfo 示例以使端口 80 用于 TLS 源。&lt;/p>&lt;/li>
&lt;li>&lt;p>为 Citadel 添加存活探针。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过将 15020 设置为 &lt;code>ingressgateway&lt;/code> 服务中列出的第一个端口来提高 AWS ELB 的互操作性。（&lt;a href="https://github.com/istio/istio/issues/12503">Issue 12502&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>对故障转移模式使用异常值检测，但不用于局部加权负载均衡的分布模式。（&lt;a href="https://github.com/istio/istio/issues/12961">Issues 12965&lt;/a>）&lt;/p>&lt;/li>
&lt;li>&lt;p>对于 Istio 1.1.0+ Sidecar，使用 &lt;code>filter_enabled&lt;/code> 字段取代 &lt;code>CorsPolicy&lt;/code> 中的 &lt;code>enabled&lt;/code> 字段。&lt;/p>&lt;/li>
&lt;li>&lt;p>标准化 Mixer Helm chart 上的标签.&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.3/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.3/</guid></item><item><title>包含重要安全更新的 Istio 1.1.2 发布公告</title><description>
&lt;p>我们宣布 Istio 1.1.2 现已可用，其包含了一些重要的安全更新。请参阅下面的详细资料。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.2"
data-downloadbuttontext="DOWNLOAD 1.1.2"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.2)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.1...1.1.2">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>最近在 Envoy 代理中发现了两个安全漏洞 (&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9900">CVE 2019-9900&lt;/a> 和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9901">CVE 2019-9901&lt;/a>)。
此漏洞已在 Envoy 1.9.1 版中被修复，相应地，也对 Istio 1.1.2 和 Istio 1.0.7 内置的 Envoy 进行了修复。
由于 Envoy 是 Istio 不可或缺的一部分，因此建议用户立即更新 Istio，以防范由这些漏洞引起的安全风险。&lt;/p>
&lt;p>漏洞实际上是这样导致的：Envoy 没有规范化 HTTP URI 路径，也没有完全验证 HTTP/1.1 header 值。这些漏洞影响了依赖于 Envoy 强制执行授权、路由和速率限制的 Istio 特性。&lt;/p>
&lt;h2 id="affected-Istio-releases">受影响的 Istio 版本&lt;/h2>
&lt;p>以下 Istio 版本容易受到攻击：&lt;/p>
&lt;ul>
&lt;li>&lt;p>1.1, 1.1.1&lt;/p>
&lt;ul>
&lt;li>这些版本可以升级至 Istio 1.1.2。&lt;/li>
&lt;li>1.1.2 与 1.1.1 是基于相同源码构建的，仅添加了解决 CVE 的 Envoy 补丁。&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;p>1.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.6&lt;/p>
&lt;ul>
&lt;li>这些版本可以升级至 Istio 1.0.7。&lt;/li>
&lt;li>1.0.6 与 1.0.7 是基于相同源码构建的，仅添加了解决 CVE 的 Envoy 补丁。&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;p>0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8&lt;/p>
&lt;ul>
&lt;li>这些发行版不再受支持，也不会进行修补。请升级到受支持的版本，以获取必要的修复程序。&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ul>
&lt;h2 id="vulnerability-impact">漏洞影响&lt;/h2>
&lt;p>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9900">CVE 2019-9900&lt;/a> 和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9901">CVE 2019-9901&lt;/a>
允许远程攻击者使用特制的请求 URI 路径（9901）和 HTTP/1.1 header 中的 NUL 字节（9900）来访问未经授权的资源，并可能绕过速率限制等 DoS 防御系统，或路由至未暴露的上游系统。
参阅 &lt;a href="https://github.com/envoyproxy/envoy/issues/6434">issue 6434&lt;/a> 和 &lt;a href="https://github.com/envoyproxy/envoy/issues/6435">issue 6435&lt;/a> 获取更多信息。&lt;/p>
&lt;p>由于 Istio 基于 Envoy，因此 Istio 客户可能会受到这些漏洞的影响，具体取决于 Istio 策略和路由规则中是否使用了路径和请求 header 以及后端 HTTP 实现是如何解析它们的。如果 Mixer 或 Istio 的授权策略或路由规则使用前缀路径匹配规则，则攻击者可能利用这些漏洞来访问某些 HTTP 后端上的未授权路径。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;p>消除漏洞需要更新到正确的 Envoy 版本。我们已经在最新的 Istio 修补程序版本中合并了必要的更新。&lt;/p>
&lt;p>对于 Istio 1.1.x deployment：至少升级至 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.2">Istio 1.1.2&lt;/a>&lt;/p>
&lt;p>对于 Istio 1.0.x deployment：至少升级至 &lt;a href="/v1.8/zh/news/releases/1.0.x/announcing-1.0.7">Istio 1.0.7&lt;/a>&lt;/p>
&lt;p>尽管 Envoy 1.9.1 需要选择路径规范化以解决 CVE 2019-9901，但默认情况下，Istio 1.1.2 和 1.0.7 中内置的 Envoy 版本已经启用了路径规范化。&lt;/p>
&lt;h2 id="detection-of-NUL-header-exploit">检测 NUL header 漏洞&lt;/h2>
&lt;p>根据目前的信息，这只会影响 HTTP/1.1 的流量。如果您的网络或配置不是这种结构，那么此漏洞不太可能影响到您。&lt;/p>
&lt;p>基于文件的访问日志记录与 gRPC 访问日志记录一样，使用 &lt;code>c_str()&lt;/code> 表示 header 值，因此扫描 NUL，不会发现通过 Envoy 的访问日志的任何异常。&lt;/p>
&lt;p>相反，运维人员可能会在 Envoy 执行的路由和 &lt;code>RouteConfiguration&lt;/code> 预期的逻辑之间的日志中寻找不一致之处。&lt;/p>
&lt;p>外部授权和速率限制服务可以检查 header 中的 NUL。后端服务器可能具有足够的日志记录来检测 NUL 或意外访问；根据 RFC 7230，在这种情况下，很可能会通过 400 bad request 简单地拒绝 NUL。&lt;/p>
&lt;h2 id="detection-of-path-traversal-exploit">检测路径遍历漏洞&lt;/h2>
&lt;p>Envoy 的访问日志（基于文件或 gRPC ）将包含非规范化路径，因此可以检查这些日志以检测可疑的模式和与预期的运维人员配置意图不一致的请求。此外，在 &lt;code>ext_authz&lt;/code>、速率限制和后端服务器上可以使用非规范化路径进行日志检查。&lt;/p></description><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.2/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.2/</guid></item><item><title>含有重要安全更新的 Istio 1.0.7 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.7 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.7"
data-downloadbuttontext="DOWNLOAD 1.0.7"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.7)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.6...1.0.7">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="security-update">安全更新&lt;/h2>
&lt;p>最近在 Envoy 代理中发现了两个安全漏洞 (&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9900">CVE 2019-9900&lt;/a> 和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9901">CVE 2019-9901&lt;/a>)。
此漏洞已在 Envoy 1.9.1 版中被修复，相应地，也对 Istio 1.1.2 和 Istio 1.0.7 内置的 Envoy 进行了修复。
由于 Envoy 是 Istio 不可或缺的一部分，因此建议用户立即更新 Istio，以防范由这些漏洞引起的安全风险。&lt;/p>
&lt;p>漏洞实际上是这样导致的：Envoy 没有规范化 HTTP URI 路径，也没有完全验证 HTTP/1.1 header 值。这些漏洞影响了依赖于 Envoy 强制执行授权、路由和速率限制的 Istio 特性。&lt;/p>
&lt;h2 id="affected-Istio-releases">受影响的 Istio 版本&lt;/h2>
&lt;p>以下 Istio 版本容易受到攻击：&lt;/p>
&lt;ul>
&lt;li>&lt;p>1.1, 1.1.1&lt;/p>
&lt;ul>
&lt;li>这些版本可以升级至 Istio 1.1.2。&lt;/li>
&lt;li>1.1.2 与 1.1.1 是基于相同源码构建的，仅添加了解决 CVE 的 Envoy 补丁。&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;p>1.0, 1.0.1, 1.0.2, 1.0.3, 1.0.4, 1.0.5, 1.0.6&lt;/p>
&lt;ul>
&lt;li>这些版本可以升级至 Istio 1.0.7。&lt;/li>
&lt;li>1.0.6 与 1.0.7 是基于相同源码构建的，仅添加了解决 CVE 的 Envoy 补丁。&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;p>0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8&lt;/p>
&lt;ul>
&lt;li>这些发行版不再受支持，也不会进行修补。请升级到受支持的版本，以获取必要的修复程序。&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ul>
&lt;h2 id="vulnerability-impact">漏洞影响&lt;/h2>
&lt;p>&lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9900">CVE 2019-9900&lt;/a> 和 &lt;a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-9901">CVE 2019-9901&lt;/a>
允许远程攻击者使用特制的请求 URI 路径（9901）和 HTTP/1.1 header 中的 NUL 字节（9900）来访问未经授权的资源，并可能绕过速率限制等 DoS 防御系统，或路由至未暴露的上游系统。
参阅 &lt;a href="https://github.com/envoyproxy/envoy/issues/6434">issue 6434&lt;/a> 和 &lt;a href="https://github.com/envoyproxy/envoy/issues/6435">issue 6435&lt;/a> 获取更多信息。&lt;/p>
&lt;p>由于 Istio 基于 Envoy，因此 Istio 客户可能会受到这些漏洞的影响，具体取决于 Istio 策略和路由规则中是否使用了路径和请求 header 以及后端 HTTP 实现是如何解析它们的。&lt;/p>
&lt;p>如果 Mixer 或 Istio 的授权策略或路由规则使用前缀路径匹配规则，则攻击者可能利用这些漏洞来访问某些 HTTP 后端上的未授权路径。&lt;/p>
&lt;h2 id="mitigation">防范&lt;/h2>
&lt;p>消除漏洞需要更新到正确的 Envoy 版本。我们已经在最新的 Istio 修补程序版本中合并了必要的更新。&lt;/p>
&lt;p>对于 Istio 1.1.x deployment：至少升级至 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1.2">Istio 1.1.2&lt;/a>&lt;/p>
&lt;p>对于 Istio 1.0.x deployment：至少升级至 &lt;a href="/v1.8/zh/news/releases/1.0.x/announcing-1.0.7">Istio 1.0.7&lt;/a>&lt;/p>
&lt;p>尽管 Envoy 1.9.1 需要选择路径规范化以解决 CVE 2019-9901，但默认情况下，Istio 1.1.2 和 1.0.7 中内置的 Envoy 版本已经启用了路径规范化。&lt;/p>
&lt;h2 id="detection-of-NUL-header-exploit">检测 NUL header 漏洞&lt;/h2>
&lt;p>根据目前的信息，这只会影响 HTTP/1.1 的流量。如果您的网络或配置不是这种结构，那么此漏洞不太可能影响到您。&lt;/p>
&lt;p>基于文件的访问日志记录与 gRPC 访问日志记录一样，使用 &lt;code>c_str()&lt;/code> 表示 header 值，因此扫描 NUL，不会发现通过 Envoy 的访问日志的任何异常。&lt;/p>
&lt;p>相反，运维人员可能会在 Envoy 执行的路由和 &lt;code>RouteConfiguration&lt;/code> 预期的逻辑之间的日志中寻找不一致之处。&lt;/p>
&lt;p>外部授权和速率限制服务可以检查 header 中的 NUL。后端服务器可能具有足够的日志记录来检测 NUL 或意外访问；根据 RFC 7230，在这种情况下，很可能会通过 400 bad request 简单地拒绝 NUL。&lt;/p>
&lt;h2 id="detection-of-path-traversal-exploit">检测路径遍历漏洞&lt;/h2>
&lt;p>Envoy 的访问日志（基于文件或 gRPC ）将包含非规范化路径，因此可以检查这些日志以检测可疑的模式和与预期的运维人员配置意图不一致的请求。此外，在 &lt;code>ext_authz&lt;/code>、速率限制和后端服务器上可以使用非规范化路径进行日志检查。&lt;/p></description><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.7/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.7/</guid></item><item><title>Istio 1.1.1 发布公告</title><description>
&lt;p>我们非常高兴的宣布 Istio 1.1.1 发布，请浏览下面的变更说明：&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/">
&lt;h5>升级之前&lt;/h5>
&lt;p>升级前须知。&lt;/p>
&lt;/a>
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.1.1"
data-downloadbuttontext="DOWNLOAD 1.1.1"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.1.1)'
data-updatebutton='了解 Istio 1.1.17'
data-updatehref="/v1.8/zh/news/releases/1.1.x/announcing-1.1.17/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.1/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.1.0...1.1.1">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes-and-minor-enhancements">Bug 修复和一些较小的增强&lt;/h2>
&lt;ul>
&lt;li>配置 Prometheus 以监控 Citadel。（&lt;a href="https://github.com/istio/istio/pull/12175">Issue 12175&lt;/a>）&lt;/li>
&lt;li>改善 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-verify-install">&lt;code>istioctl verify-install&lt;/code>&lt;/a> 命令的输出。（&lt;a href="https://github.com/istio/istio/pull/12174">Issue 12174&lt;/a>）&lt;/li>
&lt;li>降低 SPIFFE URI 的缺少服务账户消息的日志级别。（&lt;a href="https://github.com/istio/istio/issues/12108">Issue 12108&lt;/a>）&lt;/li>
&lt;li>修复 opt-in SDS 功能 Unix 域套接字路径错误的问题。（&lt;a href="https://github.com/istio/istio/pull/12688">Issue 12688&lt;/a>）&lt;/li>
&lt;li>修复 Envoy 追踪在父级 span 传播空字符串时无法创建子 span 的问题。（&lt;a href="https://github.com/envoyproxy/envoy/pull/6263">Envoy Issue 6263&lt;/a>）&lt;/li>
&lt;li>将名称空间作用域添加到网关的 “port” 名称。这解决了两个问题：
&lt;ul>
&lt;li>&lt;code>IngressGateway&lt;/code> 仅遵守第一个端口为 443 的网关定义。（&lt;a href="https://github.com/istio/istio/issues/11509">Issue 11509&lt;/a>）&lt;/li>
&lt;li>&lt;code>IngressGateway&lt;/code> 路由错误，两个不同网关使用同一个端口名（SDS）（&lt;a href="https://github.com/istio/istio/issues/12500">Issue 12500&lt;/a>）&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>本地负载均衡权重相关的五个错误修复：
&lt;ul>
&lt;li>修复导致每个位置的端点为空的错误。（&lt;a href="https://github.com/istio/istio/issues/12610">Issue 12610&lt;/a>）&lt;/li>
&lt;li>正确的应用本地负载均衡权重配置。（&lt;a href="https://github.com/istio/istio/issues/12587">Issue 12587&lt;/a>）&lt;/li>
&lt;li>Kubernetes 中的位置标签 &lt;code>istio-locality&lt;/code> 不应包含 &lt;code>/&lt;/code>，应使用 &lt;code>.&lt;/code>。（&lt;a href="https://github.com/istio/istio/issues/12582">Issue 12582&lt;/a>）&lt;/li>
&lt;li>修复了本地负载均衡方面的崩溃问题。（&lt;a href="https://github.com/istio/istio/pull/12649">Issue 12649&lt;/a>）&lt;/li>
&lt;li>修复了本地负载均衡标准化中的错误。（&lt;a href="https://github.com/istio/istio/pull/12579">Issue 12579&lt;/a>）&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>传播 Envoy 度量服务配置。（&lt;a href="https://github.com/istio/istio/issues/12569">Issue 12569&lt;/a>）&lt;/li>
&lt;li>不应用 &lt;code>VirtualService&lt;/code> 规则到错误的网关。（&lt;a href="https://github.com/istio/istio/issues/10313">Issue 10313&lt;/a>）&lt;/li>
&lt;/ul></description><pubDate>Mon, 25 Mar 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1.1/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1.1/</guid></item><item><title>Istio 1.0.6 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.6 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.6"
data-downloadbuttontext="DOWNLOAD 1.0.6"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.6)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.5...1.0.6">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="bug-fixes">Bug 修复&lt;/h2>
&lt;ul>
&lt;li>修复 Galley Helm 图表，使 &lt;code>validatingwebhookconfiguration&lt;/code> 对象现在可以部署到 &lt;code>istio-system&lt;/code> 以外的名称空间（&lt;a href="https://github.com/istio/istio/issues/13625">Issue 13625&lt;/a>）。&lt;/li>
&lt;li>Helm 图表中其他针对反亲和性支持的修复：修复 &lt;code>gatewaypodAntiAffinityRequiredDuringScheduling&lt;/code> 和 &lt;code>podAntiAffinityLabelSelector&lt;/code> 匹配表达式，并修复 &lt;code>podAntiAffinityLabelSelector&lt;/code> 的默认值（&lt;a href="https://github.com/istio/istio/issues/13892">Issue 13892&lt;/a>）。&lt;/li>
&lt;li>让 Pilot 处理这种情况：监听器资源耗尽时，Envoy 依然继续请求已删除被 gateway 的路由（&lt;a href="https://github.com/istio/istio/issues/13739">Issue 13739&lt;/a>）。&lt;/li>
&lt;/ul>
&lt;h2 id="small-enhancements">小的改进&lt;/h2>
&lt;ul>
&lt;li>如果启用了访问日志，&lt;code>passthrough&lt;/code> 监听器的请求将被记录。&lt;/li>
&lt;li>使 Pilot 容忍未知的 JSON 字段，以便在升级过程中可以更轻松地回滚到旧版本。&lt;/li>
&lt;li>将备用 secret 的支持添加到 Envoy 可以使用的 &lt;code>SDS&lt;/code> 中，而不是在启动过程中无限期地等待最新的或不存在的 secret（&lt;a href="https://github.com/istio/istio/issues/13853">Issue 13853&lt;/a>）。&lt;/li>
&lt;/ul></description><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.6/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.6/</guid></item><item><title>Istio 1.0.5 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.5 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.5"
data-downloadbuttontext="DOWNLOAD 1.0.5"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.5)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.4...1.0.5">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="general">概况&lt;/h2>
&lt;ul>
&lt;li>&lt;p>禁用 &lt;code>istio-policy&lt;/code> 服务中的前置条件缓存，因为它会导致无效的结果。缓存将在以后的版本中重新引入。&lt;/p>&lt;/li>
&lt;li>&lt;p>Mixer 现在仅在启用了 &lt;code>tracespan&lt;/code> 适配器的情况下才生成 span，从而降低了正常情况下的 CPU 开销。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了一个可能导致 Pilot 挂起的 bug。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Thu, 20 Dec 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.5/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.5/</guid></item><item><title>Istio 1.0.4 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.4 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.4"
data-downloadbuttontext="DOWNLOAD 1.0.4"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.4)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.3...1.0.4">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="known-issues">已知问题&lt;/h2>
&lt;ul>
&lt;li>使用 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-proxy-status">&lt;code>istioctl proxy-status&lt;/code>&lt;/a> 来获取代理同步状态时，可能会导致 Pilot 死锁。
临时的解决方法是不使用 &lt;code>istioctl proxy-status&lt;/code>。
一旦 Pilot 进入死锁状态，它将表现出持续的内存增长，最终耗尽内存。&lt;/li>
&lt;/ul>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;p>修复了过期 endpoint 漏删导致 503 错误的 bug。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 Pod 标签包含 &lt;code>/&lt;/code> 时 sidecar 的注入 bug。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="policy-and-telemetry">策略和遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;p>修复了进程外 Mixer 适配器偶尔的数据损坏问题导致的不正确行为。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了在等待失踪的 CRD 时，Mixer 过度使用 CPU 的 bug。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.4/</guid></item><item><title>Istio 1.0.3 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.3 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.3"
data-downloadbuttontext="DOWNLOAD 1.0.3"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.3)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.2...1.0.3">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="behavior-changes">行为变更&lt;/h2>
&lt;ul>
&lt;li>&lt;p>现在强制使用&lt;a href="/v1.8/zh/docs/ops/common-problems/validation">验证 webhook&lt;/a>。禁用它可能导致 Pilot 崩溃。&lt;/p>&lt;/li>
&lt;li>&lt;p>现在，&lt;a href="/v1.8/zh/docs/reference/config/networking/service-entry/">Service entry&lt;/a> 验证会在配置为 DNS 解析时拒绝通配主机名（&lt;code>*&lt;/code>）。API 从未允许这样做，只是在以前的版本中，&lt;code>ServiceEntry&lt;/code> 被错误地排除在验证之外。把通配符作为主机名的一部分，例如 &lt;code>*.bar.com&lt;/code>，将保持不变。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;code>istio-proxy&lt;/code> 的核心转储路径已更改为 &lt;code>/var/lib/istio&lt;/code>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/security/authentication/authn-policy/#auto-mutual-TLS">双向 TLS&lt;/a> 宽容模式现在是默认启用的。&lt;/p>&lt;/li>
&lt;li>&lt;p>Pilot 性能和可扩展性已大大增强。Pilot 现在可以在不到 1 秒的时间内向 500 个 sidecar 提供 endpoint 更新。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/observability/distributed-tracing/overview/#trace-sampling">追踪采样&lt;/a>默认设置为 1%。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="policy-and-telemetry">策略和遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;p>Mixer（&lt;code>istio-telemetry&lt;/code>）现在支持基于请求速率和预期延迟的减载。&lt;/p>&lt;/li>
&lt;li>&lt;p>Mixer 客户端（&lt;code>istio-policy&lt;/code>）现在支持 &lt;code>FAIL_OPEN&lt;/code> 设置。&lt;/p>&lt;/li>
&lt;li>&lt;p>Istio 性能仪表盘已添加至 Grafana。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;code>istio-telemetry&lt;/code> CPU 使用率降低 10%。&lt;/p>&lt;/li>
&lt;li>&lt;p>淘汰 &lt;code>statsd-to-prometheus&lt;/code> deployment。Prometheus 现在可以直接从 &lt;code>istio-proxy&lt;/code> 中抓取指标。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Tue, 30 Oct 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.3/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.3/</guid></item><item><title>Istio 1.0.2 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.2 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.2"
data-downloadbuttontext="DOWNLOAD 1.0.2"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.2)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.1...1.0.2">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="general">概况&lt;/h2>
&lt;ul>
&lt;li>&lt;p>修复 Envoy 的 bug：如果在双向 TLS 端口上接收正常流量，则 sidecar 会崩溃。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 Pilot 在多集群环境中向 Envoy 传播不完整更新的 bug。&lt;/p>&lt;/li>
&lt;li>&lt;p>为 Grafana 添加了更多 Helm 选项。&lt;/p>&lt;/li>
&lt;li>&lt;p>改进 Kubernetes 服务注册队列的性能。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复 &lt;code>istioctl proxy-status&lt;/code> 未显示补丁版本的 bug。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加虚拟服务 SNI host 的验证。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Thu, 06 Sep 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.2/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.2/</guid></item><item><title>Istio 1.0.1 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 1.0.1 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.1"
data-downloadbuttontext="DOWNLOAD 1.0.1"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0.1)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://github.com/istio/istio/compare/1.0.0...1.0.1">
&lt;h5>代码变更&lt;/h5>
&lt;p>查看源码变更的详细信息。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;p>改进了 Pilot 的可扩展性和 Envoy 的启动时间。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了添加端口时，虚拟服务 host 不匹配的 bug。&lt;/p>&lt;/li>
&lt;li>&lt;p>增加了对&lt;a href="/v1.8/zh/docs/ops/best-practices/traffic-management/#split-virtual-services">合并同一主机的多个虚拟服务或目标规则定义&lt;/a>的有限支持。&lt;/p>&lt;/li>
&lt;li>&lt;p>使用 HTTP 时，允许连续的&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/cluster/outlier_detection.proto">异常&lt;/a>网关故障。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="environment">环境&lt;/h2>
&lt;ul>
&lt;li>&lt;p>对于那些只想使用 Istio 流量管理功能的用户，Pilot 现在可以独立使用。&lt;/p>&lt;/li>
&lt;li>&lt;p>引入了方便的配置 &lt;code>values-istio-gateway.yaml&lt;/code>，该配置使用户能够运行独立网关。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了一堆 Helm 的安装问题，包括 &lt;code>istio-sidecar-injector&lt;/code> 找不到配置映射的 bug。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了 Galley 尚未准备就绪的 Istio 安装 bug。&lt;/p>&lt;/li>
&lt;li>&lt;p>修复了有关网格扩展的各种 bug。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="policy-and-telemetry">策略和遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;p>向 Mixer Prometheus 适配器添加了实验性的指标过期配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>Grafana 升级至 5.2.2。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="adapters">适配器&lt;/h3>
&lt;ul>
&lt;li>现在可以为 Stackdriver 适配器指定接收器选项。&lt;/li>
&lt;/ul>
&lt;h2 id="galley">Galley&lt;/h2>
&lt;ul>
&lt;li>改进健康检查的配置验证。&lt;/li>
&lt;/ul></description><pubDate>Wed, 29 Aug 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0.1/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0.1/</guid></item><item><title>Istio 1.0 发布公告</title><description>
&lt;p>今天，我们激动的宣布，Istio 1.0 正式发布！自我们最初发布 0.1 版以来已经一年多了。从那时起，一个由贡献者和用户组成的蓬勃发展的社区，使得 Istio 有了长足的发展。现在，许多公司已成功将 Istio 投入生产，并从 Istio 对部署的洞察力和控制力中获得了真正的价值。我们帮助了很多大型企业和快速发展的初创企业，例如：&lt;a href="https://www.ebay.com/">eBay&lt;/a>、&lt;a href="https://www.autotrader.co.uk/">Auto Trader UK&lt;/a>、&lt;a href="http://www.descarteslabs.com/">Descartes Labs&lt;/a>、&lt;a href="https://www.fitstation.com/">HP FitStation&lt;/a>、&lt;a href="https://juspay.in">JUSPAY&lt;/a>、&lt;a href="https://www.namely.com/">Namely&lt;/a>、&lt;a href="https://www.pubnub.com/">PubNub&lt;/a> 和 &lt;a href="https://www.trulia.com/">Trulia&lt;/a> 已经使用 Istio 从头开始连接、管理和保护其服务。将此版本发布为 1.0 表示我们已经建立了一套核心功能，可供用户在生产中使用。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="update-notice entry"
data-title='更新提示'
data-downloadhref="https://github.com/istio/istio/releases/tag/1.0.0"
data-downloadbuttontext="DOWNLOAD 1.0.0"
data-updateadvice='在下载 ％s 之前，您应该知道有一个更新的补丁版本，这个版本修复了已知的 Bug 并且在一定程度上提升了性能。%!(EXTRA string=1.0)'
data-updatebutton='了解 Istio 1.0.9'
data-updatehref="/v1.8/zh/news/releases/1.0.x/announcing-1.0.9/">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v1.0/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="ecosystem">生态系统&lt;/h2>
&lt;p>去年，我们发现 Istio 的生态系统有了大幅增长。
&lt;a href="https://www.envoyproxy.io/">Envoy&lt;/a> 继续保持惊人的增长，并增加了许多对服务网格生产质量至关重要的功能。
诸如 &lt;a href="https://www.datadoghq.com/">Datadog&lt;/a>、&lt;a href="https://www.solarwinds.com/">SolarWinds&lt;/a>、&lt;a href="https://sysdig.com/blog/monitor-istio/">Sysdig&lt;/a>、&lt;a href="https://cloud.google.com/stackdriver/">Google Stackdriver&lt;/a> 和 &lt;a href="https://aws.amazon.com/cloudwatch/">Amazon CloudWatch&lt;/a> 之类的可观察性提供商已经编写了将 Istio 与他们的产品集成的插件。
&lt;a href="https://www.tigera.io/resources/using-network-policy-concert-istio-2/">Tigera&lt;/a>、&lt;a href="https://www.aporeto.com/">Aporeto&lt;/a>、&lt;a href="https://cilium.io/">Cilium&lt;/a> 和 &lt;a href="https://styra.com/">Styra&lt;/a> 为我们的策略执行和网络功能构建了扩展。
&lt;a href="https://www.redhat.com/en">Red Hat&lt;/a> 构建了 &lt;a href="https://www.kiali.io">Kiali&lt;/a>，以围绕网格管理和可观察性提供不错的用户体验。
&lt;a href="https://www.cloudfoundry.org/">Cloud Foundry&lt;/a> 基于 Istio 的下一代流量路由栈，
最近宣布的 &lt;a href="https://github.com/knative/docs">Knative&lt;/a> serverless 项目也在做同样的事情，并且 &lt;a href="https://apigee.com/">Apigee&lt;/a> 宣布他们计划在其 API 管理中使用它。
这些只是社区去年添加集成中的一部分。&lt;/p>
&lt;h2 id="features">特性&lt;/h2>
&lt;p>自 0.8 版以来，我们添加了一些重要的新功能，更重要的是将许多现有功能标记为 Beta，表明它们已可以投入生产。以下是一些要点：&lt;/p>
&lt;ul>
&lt;li>&lt;p>现在可以将多个 Kubernetes 集群&lt;a href="/v1.8/zh/docs/setup/install/multicluster/">添加到单个网格&lt;/a>中，并实现跨集群通信和一致的策略实施。多群集支持现在为 Beta。&lt;/p>&lt;/li>
&lt;li>&lt;p>现在，可以对通过网状网络的流量进行细粒度控制的网络 API 已成为 Beta。使用网关对进入和退出问题进行显式建模，使运维人员可以&lt;a href="/v1.8/zh/blog/2018/v1alpha3-routing/">控制网络拓扑&lt;/a>并满足边缘的访问安全性要求。&lt;/p>&lt;/li>
&lt;li>&lt;p>双向 TLS 现在[以增量方式推出]，无需更新服务的所有客户端。这是一项关键功能，现有生产部署可以无障碍的就地采用。&lt;/p>&lt;/li>
&lt;li>&lt;p>Mixer 开始支持&lt;a href="https://github.com/istio/istio/wiki/Out-Of-Process-gRPC-Adapter-Dev-Guide">开发进程外适配器&lt;/a>。这将成为在未来发行版中扩展 Mixer 的默认方法，并使构建适配器更加简单。&lt;/p>&lt;/li>
&lt;li>&lt;p>现在，由 Envoy 完全控制本地控制访问服务的&lt;a href="/v1.8/zh/docs/concepts/security/#authorization">授权策略&lt;/a>，以提高其性能和可靠性。&lt;/p>&lt;/li>
&lt;li>&lt;p>现在建议使用 &lt;a href="/v1.8/zh/docs/setup/install/helm/">Helm chart 安装&lt;/a>方法，该方法提供了丰富的自定义选项，可以按您的意愿采用 Istio。&lt;/p>&lt;/li>
&lt;li>&lt;p>我们已经在性能上做出了很多努力，包括连续回归测试，大规模环境模拟和目标修复。我们对结果感到非常满意，并将在未来几周内详细分享更多信息。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="what-is-next">接下来呢？&lt;/h2>
&lt;p>尽管这是该项目的重要里程碑，但还有很多工作要做。通过与使用者合作，我们获得了很多有关下一步重点的反馈。我们听到了围绕以下功能的一致诉求：混合云、安装模块化、更丰富的网络功能和大规模部署的可伸缩性。我们已经在 1.0 版本中考虑了其中一些反馈，并且在接下来的几个月中我们将继续积极地解决这项工作。&lt;/p>
&lt;h2 id="getting-started">开始之前&lt;/h2>
&lt;p>如果您是 Istio 的新手，并希望将其用于您的部署，我们很乐意听取您的意见。
可以看看&lt;a href="/v1.8/zh/docs/">我们的文档&lt;/a>或者移步我们的&lt;a href="https://discuss.istio.io">聊天室&lt;/a>。
如果您想更深入地&lt;a href="/v1.8/zh/about/community">为项目做贡献&lt;/a>，请参加一个我们的社区会议，并打个招呼。&lt;/p>
&lt;h2 id="thanks">感谢&lt;/h2>
&lt;p>Istio 团队非常感谢为该项目做出贡献的每个人。没有您的帮助，就没有 Istio 的今天。这一年真的太神奇了，我们非常期待接下来的一年，我们共同构成的社区又可以取得什么样的成就。&lt;/p>
&lt;h2 id="release-notes">发行说明&lt;/h2>
&lt;h3 id="networking">网络&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>使用虚拟服务的 SNI 路由&lt;/strong>。&lt;a href="/v1.8/zh/docs/reference/config/networking/virtual-service/">&lt;code>VirtualService&lt;/code>&lt;/a> 新引入的 &lt;code>TLS&lt;/code> 部分，可用于基于 SNI 值的路由 TLS 流量。可以将名为 TLS/HTTPS 的服务端口与虚拟服务 TLS 路由结合使用。没有附带虚拟服务的 TLS/HTTPS 端口将被视为不透明的 TCP。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>恢复流式 gRPC&lt;/strong>。Istio 0.8 导致长时间运行的流式 gRPC 连接的定期终止。此问题已在 1.0 中修复。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>移除旧的（v1alpha1）网络 API&lt;/strong>。对旧的 &lt;code>v1alpha1&lt;/code> 流量管理模型的支持已被删除。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>弃用 Istio Ingress&lt;/strong>。默认情况下，旧的 Istio Ingress 已被弃用并禁用。我们鼓励用户改用 &lt;a href="/v1.8/zh/docs/concepts/traffic-management/#gateways">gateway&lt;/a>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="policy-and-telemetry">策略和遥测&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>更新的属性&lt;/strong>。用于描述流量来源和目的地的一组&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/attribute-vocabulary/">属性&lt;/a>已被彻底修改，变得更加精确和全面。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>策略检查缓存&lt;/strong>。Mixer 现在具有了用于策略检查的大型 2 级缓存，补充了 sidecar 代理中存在的 1 级缓存。这进一步减少了外部强制策略检查的平均延迟。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>遥测缓冲&lt;/strong>。Mixer 现在可以在将调用报告分配给适配器之前先缓冲调用报告，这为适配器提供了机会以更大的块处理遥测数据，从而减少了 Mixer 及其适配器的总体计算开销。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>进程外适配器&lt;/strong>。Mixer 现在包括对进程外适配器的初始支持。这将是与 Mixer 集成的推荐方法。&lt;a href="https://github.com/istio/istio/wiki/Mixer-Out-Of-Process-Adapter-Dev-Guide">进程外适配器开发指南&lt;/a>和&lt;a href="https://github.com/istio/istio/wiki/Mixer-Out-Of-Process-Adapter-Walkthrough">进程外适配器遍历&lt;/a>提供了有关如何构建进程外适配器的初始文档。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>客户端遥测&lt;/strong>。现在，除了服务器端遥测之外，还可以从交互的客户端收集遥测。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h4 id="adapters">适配器&lt;/h4>
&lt;ul>
&lt;li>&lt;p>&lt;strong>SignalFX&lt;/strong>。新的 &lt;code>signalfx&lt;/code> 适配器。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Stackdriver&lt;/strong>。&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/stackdriver/">&lt;code>stackdriver&lt;/code>&lt;/a> 适配器在此发行版中得到大幅增强，添加了新功能并提高性能。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="security">安全&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>授权&lt;/strong>。我们已经重新实现了[授权功能] 的 RPC 级授权策略，此功能现在的实现，不再需要使用 Mixer 和 Mixer 适配器。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改进双向 TLS 身份认证控制&lt;/strong>。现在，可以更轻松地控制服务之间的&lt;a href="/v1.8/zh/docs/concepts/security/#authentication">双向 TLS 身份认证&lt;/a>。我们提供 &lt;code>PERMISSIVE&lt;/code> 模式，以便您可以为您的服务&lt;a href="/v1.8/zh/docs/tasks/security/authentication/mtls-migration/">递增地启用双向 TLS&lt;/a>。我们移除了服务注释，采用&lt;a href="/v1.8/zh/docs/tasks/security/authentication/authn-policy/">独特的方法来启用双向 TLS&lt;/a>，并结合了客户端&lt;a href="/v1.8/zh/docs/concepts/traffic-management/#destination-rules">目标规则&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>JWT 授权&lt;/strong>。现在支持 &lt;a href="/v1.8/zh/docs/concepts/security/#authentication">JWT 身份验证&lt;/a>，可以使用&lt;a href="/v1.8/zh/docs/concepts/security/#authentication-policies">身份验证策略&lt;/a>对其进行配置。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="istioctl">&lt;code>istioctl&lt;/code>&lt;/h3>
&lt;ul>
&lt;li>&lt;p>添加 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-authn-tls-check">&lt;code>istioctl authn tls-check&lt;/code>&lt;/a> 命令。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-proxy-status">&lt;code>istioctl proxy-status&lt;/code>&lt;/a> 命令。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加 &lt;code>istioctl experimental convert-ingress&lt;/code> 命令。&lt;/p>&lt;/li>
&lt;li>&lt;p>移除 &lt;code>istioctl experimental convert-networking-config&lt;/code> 命令。&lt;/p>&lt;/li>
&lt;li>&lt;p>改进和 bug 修复：&lt;/p>
&lt;ul>
&lt;li>&lt;p>使 &lt;code>kubeconfig&lt;/code> handle 与 &lt;code>kubectl&lt;/code> 对齐。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;code>istioctl get all&lt;/code> 返回所有类型的网络和身份验证配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>在 &lt;code>istioctl get&lt;/code> 中添加了 &lt;code>--all-namespaces&lt;/code> 标志，用于检索所有命名空间中的资源。&lt;/p>&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ul>
&lt;h3 id="known-issues-with-1-0">1.0 已知问题&lt;/h3>
&lt;ul>
&lt;li>&lt;p>Amazon EKS 服务未实现 sidecar 自动注入。在 Amazon EKS 中使用 Istio 需要为 sidecar 使用&lt;a href="/v1.8/zh/docs/setup/additional-setup/sidecar-injection/#manual-sidecar-injection">手动注入&lt;/a>并通过 &lt;a href="/v1.8/zh/docs/setup/install/helm">Helm 参数&lt;/a> &lt;code>--set galley.enabled=false&lt;/code> 关闭 galley。&lt;/p>&lt;/li>
&lt;li>&lt;p>在&lt;a href="/v1.8/zh/docs/setup/install/multicluster">多集群部署&lt;/a>中，mixer-telemetry 和 mixer-policy 组件不会连接到任何远程集群的 Kubernetes API 端点。由于与远程集群上的工作负载相关的某些元数据不完整，这会导致遥测保真度的损失。&lt;/p>&lt;/li>
&lt;li>&lt;p>有的 Kubernetes 清单，可用于独立使用 Citadel 或启用 Citadel 运行状况检查。Helm 没有实现这些模式。有关更多详细信息，请参见 &lt;a href="https://github.com/istio/istio/issues/6922">Issue 6922&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>网格扩展功能，使您可以将原始 VM 添加到网格，此功能在 1.0 中已被破坏。我们预计将在几天内产生可解决此问题的补丁。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.0.x/announcing-1.0/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.0.x/announcing-1.0/</guid></item><item><title>Istio 0.8 发布公告</title><description>
&lt;p>这是迈向 Istio 1.0 前的一个重要版本。除了常规的 bug 修复和性能改进之外，还包含许多新功能和体系结构改进。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/0.8.0">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v0.8/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>改良的流量管理模型&lt;/strong>。我们终于准备好完成我们的&lt;a href="/v1.8/zh/blog/2018/v1alpha3-routing/">新流量管理 API&lt;/a> 的总结。我们相信，在涵盖更多实际部署&lt;a href="/v1.8/zh/docs/tasks/traffic-management/">用例&lt;/a>的同时，这种新模型更易于理解。对于从早期发行版升级的人，这儿有一个&lt;a href="/v1.8/zh/docs/setup/upgrade/">迁移指南&lt;/a>和内置在 &lt;code>istioctl&lt;/code> 中的转换工具，可帮助您从旧模型转换配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Envoy 流式配置&lt;/strong>。默认情况下，Pilot 现在使用其 &lt;a href="https://github.com/envoyproxy/data-plane-api/blob/master/xds_protocol.rst">ADS API&lt;/a> 将配置流式传输到 Envoy。这种新方法提高了有效的可伸缩性，减少了推出延迟，应该能消除虚假的 404 错误。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Ingress/Egress 的 Gateway&lt;/strong>。我们不再支持将 Kubernetes Ingress 规范与 Istio 路由规则结合使用，因为它导致了许多错误和可靠性问题。Istio 现在支持用于 ingress 和 egress 代理的独立于平台的 &lt;a href="/v1.8/zh/docs/concepts/traffic-management/#gateways">Gateway&lt;/a> 模型，该模型可跨 Kubernetes 和 Cloud Foundry 使用，并与路由无缝协作。Gateway 支持基于&lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">服务器名称指示&lt;/a>的路由，并基于客户端提供的服务器名称提供证书。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>受限的入站端口&lt;/strong>。现在，我们将 Pod 中的入站端口限制为该 Pod 中运行的应用所声明的端口。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>Citadel 介绍&lt;/strong>。我们终于给安全组件起了个名字。以前的 Istio-Auth 或者 Istio-CA 现在被统称为 Citadel。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>多集群支持&lt;/strong>。我们在多集群部署中支持每一个集群的 Citadel，以便所有 Citadel 共享相同的根证书，并且工作负载可以在整个网格上相互认证。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>认证策略&lt;/strong>。我们为&lt;a href="/v1.8/zh/docs/tasks/security/authentication/authn-policy/">认证策略&lt;/a>创建了一个统一的 API，用于控制服务到服务的通信是否使用双向 TLS 以及最终用户身份验证。这是现在控制这些行为的推荐方法。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="telemetry">遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>自我报告&lt;/strong>。Mixer 和 Pilot 现在会产生遥测，该遥测流经正常的 Istio 遥测管道，就像网格中的服务一样。&lt;/li>
&lt;/ul>
&lt;h2 id="setup">安装&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>Istio 安装菜单&lt;/strong>。Istio 具有一系列丰富的功能，但是您并不需要全部安装或使用它们。通过使用 Helm 或 &lt;code>istioctl gen-deploy&lt;/code>，用户可以只安装他们想要的功能。例如，用户可以只安装 Pilot 并享受流量管理功能，而无需处理 Mixer 或 Citadel。&lt;/li>
&lt;/ul>
&lt;h2 id="mixer-adapters">Mixer 适配器&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>CloudWatch&lt;/strong>。Mixer 现在可以将指标报告给 AWS CloudWatch。&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/cloudwatch/">了解更多&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="known-issues-with-0.8">0.8 已知问题&lt;/h2>
&lt;ul>
&lt;li>&lt;p>有关指向 headless 服务的虚拟服务的网关无法工作（&lt;a href="https://github.com/istio/istio/issues/5005">Issue #5005&lt;/a>）。&lt;/p>&lt;/li>
&lt;li>&lt;p>这是一个 &lt;a href="https://github.com/istio/istio/issues/5723">Google Kubernetes Engine 1.10.2 的问题&lt;/a>。变通的方法是使用 Kubernetes 1.9 或者将节点的镜像切换为 Ubuntu。该问题预计在 GKE 1.10.4 会得到修复。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;code>istioctl experimental convert-networking-config&lt;/code> 工具存在一个已知的命名空间问题，所需的命名空间可能会被修改为 &lt;code>istio-system&lt;/code>，请在运行对话工具后手动将其修改为所需的命名空间。&lt;a href="https://github.com/istio/istio/issues/5817">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.8/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.8/</guid></item><item><title>Istio 0.7 发布公告</title><description>&lt;p>这次发布的版本，我们专注于改进构建和测试基础架构并提高测试质量。因此，本月没有新功能。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/0.7.0">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v0.7/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;p>请注意，此版本包括对新的 v1alpha3 流量管理功能的初步支持。此功能仍在不断变化中，0.8 可能会有一些重大变化。
因此，如果您想探索，请继续前进，但它可能会在 0.8 或更高的版本有变化。&lt;/p>
&lt;p>已知问题：&lt;/p>
&lt;p>我们的 &lt;a href="/v1.8/zh/docs/setup/install/helm">Helm chart&lt;/a> 现在必须使用一些变通的方法才能正确运行，查看 &lt;a href="https://github.com/istio/istio/issues/4701">4701&lt;/a> 获取详情。&lt;/p></description><pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.7/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.7/</guid></item><item><title>Istio 0.6 发布公告</title><description>
&lt;p>除了常规的 bug 修复和性能改进，该版本还新增或更新了以下特性。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/0.6.0">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v0.6/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>自定义 Envoy 配置&lt;/strong>。Pilot 现在支持将自定义 Envoy 配置传递到 proxy。&lt;a href="https://github.com/mandarjog/istioluawebhook">了解更多&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="mixer-adapters">Mixer 适配器&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>SolarWinds&lt;/strong>。Mixer 现在可以跟 AppOptics 和 Papertrail 交互。&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/solarwinds/">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Redis 配额&lt;/strong>。现在，Mixer 支持了一个用于速率限制跟踪的基于 Redis 的适配器。&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/redisquota/">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Datadog&lt;/strong>。现在，Mixer 提供了一个将度量标准数据传递给 Datadog 代理的适配器。&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/datadog/">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="other">其它&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>独立的检查、报告集群&lt;/strong>。现在，配置 Envoy 时，具有 Mixer 检查功能的实例和具有 Mixer 报告功能的实例可以来自不同的群集。这在大型部署中可能有用，以更好地扩展 Mixer 实例。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>监控仪表盘&lt;/strong>。Grafana 现在有了初步的 Mixer&amp;amp;Pilot 监控仪表盘。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>存活及就绪检测&lt;/strong>。Istio 组件现在提供了规范的存活及就绪检测支持，以帮助确保网格基础结构的健康。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Egress 策略和遥测&lt;/strong>。Istio 可以监控由 &lt;code>EgressRule&lt;/code> 或 External Service 定义的外部服务的流量。也可以将 Mixer 策略应用于该流量。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Thu, 08 Mar 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.6/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.6/</guid></item><item><title>Istio 0.5 发布公告</title><description>
&lt;p>除了常规的 bug 修复和性能改进，该版本还新增或更新了以下特性。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/0.5.0">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v0.5/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>渐进式部署 Istio&lt;/strong>。（预览）现在，通过仅安装所需的组件（例如，仅 Pilot + Ingress 作为最小化的 Istio 安装），您可以比以前更轻松地逐步采用 Istio。请参考 &lt;code>istioctl&lt;/code> CLI 工具，以生成有关自定义 Istio 部署的信息。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>自动注入 Proxy&lt;/strong>。我们利用 Kubernetes 1.9 的新 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.9.md#api-machinery">muting webhook 特性&lt;/a>提供 Pod 级的自动注入。自动注入需要 Kubernetes 1.9 或更高版本，因此不适用于旧版本。不再支持 alpha 初始化机制。&lt;a href="/v1.8/zh/docs/setup/additional-setup/sidecar-injection/#automatic-sidecar-injection">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改进流量规则&lt;/strong>。根据用户反馈，我们对 Istio 的流量管理（路由规则，目标规则等）进行了重大更改。在接下来的几周中，我们会不断完善您的反馈，希望我们能继续为您提供帮助。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="mixer-adapters">Mixer 适配器&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>Open Policy Agent&lt;/strong>。现在，Mixer 有一个实现了 &lt;a href="https://www.openpolicyagent.org">open policy agent&lt;/a> 模型的适配器，可提供灵活的细粒度访问控制机制。&lt;a href="https://docs.google.com/document/d/1U2XFmah7tYdmC5lWkk3D43VMAAQ0xkBatKmohf90ICA">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Istio RBAC&lt;/strong>。现在，Mixer 有了一个基于角色的访问控制适配器。&lt;a href="/v1.8/zh/docs/concepts/security/#authorization">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Fluentd&lt;/strong>。现在，Mixer 提供了一个通过 &lt;a href="https://www.fluentd.org">Fluentd&lt;/a> 收集日志的适配器。&lt;a href="/v1.8/zh/docs/tasks/observability/logs/fluentd/">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Stdio&lt;/strong>。现在，Stdio 适配器使您可以将日志记录到文件，并支持日志轮转、备份以及大量控件。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>使用你自己的 CA&lt;/strong>。多项针对 ‘使用你自己的 CA’特性的改进。&lt;a href="/v1.8/zh/docs/tasks/security/plugin-ca-cert/">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>PKCS8&lt;/strong>。将 PKCS8 密钥的支持添加到 Istio PKI。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Istio RBAC&lt;/strong>。Istio RBAC 为 Istio 网格中的服务提供了访问控制。&lt;a href="/v1.8/zh/docs/concepts/security/#authorization">了解更多&lt;/a>&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="other">其它&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>发行版二进制文件&lt;/strong>。我们已将版本和安装默认值切换至发行版，以提高性能和安全性，&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>组件日志&lt;/strong>。Istio 组件现在提供了一组丰富的命令行选项来控制本地日志记录，包括对日志轮换的通用支持。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>一致的版本报告&lt;/strong>。Istio 组件现在提供了一致的命令行界面来报告其版本信息。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>可选的实例字段&lt;/strong>。在配置中，Mixer 实例的定义不再需要包含关联模板的每个字段。缺省字段的值将为零或空值。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="known-issues">已知问题&lt;/h2>
&lt;ul>
&lt;li>&lt;p>Helm charts 安装目前无法使用。&lt;/p>&lt;/li>
&lt;li>&lt;p>sidecar 自动注入仅支持 Kubernetes 1.9 及以后的版本。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Fri, 02 Feb 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.5/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.5/</guid></item><item><title>Istio 0.4 发布公告</title><description>
&lt;p>随着我们稳定的每月发布流程，此版本只进行了几周的更改。除了普通的错误修复和性能改进之外，此版本还包含以下项。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/0.4.0">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v0.4/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="general">General&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>Cloud Foundry&lt;/strong>。增加了对 &lt;a href="https://www.cloudfoundry.org">Cloud Foundry&lt;/a> 平台的最低 Pilot 支持，使 Pilot 可以发现 CF 服务和服务实例。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Circonus&lt;/strong>。Mixer 现在包含了用于 &lt;a href="https://www.circonus.com">Circonus&lt;/a> 分析和监控平台的适配器。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Pilot 指标&lt;/strong>。Pilot 现在会收集诊断指标。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Helm Chart&lt;/strong>。现在，我们提供了 Helm Chart 安装 Istio 的方式。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>增强的属性表达式&lt;/strong>。Mixer 的表达语言获得了一些新功能，使编写策略规则变得更加容易。&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/expression-language/">学到更多&lt;/a>&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>如果您想了解细节，可以在&lt;a href="https://github.com/istio/istio/wiki/v0.4.0">此处&lt;/a>查看我们更详细的低级发行说明。&lt;/p></description><pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.4/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.4/</guid></item><item><title>Istio 0.3 发布公告</title><description>
&lt;p>我们很高兴的宣布 Istio 0.3 现已正式发布。下面是更新详情。&lt;/p>
&lt;div class="relnote-actions call-to-action">
&lt;a class="entry" href="https://github.com/istio/istio/releases/tag/0.3.0">
&lt;h5>下载&lt;/h5>
&lt;p>下载安装该发行版。&lt;/p>
&lt;/a>
&lt;a class="entry" href="https://archive.istio.io/v0.3/docs">
&lt;h5>文档&lt;/h5>
&lt;p> 访问该发行版的文档。&lt;/p>
&lt;/a>
&lt;/div>
&lt;h2 id="general">概况&lt;/h2>
&lt;p>从 0.3 开始，Istio 的发布节奏切换为月度更新。我们希望这将有助于提高我们及时提供改进的能力。有关此版本的各个功能的状态，请参见 &lt;a href="/v1.8/zh/about/feature-stages/">here&lt;/a>。&lt;/p>
&lt;p>团队将重点放在内部基础设施工作上，以提高我们的速度，所以在新功能方面，这是一个相当适中的发布。解决了许多错误和较小的问题，并在许多方面提高了整体性能。&lt;/p>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>安全的控制平面通信&lt;/strong>。Mixer 和 Pilot 现在由双向 TLS 保障安全，就像网格中的所有服务一样。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>选择性认证&lt;/strong>。现在，您可以通过服务注释在每个服务的基础上控制身份验证，这有助于逐步迁移到 Istio。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="networking">网络&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>TCP Egress 规则&lt;/strong>。现在，您可以指定影响 TCP 级别流量的 Egress 规则。&lt;/li>
&lt;/ul>
&lt;h2 id="policy-enforcement-and-telemetry">策略执行和遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>改善缓存&lt;/strong>。Envoy 和 Mixer 之间的缓存得到了很大改善，大大降低了授权检查的平均延迟。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改进的列表适配器&lt;/strong>。Mixer “列表” 适配器现在支持正则表达式匹配。有关详细信息，请参见适配器的&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/list/">配置选项&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>配置校验&lt;/strong>。Mixer 对配置状态进行更广泛的验证，以便更早发现问题。我们希望在即将发布的版本中，投入更多的精力在此功能上。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>如果您想了解细节，可以在&lt;a href="https://github.com/istio/istio/wiki/v0.3.0">这里&lt;/a>查看我们更详细的低级发行说明。&lt;/p></description><pubDate>Wed, 29 Nov 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.3/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.3/</guid></item><item><title>宣布 Istio 0.2</title><description>
&lt;p>我在 2017 年 5 月 24 日发布了 Istio ，它是一个用于连接、管理、监控和保护微服务的开放平台。看着饱含浓厚兴趣的开发者、运营商、合作伙伴和不断发展的社区，我们感到十分的欣慰。我们 0.1 版本的重点是展示 Istio 在 Kubernetes 中的所有概念。&lt;/p>
&lt;p>今天我们十分高兴地宣布推出 0.2 版本，它提高了稳定性和性能、允许在 Kubernetes 集群中广泛部署并自动注入 sidecar 、为 TCP 服务添加策略和身份验证、同时保证扩展网格收录那些部署在虚拟机中的服务。此外，Istio 可以利用 Consul/Nomad 或 Eureka 在 Kubernetes 外部运行。除了核心功能，Istio 的扩展已经准备由第三方公司和开发人员编写。&lt;/p>
&lt;h2 id="highlights-for-the-0.2-release">0.2 版本的亮点&lt;/h2>
&lt;h3 id="usability-improvements">可用性改进&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;em>支持多命名空间&lt;/em>: Istio 现在可以跨多个名称空间在集群范围内工作，这也是来自 0.1 版本中社区最强烈的要求之一。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;em>TCP 服务的策略与安全&lt;/em>: 除了 HTTP ，我们还为 TCP 服务增加了透明双向 TLS 认证和策略实施。这将让拥有像遥测，策略和安全等 Istio 功能的同时，保护更多 Kubernetes deployment 。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;em>自动注入 sidecar&lt;/em>: 通过利用 Kubernetes 1.7 提供的 alpha &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">初始化程序&lt;/a> ，当您的集群启用了该程序时，envoy sidecar 就可以自动注入到应用的 deployment 里。这使得你可以使用 &lt;code>kubectl&lt;/code> 命令部署微服务，这与您通常在没有 Istio 的情况下部署微服务的命令完全相同。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;em>扩展 Istio&lt;/em> : 改进的 Mixer 设计，可以允许供应商编写 Mixer 适配器以实现对其自身系统的支持，例如应用管理或策略实施。该 &lt;a href="https://github.com/istio/istio/wiki/Mixer-Compiled-In-Adapter-Dev-Guide">Mixer 适配器开发指南&lt;/a>可以轻松的帮你将 Istio 集成于你的解决方案。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;em>使用您自己的 CA 证书&lt;/em>: 允许用户提供自己的密钥和证书给 Istio CA 和永久 CA 密钥/证书存储，允许在持久化存储中提供签名密钥/证书，以便于 CA 重启。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;em>改进路由和指标&lt;/em>: 支持 WebSocket 、MongoDB 和 Redis 协议。您可以将弹性功能（如熔断器）应用于第三方服务。除了 Mixer 的指标外，数以百计 Envoy 指标现在已经在 Prometheus 中可见，它们用于监控 Istio 网格中的流量吞吐。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="cross-environment-support">跨环境支持&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;em>网格扩展&lt;/em>: Istio 网格现在可以在 Kubernetes 之外跨服务 —— 就像那些运行在虚拟机中的服务一样，他们同时享受诸如自动双向 TLS 认证、流量管理、遥测和跨网格策略实施带来的好处。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;em>运行在 Kubernetes 外部&lt;/em>: 我们知道许多客户使用其他的服务注册中心和 orchestration 解决方案（如 Consul/Nomad 和 Eureka），Istio Pilot 可以在 Kubernetes 外部单独运行，同时从这些系统中获取信息，并在虚拟机或容器中管理 Envoy fleet 。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="get-involved-in-shaping-the-future-of-Istio">加入到塑造 Istio 未来的队伍中&lt;/h2>
&lt;p>呈现在我们面前的是一幅不断延伸的&lt;a href="/v1.8/zh/about/feature-stages/">蓝图&lt;/a> ，它充满着强大的潜能。我们将在下个版本致力于 Istio 的稳定性，可靠性，第三方工具集成和多集群用例。&lt;/p>
&lt;p>想要了解如何参与并为 Istio 的未来做出贡献，请查看我们在 GitHub 的&lt;a href="https://github.com/istio/community">社区&lt;/a>项目，它将会向您介绍我们的工作组，邮件列表，各种社区会议，常规流程和指南。&lt;/p>
&lt;p>我们要感谢为我们测试新版本、提交错误报告、贡献代码、帮助其他成员以及通过参与无数次富有成效的讨论塑造 Istio 的出色社区，这让我们的项目自启动以来在 GitHub 上累积了 3000 颗星，并且在 Istio 邮件列表上有着数百名活跃的社区成员。&lt;/p>
&lt;p>谢谢&lt;/p>
&lt;h2 id="release-notes">发布说明&lt;/h2>
&lt;h3 id="general">通用&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>更新配置模型&lt;/strong>。Istio 现在使用了 Kubernetes 的 &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resource&lt;/a>
来描述和存储其配置。当运行在 Kubernetes 上时，现在可以使用 &lt;code>kubectl&lt;/code> 命令来管理配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>多 namespace 的支持&lt;/strong>。Istio 控制平面组件现在位于专用的 &lt;code>istio-system&lt;/code> namespace 下。
Istio 可以管理其他非系统名称空间中的服务。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Mesh 扩展&lt;/strong>。初步支持将非 Kubernetes 服务（以 VM 和/或 物理机的形式）添加到网格中。
这是此功能的早期版本，存在一些限制（例如，要求在容器和 VM 之间建立扁平网络）。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>多环境的支持&lt;/strong>。初步支持将 Istio 与其他服务注册表（包括 Consul 和 Eureka ）结合使用。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>自动注入 Sidecar&lt;/strong>。使用 Kubernetes 中的 &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/">Initializers&lt;/a> alpha 功能，可以在部署后将 Istio 边车自动注入到 Pod 中。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="performance-and-quality">性能及品质&lt;/h3>
&lt;p>整个系统在性能和可靠性方面都有许多改进。
我们尚未考虑将 Istio 0.2 用于生产，但我们在这一方面取得了长足的进步。以下是一些注意事项：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>缓存客户端&lt;/strong>。现在，Envoy 使用的 Mixer 客户端库为 Check 调用提供了缓存，为 Report 调用提供了批处理，从而大大减少了端到端的开销。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>避免热重启&lt;/strong>。通过有效使用 LDS/RDS/CDS/EDS，基本上消除了 Envoy 需要热重启的情况。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>减少内存使用&lt;/strong>。大大减少了 Sidecar 辅助代理的大小，从 50Mb 减少到了 7Mb。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改善 Mixer 延迟&lt;/strong>。Mixer 现在可以清楚地描述配置时间和请求时间的计算，这样可以避免在请求时针对初始请求进行额外的设置工作，从而提供更平滑的平均延迟。
更好的资源缓存还有助于提高端到端性能。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>减少 Egress 流量的延迟&lt;/strong>。现在，我们直接将流量从 sidecar 转发到外部服务。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="traffic-management">流量管理&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>Egress 规则&lt;/strong>。现在可以为 Egress 流量指定路由规则。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>新协议&lt;/strong>。Mesh-wide 现在支持 WebSocket 链接, MongoDB 代理,
和 Kubernetes &lt;a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services">headless 服务&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>其它改进&lt;/strong>。Ingress 正确支持 gRPC 服务，更好的支持健康检查和 Jaeger 追踪。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="policy-enforcement-telemetry">策略执行及遥测&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>Ingress 策略&lt;/strong>。除了 0.1 中支持的东西流量。现在，策略也可以应用于南北流量。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>支持 TCP 服务&lt;/strong>。除了 0.1 中可用的 HTTP 级策略控制外，0.2 还引入了 TCP 服务的策略控制。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>新的 Mixer API&lt;/strong>。Envoy 用于与 Mixer 进行交互的 API 已进行了完全重新设计，以提高健壮性，灵活性，并支持丰富的代理端缓存和批处理以提高性能。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>新的 Mixer Adapter 模型&lt;/strong>。新的适配器组合模型通过模板添加全新的适配器类，使扩展 Mixer 更容易。这种新模型将作为将来许多功能的基础构建块。
请参阅&lt;a href="https://github.com/istio/istio/wiki/Mixer-Compiled-In-Adapter-Dev-Guide">适配器开发者指南&lt;/a>以了解如何编写适配器。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改进 Mixer 构建模型&lt;/strong>。现在，构建包含自定义适配器的 Mixer 二进制文件变得更加容易。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Mixer Adapter 更新&lt;/strong>。内置适配器已全部重写以适合新的适配器模型。该版本已添加了 &lt;code>stackdriver&lt;/code> 适配器。
实验性的 &lt;code>redisquota&lt;/code> 适配器已从 0.2 版本中删除，但有望在 生产就绪的 0.3 版本中回归。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Mixer 调用追踪&lt;/strong>。现在可以在 Zipkin 仪表板中跟踪和分析 Envoy 和 Mixer 之间的调用。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="security">安全&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>TCP 流量的双向 TLS&lt;/strong>。除了 HTTP 流量外，TCP 流量现在也支持双向 TLS。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>VM 和物理机的身份配置&lt;/strong>。Auth 支持使用每节点代理进行身份配置的新机制。
该代理在每个节点（VM /物理机）上运行，并负责生成和发送 CSR（证书签名请求）以从 Istio CA 获取证书。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>使用自己的 CA 证书&lt;/strong>。允许用户向 Istio CA 提供自己的密钥和证书。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>永久性 CA 密钥/证书存储&lt;/strong>。Istio CA 现在将签名密钥/证书持久化存储，以方便 CA 重新启动。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="known-issues">已知问题&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>用户访问应用程序时可能会收到 404&lt;/strong>：我们注意到，Envoy 有时无法正确获取路由，因此将 404 返回给用户。
我们正在对此&lt;a href="https://github.com/istio/istio/issues/1038">问题&lt;/a>进行积极的工作。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>在真正准备就绪之前，Istio Ingress 或 Egress 就报告了准备就绪&lt;/strong>：您可以在 &lt;code>istio-system&lt;/code> 名称空间中检查 &lt;code>istio-ingress&lt;/code> 和 &lt;code>istio-egress&lt;/code> pod 的状态，并在所有 Istio pod 报告就绪状态后等待几秒钟。我们正在对此&lt;a href="https://github.com/istio/istio/pull/1055">问题&lt;/a>进行积极的工作。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>启用了 Istio Auth 的服务无法与一个非 Istio 服务通信&lt;/strong>：此限制将在不久的将来消除。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Tue, 10 Oct 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.2/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.2/</guid></item><item><title>初次了解 Istio</title><description>
&lt;p>Google、IBM 和 Lyft 骄傲的宣布了 &lt;a href="/v1.8/zh">Istio&lt;/a> 的首个公开版本。Istio 是一个以统一方式对微服务实施连接、管理、监控以及安全增强的开源项目。当前版本专注于支持 &lt;a href="https://kubernetes.io/">Kubernetes&lt;/a> 环境，我们计划在接下来的几个月添加诸如虚拟机和 Cloud Foundry 等环境的支持。
Istio 为微服务添加了流量管理能力，同时为比如安全、监控、路由、连接管理和策略等附加能力打下了基础。此软件构建于来自 Lyft 的经过实战检验的 &lt;a href="https://envoyproxy.github.io/envoy/">Envoy&lt;/a> 代理之上，能在 &lt;em>无需改动任何应用代码&lt;/em> 的情况下赋予对应用流量的可见性和控制能力。Istio 为 CIO 们提供了一个在企业内加强安全、策略和合规性的强有力的工具。&lt;/p>
&lt;h2 id="background">背景&lt;/h2>
&lt;p>基于微服务模式编写可靠的、松耦合的、产品级的应用是有挑战的。随着巨型单体应用被分解为微服务，软件团队不得不面对将微服务集成进分布式系统的挑战：服务发现、负载均衡、故障容忍、端到端监测、动态路由，还有最重要的合规和安全。&lt;/p>
&lt;p>层出不穷的方案尝试解决这些挑战，互不一致的库、脚本和堆栈溢出代码段导致这些解决方案跨越多种语言和运行时，严重影响了可观测性，最终危及到安全。&lt;/p>
&lt;p>有一个解决方案是使用通用 RPC 库比如 &lt;a href="https://grpc.io">gRPC&lt;/a>，但是这在大规模适配时花销不菲，且可能在某些事实上无法变更的应用上留下棕色地带。运维人员需要一个灵活的工具来使他们的微服务变得安全、合规、可追踪和高可用，开发人员也需要这种能力来在产品环境实验不同的功能或者部署金丝雀版本而不影响系统的完整性。&lt;/p>
&lt;h2 id="solution-service-mesh">解决方案：服务网格&lt;/h2>
&lt;p>想象一下如果我们可以在服务和网络之间透明的注入一层基础设施来给予运维人员所需要的控制能力的同时又能让开发人员免除需要将解决分布式系统问题的代码糅合到业务代码的烦恼。这种一致的基础设施层与服务开发的搭配通常被称之为 &lt;strong>&lt;em>服务网格&lt;/em>&lt;/strong>。正如微服务帮助不同的功能团队之间互相解耦，服务网格可以帮助解除功能开发和发布流程之间的耦合。Istio 通过在不同的服务网络间注入代理来将不同的微服务集成进同一个服务网格。&lt;/p>
&lt;p>Google、IBM 和 Lyft 为了共同的愿景，基于为内部和企业客户构建和管理大规模微服务的经验合力创造了 Istio，以此来为微服务的开发和维护提供一个可靠的基础。Google 和 IBM 在他们自身的应用以及他们的企业客户的敏感的／ 受管制的环境中实施大规模微服务时积累了丰富的经验，同时 Lyft 开发了 Envoy 以解决他们内部面对的挑战。在成功的将其应用于生产环境，管理过能每秒处理两百万个请求的分布于上万个虚拟机 超过 100 个微服务一年后 &lt;a href="https://eng.lyft.com/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191">Lyft 开源 Envoy&lt;/a> 。&lt;/p>
&lt;h2 id="benefits-of-Istio">Istio 的好处&lt;/h2>
&lt;p>&lt;strong>集群范围的可见性&lt;/strong>：故障时有发生，运维人员需要工具来监控集群健康和微服务状态。Istio 生成有关应用和网络行为的详细监测数据，可使用 &lt;a href="https://prometheus.io/">Prometheus&lt;/a> 和 &lt;a href="https://github.com/grafana/grafana">Grafana&lt;/a> 渲染，也可以发送指标和日志到任何收集、聚合和查询的系统以轻松的扩展其功能。Istio 使用 &lt;a href="https://github.com/openzipkin/zipkin">Zipkin&lt;/a> 提供分析性能瓶颈和诊断分布式故障的功能。&lt;/p>
&lt;figure style="width:100%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:55.425531914893625%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/news/releases/0.x/announcing-0.1/istio_grafana_dashboard-new.png" title="Grafana Dashboard with Response Size">
&lt;img class="element-to-stretch" src="/v1.8/zh/news/releases/0.x/announcing-0.1/istio_grafana_dashboard-new.png" alt="Grafana Dashboard with Response Size" />
&lt;/a>
&lt;/div>
&lt;figcaption>Grafana Dashboard with Response Size&lt;/figcaption>
&lt;/figure>
&lt;figure style="width:100%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:29.912663755458514%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/news/releases/0.x/announcing-0.1/istio_zipkin_dashboard.png" title="Zipkin Dashboard">
&lt;img class="element-to-stretch" src="/v1.8/zh/news/releases/0.x/announcing-0.1/istio_zipkin_dashboard.png" alt="Zipkin Dashboard" />
&lt;/a>
&lt;/div>
&lt;figcaption>Zipkin Dashboard&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;strong>适应能力和效率&lt;/strong>：当开发微服务时，运维人员需要假设网络是不可靠的。运维人员可以使用重试、负载均衡、流程控制（HTTP/2）和熔断等措施来缓解不可靠网络中这些常见的故障。Istio 提供了一致的方式来配置这些功能，使其易于维护一个高适应性的服务网格。&lt;/p>
&lt;p>&lt;strong>开发者生产力&lt;/strong>：Istio 使开发者专注于使用他们喜欢的编程语言构建服务功能，这有效的提升了开发者的生产力，同时 Istio 使用统一的方式处理适应性和网络认证。开发者免于将解决分布式系统问题的代码糅合到业务代码。Istio 提供支持 A/B 测试、金丝雀部署和故障注入的通用功能进一步的提高了生产力。&lt;/p>
&lt;p>&lt;strong>策略驱动运维&lt;/strong>：Istio 赋予肩负不同职责的团队以独立操作的能力。它将集群管理员从应用部署环节中分离，这可以增强应用的安全、监测、伸缩和服务拓扑等能力而 &lt;em>不需要&lt;/em> 变更代码。运维人员可以精确的路由一部分生产流量用于检验一个新版本的服务。他们可以在流量中注入故障和延迟来测试服务网格的适应能力，同时可以设置请求限制来放置服务被过载。Istio 也可以被用于确保合规，在服务间定义 ACL 可以仅允许被授权的服务才能相互访问。&lt;/p>
&lt;p>&lt;strong>默认安全&lt;/strong>：一个常见的缪误是认为分布式计算的网络是安全的。Istio 使用双向 TLS 连接，使运维人员可以确保服务之间的通信是经过认证和安全的，而使开发者或运维人员无需负担繁重的认证管理任务。我们的安全框架符合 &lt;a href="https://spiffe.io/">SPIFFE&lt;/a> 规范，且基于在 Google 内部经过大范围测试的类似系统。&lt;/p>
&lt;p>&lt;strong>渐进式适配&lt;/strong>：我们有意使 Istio 对于运行于网格中的服务完全透明，这允许团队逐步适配 Istio 的功能。适配人员可以首先启用集群范围内的可见性，一旦他们适应了 Istio 的存在，他们可以按需开启其他功能。&lt;/p>
&lt;h2 id="join-us-in-this-journey">加入我们&lt;/h2>
&lt;p>Istio 是一个完全开放的开发项目。今天我们发布了能工作于 Kubernetes 集群的 0.1 版本，我们计划每三个月发布一个大版本，包括支持更多的环境。我们的目标是赋能开发者和运维人员，使他们在所有环境中都能敏捷的发布和维护微服务，拥有底层网络的完全的可见性，且获得一致的控制和安全能力。我们期待与 Istio 社区和我们的合作伙伴一起沿着&lt;a href="/v1.8/zh/about/feature-stages/">路线图&lt;/a>朝着这些目标前进。&lt;/p>
&lt;p>访问&lt;a href="https://github.com/istio/istio/releases">此处&lt;/a>获取最新发布的代码。&lt;/p>
&lt;p>查看在 GlueCon 2017 公布 Istio 时的&lt;a href="/v1.8/talks/istio_talk_gluecon_2017.pdf">介绍&lt;/a>。&lt;/p>
&lt;h2 id="community">社区&lt;/h2>
&lt;p>我们很兴奋的看到来自社区中很多公司的早期支持：
&lt;a href="https://blog.openshift.com/red-hat-istio-launch/">Red Hat&lt;/a> 的 Red Hat OpenShift 和 OpenShift Application Runtimes，
Pivotal 的 &lt;a href="https://content.pivotal.io/blog/pivotal-and-istio-advancing-the-ecosystem-for-microservices-in-the-enterprise">Pivotal Cloud Foundry&lt;/a>，
WeaveWorks 的 &lt;a href="https://www.weave.works/blog/istio-weave-cloud/">Weave Cloud&lt;/a> 和 Weave Net 2.0，
&lt;a href="https://www.projectcalico.org/welcoming-istio-to-the-kubernetes-networking-community">Tigera&lt;/a> 的 Calico Network Policy Engine 项目，还有 &lt;a href="https://www.datawire.io/istio-and-datawire-ecosystem/">Datawire&lt;/a> 的 Ambassador 项目。我们期待看到更多的公司加入我们。&lt;/p>
&lt;p>想要参与时可以通过以下任意渠道与我们联系：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;a href="/v1.8/zh">istio.io&lt;/a> 提供文档和示例。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://discuss.istio.io">Istio discussion board&lt;/a> 综合交流区。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://stackoverflow.com/questions/tagged/istio">Stack Overflow&lt;/a> 用于问答&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://github.com/istio/istio/issues">GitHub&lt;/a> 用于提交 Issue&lt;/p>&lt;/li>
&lt;li>&lt;p>Twitter &lt;a href="https://twitter.com/IstioMesh">@IstioMesh&lt;/a>&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>欢迎登船！&lt;/p>
&lt;h2 id="release-notes">发布说明&lt;/h2>
&lt;ul>
&lt;li>使用单个命令将 Istio 安装到 Kubernetes namespace 中。&lt;/li>
&lt;li>将 Envoy proxy 半自动注入至 Kubernetes Pod 中。&lt;/li>
&lt;li>使用 iptables 自动捕获 Kubernetes Pod 的流量。&lt;/li>
&lt;li>针对 HTTP，gRPC 和 TCP 流量的集群内负载平衡。&lt;/li>
&lt;li>支持超时，预算重试和熔断器。&lt;/li>
&lt;li>Istio 集成的 Kubernetes Ingress 支持（Istio 充当 Ingress Controller）。&lt;/li>
&lt;li>细粒度的流量路由控件，包括 A/B 测试，金丝雀，红/黑部署。&lt;/li>
&lt;li>灵活的内存速率限制。&lt;/li>
&lt;li>使用 Prometheus 进行 HTTP 和 gRPC 的 L7 遥测和日志记录。&lt;/li>
&lt;li>Grafana 仪表板显示每个服务的 L7 指标。&lt;/li>
&lt;li>使用 Envoy 及 Zipkin 实现请求跟踪。&lt;/li>
&lt;li>使用双向 TLS 实现 service-to-service 的认证。&lt;/li>
&lt;li>使用拒绝表达式实现简单 service-to-service 的认证。&lt;/li>
&lt;/ul></description><pubDate>Wed, 24 May 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/0.x/announcing-0.1/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/0.x/announcing-0.1/</guid></item><item><title>对 Istio 1.2 的支持已终止</title><description>&lt;p>如&lt;a href="/v1.8/zh/news/support/announcing-1.2-eol/">先前宣布&lt;/a>的一样, 对 Istio 1.2 的支持现已正式终止。&lt;/p>
&lt;p>我们将不再为 1.2 提供针对安全问题和关键错误的修复程序，因此，如果您尚未升级，
我们建议您升级到最新版本的 Istio (1.8.3)。&lt;/p></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/support/announcing-1.2-eol-final/</link><author/><guid isPermaLink="true">/v1.8/zh/news/support/announcing-1.2-eol-final/</guid></item><item><title>Helm 安装参数变动表</title><description>
&lt;p>下表显示了在 Istio 1.2 版本到 Istio 1.3 版本之间使用 Helm 自定义安装 Istio 时参数变更，主要包含了三种类型的变更：&lt;/p>
&lt;ul>
&lt;li>安装参数在 1.2 版本之前已经存在，但是值在新发布的 1.3 版本中进行了修改。&lt;/li>
&lt;li>1.3 版本新加的参数。&lt;/li>
&lt;li>1.3 版本删除的参数。&lt;/li>
&lt;/ul>
&lt;!-- 下表是运行 python 脚本 scripts/tablegen.py 自动生成 -->
&lt;!-- 自动生成开始 -->
&lt;h2 id="modified-configuration-options">修改的配置选项&lt;/h2>
&lt;h3 id="modified-Kiali-key-value-pairs">修改 &lt;code>kiali&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>老的默认值&lt;/th>
&lt;th>新的默认值&lt;/th>
&lt;th>老的说明&lt;/th>
&lt;th>新的说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.20&lt;/code>&lt;/td>
&lt;td>&lt;code>v1.1.0&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-global-key-value-pairs">修改 &lt;code>global&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>老的默认值&lt;/th>
&lt;th>新的默认值&lt;/th>
&lt;th>老的说明&lt;/th>
&lt;th>新的说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>1.2.0-rc.3&lt;/code>&lt;/td>
&lt;td>&lt;code>release-1.3-latest-daily&lt;/code>&lt;/td>
&lt;td>&lt;code>Istio 镜像默认 tag。&lt;/code>&lt;/td>
&lt;td>&lt;code>Istio 镜像默认 tag。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-gateways-key-value-pairs">修改 &lt;code>gateways&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>老的默认值&lt;/th>
&lt;th>新的默认值&lt;/th>
&lt;th>老的说明&lt;/th>
&lt;th>新的说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>256Mi&lt;/code>&lt;/td>
&lt;td>&lt;code>1024Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-tracing-key-value-pairs">修改 &lt;code>tracing&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>老的默认值&lt;/th>
&lt;th>新的默认值&lt;/th>
&lt;th>老的说明&lt;/th>
&lt;th>新的说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>1.9&lt;/code>&lt;/td>
&lt;td>&lt;code>1.12&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>2&lt;/code>&lt;/td>
&lt;td>&lt;code>2.14.2&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="new-configuration-options">新加的配置选项&lt;/h2>
&lt;h3 id="new-tracing-key-value-pairs">添加 &lt;code>tracing&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>tracing.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.image&lt;/code>&lt;/td>
&lt;td>&lt;code>all-in-one&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.spanStorageType&lt;/code>&lt;/td>
&lt;td>&lt;code>badger&lt;/code>&lt;/td>
&lt;td>&lt;code>对于 all-in-one 模式镜像 spanStorageType 值可以是“memory”和“badger”&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.persist&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.storageClassName&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.accessMode&lt;/code>&lt;/td>
&lt;td>&lt;code>ReadWriteMany&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.image&lt;/code>&lt;/td>
&lt;td>&lt;code>zipkin&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-sidecar-injector-webhook-key-value-pairs">添加 &lt;code>sidecarInjectorWebhook&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-global-key-value-pairs">添加 &lt;code>global&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.proxy.init.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>100m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.init.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>50Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.init.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>10m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.init.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>10Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.host&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如：accesslog-service.istio-system&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.port&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如：15000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tlsSettings.mode&lt;/code>&lt;/td>
&lt;td>&lt;code>DISABLE&lt;/code>&lt;/td>
&lt;td>&lt;code>DISABLE, SIMPLE, MUTUAL, ISTIO_MUTUAL&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tlsSettings.clientCertificate&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如: /etc/istio/als/cert-chain.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tlsSettings.privateKey&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如：/etc/istio/als/key.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tlsSettings.caCertificates&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如：/etc/istio/als/root-cert.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tlsSettings.sni&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如： als.somedomain&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tlsSettings.subjectAltNames&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tcpKeepalive.probes&lt;/code>&lt;/td>
&lt;td>&lt;code>3&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tcpKeepalive.time&lt;/code>&lt;/td>
&lt;td>&lt;code>10s&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyAccessLogService.tcpKeepalive.interval&lt;/code>&lt;/td>
&lt;td>&lt;code>10s&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.protocolDetectionTimeout&lt;/code>&lt;/td>
&lt;td>&lt;code>10ms&lt;/code>&lt;/td>
&lt;td>&lt;code>在服务端，自动协议检测使用一组启发式方法来确定连接是否正在使用 TLS，以及所使用的应用协议（例如，http vs tcp）。 这些试探法依赖于客户端发送第一次请求数。对于一些优先发现的协议，如 MySQL 协议，MongoDB 协议等等，Envoy 在完成协议检测超时情况下，默认为非 mTLS 的普通 TCP 流量。 设置此字段可调整 Envoy 等待客户端发送第一次请求数据时间。（必须 &amp;gt;= 1ms）&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.enableCoreDumpImage&lt;/code>&lt;/td>
&lt;td>&lt;code>ubuntu:xenial&lt;/code>&lt;/td>
&lt;td>&lt;code>当 &amp;quot;enableCoreDump&amp;quot; 设置为 true 的时候，启动核心存储的镜像&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.defaultTolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;code>节点的默认 tolerations 将应用于所有部署，以便可以将所有 Pod 调度到具有匹配 taints 的特定节点。每个组件都可以通过在下面的相关部分中添加其 tolerations block 并设置所需的值来覆盖这些默认值。如果希望将 Istio 控制平面的所有 Pod 都调度到具有指定 taints 的特定节点，请配置此字段。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.meshID&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>MeshID 表示 Mesh 标识符。在可能会彼此交互的 mesh 之间，它应该是唯一的，但是并不需要是全局唯一的。例如，如果满足以下任一条件，则两个 mesh 必须具有不同的 MeshID：- Mesh 将遥测聚集在同一个地方。- Mesh 将联合在一起。- 策略将被另一个 Mesh 引用。管理员希望这些条件中的任何一种将来可能成为现实，因此应确保为其 Mesh 分配了不同的 MeshID。在多集群 Mesh 中，每个集群必须（手动或自动）配置为具有相同的 MeshID 值。如果现有集群“加入”到多集群 Mesh 则需要将其迁移到新的 MeshID。迁移的详细信息待定，并且在安装后更改 MeshID 可能是一项破坏性操作。如果 Mesh 管理者未指定值，则 Istio 将使用 Mesh “信任域”的值。最佳实践是选择适当的“信任域”值。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.localityLbSetting.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-galley-key-value-pairs">添加 &lt;code>galley&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>galley.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>galley.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-mixer-key-value-pairs">添加 &lt;code>mixer&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.policy.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.reportBatchMaxEntries&lt;/code>&lt;/td>
&lt;td>&lt;code>100&lt;/code>&lt;/td>
&lt;td>&lt;code>将 reportBatchMaxEntries 设置为 0 表示使用默认的批处理行为（即每 100 个批处理一次）。 正值表示遥测数据发送到 mixer 服务器之前已批处理的请求数&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.reportBatchMaxTime&lt;/code>&lt;/td>
&lt;td>&lt;code>1s&lt;/code>&lt;/td>
&lt;td>&lt;code>将 reportBatchMaxTime 设置为 0 以使用默认的批处理行为（即每 1 秒批处理一次）。 正值表示处理完上次请求并将遥测数据发送到 mixer 服务器后，进行下次批处理前的最大等待时间&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Grafana-key-value-pairs">添加 &lt;code>grafana&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>grafana.env&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.envSecrets&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type.orgId&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type.url&lt;/code>&lt;/td>
&lt;td>&lt;code>http://prometheus:9090&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type.access&lt;/code>&lt;/td>
&lt;td>&lt;code>proxy&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type.isDefault&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type.jsonData.timeInterval&lt;/code>&lt;/td>
&lt;td>&lt;code>5s&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type.editable&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.orgId.folder&lt;/code>&lt;/td>
&lt;td>&lt;code>'istio'&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.orgId.type&lt;/code>&lt;/td>
&lt;td>&lt;code>file&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.orgId.disableDeletion&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.orgId.options.path&lt;/code>&lt;/td>
&lt;td>&lt;code>/var/lib/grafana/dashboards/istio&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Prometheus-key-value-pairs">添加 &lt;code>prometheus&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>prometheus.image&lt;/code>&lt;/td>
&lt;td>&lt;code>prometheus&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-gateways-key-value-pairs">添加 &lt;code>gateways&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-cert-manager-key-value-pairs">添加 &lt;code>certmanager&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>certmanager.image&lt;/code>&lt;/td>
&lt;td>&lt;code>cert-manager-controller&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Kiali-key-value-pairs">添加 &lt;code>kiali&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.image&lt;/code>&lt;/td>
&lt;td>&lt;code>kiali&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.auth.strategy&lt;/code>&lt;/td>
&lt;td>&lt;code>login&lt;/code>&lt;/td>
&lt;td>&lt;code>可以通过匿名，登录，或者是 openshift 方式&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.security.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.security.cert_file&lt;/code>&lt;/td>
&lt;td>&lt;code>/kiali-cert/cert-chain.pem&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.security.private_key_file&lt;/code>&lt;/td>
&lt;td>&lt;code>/kiali-cert/key.pem&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Istio-core-DNS-key-value-pairs">添加 &lt;code>istiocoredns&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>istiocoredns.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-security-key-value-pairs">添加 &lt;code>security&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>security.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.workloadCertTtl&lt;/code>&lt;/td>
&lt;td>&lt;code>2160h&lt;/code>&lt;/td>
&lt;td>&lt;code>90*24hour = 2160h&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.enableNamespacesByDefault&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>如果在给定命名空间上找不到 ca.istio.io/env 或 ca.istio.io/override 标签，则确定 Citadel 默认行为。 例如：考虑一个名为 “target” 的命名空间，该命名空间既没有 ca.istio.io/env 也没有 ca.istio.io/override 命名空间标签，为了确定是否为在 “target” 命名空间中创建的服务帐户生成 secret，Citadel 将采用此选项。如果在这种情况下此选项的值为 “true”，则将为 “target” 命名空间生成 secret。 如果此选项的值为“false”，则 Citadel 在创建服务帐户时不会生成机密信息。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-pilot-key-value-pairs">添加 &lt;code>pilot&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pilot.rollingMaxSurge&lt;/code>&lt;/td>
&lt;td>&lt;code>100%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.rollingMaxUnavailable&lt;/code>&lt;/td>
&lt;td>&lt;code>25%&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.enableProtocolSniffing&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果启用了协议嗅探。默认为 false。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="removed-configuration-options">删除的配置选项&lt;/h2>
&lt;h3 id="removed-global-key-value-pairs">删除 &lt;code>global&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.sds.useTrustworthyJwt&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.sds.useNormalJwt&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.localityLbSetting&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-mixer-key-value-pairs">删除 &lt;code>mixer&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.templates.seTemplateCRDs&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-Grafana-key-value-pairs">删除 &lt;code>grafana&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.disableDeletion&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.type&lt;/code>&lt;/td>
&lt;td>&lt;code>file&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.folder&lt;/code>&lt;/td>
&lt;td>&lt;code>'istio'&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.isDefault&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.url&lt;/code>&lt;/td>
&lt;td>&lt;code>http://prometheus:9090&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.access&lt;/code>&lt;/td>
&lt;td>&lt;code>proxy&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.jsonData.timeInterval&lt;/code>&lt;/td>
&lt;td>&lt;code>5s&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.options.path&lt;/code>&lt;/td>
&lt;td>&lt;code>/var/lib/grafana/dashboards/istio&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.editable&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.orgId&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!-- 自动生成结束--></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3/helm-changes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3/helm-changes/</guid><category>kubernetes</category><category>helm</category><category>install</category><category>options</category></item><item><title>Helm 安装参数变动表</title><description>
&lt;p>下表显示了在 Istio 1.0 版本到 Istio 1.1 版本之间使用 Helm 自定义安装 Istio 时参数变更，主要包含了三种类型的变更：&lt;/p>
&lt;ul>
&lt;li>安装参数在 1.0 版本之前已经存在，但是值在新发布的 1.1 版本中进行了修改。&lt;/li>
&lt;li>1.1 版本新加的参数。&lt;/li>
&lt;li>1.1 版本删除的参数。&lt;/li>
&lt;/ul>
&lt;!-- 下表是运行 python 脚本 scripts/tablegen.py 自动生成 -->
&lt;!-- 自动生成开始 -->
&lt;h2 id="modified-configuration-options">修改配置选项&lt;/h2>
&lt;h3 id="modified-key-value-pairs">修改 &lt;code>servicegraph&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>servicegraph.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>servicegraph.local&lt;/code>&lt;/td>
&lt;td>&lt;code>servicegraph.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>用来创建一个 Ingress record。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-tracing-key-value-pairs">修改 &lt;code>tracing&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>1.5&lt;/code>&lt;/td>
&lt;td>&lt;code>1.9&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-global-key-value-pairs">修改 &lt;code>global&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.hub&lt;/code>&lt;/td>
&lt;td>&lt;code>gcr.io/istio-release&lt;/code>&lt;/td>
&lt;td>&lt;code>gcr.io/istio-release&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>Istio 镜像的默认仓库。已发布版本的 Istio 镜像已经推送到了 docker hub 中的 istio 项目下，白天会从 gcr.io 进行构建，夜晚会从 docker.io/istionightly 上进行构建。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>release-1.0-latest-daily&lt;/code>&lt;/td>
&lt;td>&lt;code>release-1.1-latest-daily&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>Istio 镜像的默认标签。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>10m&lt;/code>&lt;/td>
&lt;td>&lt;code>100m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.accessLogFile&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;/dev/stdout&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.enableCoreDump&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>如果设置，新注入的 sidecars 将启用 core dumps。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.autoInject&lt;/code>&lt;/td>
&lt;td>&lt;code>enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>enabled&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>可以控制 sidecar 的注入策略。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyStatsd.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>如果设置为 true，则还须提供主机地址和端口。Istio 不再提供 statsd 收集器。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyStatsd.host&lt;/code>&lt;/td>
&lt;td>&lt;code>istio-statsd-prom-bridge&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>例如: statsd-svc.istio-system&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyStatsd.port&lt;/code>&lt;/td>
&lt;td>&lt;code>9125&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>例如: 9125&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy_init.image&lt;/code>&lt;/td>
&lt;td>&lt;code>proxy_init&lt;/code>&lt;/td>
&lt;td>&lt;code>proxy_init&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>proxy_init 容器的基本名称，用于配置 iptables。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.controlPlaneSecurityEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>启用 controlPlaneMtls。在传播 secret 时，将导致 Pod 的延迟启动，不建议用于测试。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.disablePolicyChecks&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>disablePolicyChecks 禁用 mixer 策略检查。如果 mixer.policy.enabled==true 则 disablePolicyChecks 已生效。将在 istio ConfigMap 设置相同名称的值 - pilot 需要重新启动才能生效。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.enableTracing&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>EnableTracing 在 istio ConfigMap 中具有相同名称的值，需要重新启动 pilot 才能生效。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.mtls.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>服务到服务间的 mtls 的默认设置。可以使用目标规则或服务注释来显式设置。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.oneNamespace&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>是否限制控制器管理的应用程序的名称空间；如果未设置，则控制器将监控所有名称空间。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.configValidation&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>是否执行服务器端配置验证。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-gateways-key-value-pairs">修改 &lt;code>gateways&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.type&lt;/code>&lt;/td>
&lt;td>&lt;code>LoadBalancer #change to NodePort, ClusterIP or LoadBalancer if need be&lt;/code>&lt;/td>
&lt;td>&lt;code>LoadBalancer&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>如果需要，请更改为节点端口，集群 IP，或者负载地址。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.type&lt;/code>&lt;/td>
&lt;td>&lt;code>ClusterIP #change to NodePort or LoadBalancer if need be&lt;/code>&lt;/td>
&lt;td>&lt;code>ClusterIP&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>如果需要，请更改为节点端口或者负载地址。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified--key-value-pairs">修改 &lt;code>certmanager&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>certmanager.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.3.1&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.6.2&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-key-value-pairs-1">修改 &lt;code>kiali&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>istio-release-1.0&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.14&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-security-key-value-pairs">修改 &lt;code>security&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>security.selfSigned&lt;/code>&lt;/td>
&lt;td>&lt;code>true # indicate if self-signed CA is used.&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;code>是否使用自签名 CA 证书。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-pilot-key-value-pairs">修改 &lt;code>pilot&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pilot.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.traceSampling&lt;/code>&lt;/td>
&lt;td>&lt;code>100.0&lt;/code>&lt;/td>
&lt;td>&lt;code>1.0&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="new-configuration-options">新的配置选项&lt;/h2>
&lt;h3 id="new-key-value-pairs">新增 &lt;code>istio_cni&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>istio_cni.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-1">新增 &lt;code>servicegraph&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>servicegraph.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-tracing-key-value-pairs">新增 &lt;code>tracing&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>tracing.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.hub&lt;/code>&lt;/td>
&lt;td>&lt;code>docker.io/openzipkin&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>2&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.probeStartupDelay&lt;/code>&lt;/td>
&lt;td>&lt;code>200&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.queryPort&lt;/code>&lt;/td>
&lt;td>&lt;code>9411&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>300m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>900Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>150m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>900Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.javaOptsHeap&lt;/code>&lt;/td>
&lt;td>&lt;code>700&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.maxSpans&lt;/code>&lt;/td>
&lt;td>&lt;code>500000&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.zipkin.node.cpus&lt;/code>&lt;/td>
&lt;td>&lt;code>2&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-2">新增 &lt;code>sidecarInjectorWebhook&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.rewriteAppHTTPProbe&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设置为 true，则 webhook 或 istioctl injector 将重写 PodSpec 进行 livenesshealth 检查，以将请求重定向到 Sidecar，即使启用了 mTLS，也可以进行活动检查。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-global-key-value-pairs">新增 &lt;code>global&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.monitoringPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15014&lt;/code>&lt;/td>
&lt;td>&lt;code>监控被 mixer、 pilot 和 galley 所使用的端口。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.k8sIngress.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.k8sIngress.gatewayName&lt;/code>&lt;/td>
&lt;td>&lt;code>ingressgateway&lt;/code>&lt;/td>
&lt;td>&lt;code>用于 k8s 入口资源的网关，默认情况下，它使用的是 istio：ingressgateway，将 gateways.enabled 和 gateways.istio-ingressgateway.enabled 标志设置为 true 即可安装。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.k8sIngress.enableHttps&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>enableHttps 将在入口处添加 443 端口，它要求将证书安装在预期的 secret 中，启用不带证书的此选项将导致 LDS 拒绝，并且入口将不起作用。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.clusterDomain&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;cluster.local&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>集群域，默认值为 cluster.local。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>128Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>2000m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>128Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.concurrency&lt;/code>&lt;/td>
&lt;td>&lt;code>2&lt;/code>&lt;/td>
&lt;td>&lt;code>控制代理工作线程的数量，如果设置为 0（默认值），则为每个 CPU 线程/核心。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.accessLogFormat&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>配置 sidecar 访问日志中显示方式和字段的显示方式，设置空字符串将导致成为默认的日志格式。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.accessLogEncoding&lt;/code>&lt;/td>
&lt;td>&lt;code>TEXT&lt;/code>&lt;/td>
&lt;td>&lt;code>将 Sidecar 的访问日志配置为 JSON 或 TEXT 格式。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.dnsRefreshRate&lt;/code>&lt;/td>
&lt;td>&lt;code>5s&lt;/code>&lt;/td>
&lt;td>&lt;code>为类型为 STRICT_DNS 的 Envoy 集群配置 DNS 的刷新频率为 5s，是 Envoy 使用的默认刷新频率。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.privileged&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设置为 true，则 istio-proxy 容器将具有特权 securityContext。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.statusPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15020&lt;/code>&lt;/td>
&lt;td>&lt;code>Pilot 代理运行状况检查的默认端口，设置为 0 将禁用运行状况检查。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.readinessInitialDelaySeconds&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;code>准备就绪探测的初始延迟（以秒为单位）。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.readinessPeriodSeconds&lt;/code>&lt;/td>
&lt;td>&lt;code>2&lt;/code>&lt;/td>
&lt;td>&lt;code>准备就绪探测之间的时间间隔。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.readinessFailureThreshold&lt;/code>&lt;/td>
&lt;td>&lt;code>30&lt;/code>&lt;/td>
&lt;td>&lt;code>指示准备就绪失败之前，连续失败的探测数。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.kubevirtInterfaces&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>pod 的内部接口。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyMetricsService.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyMetricsService.host&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如：metrics-service.istio-system&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.envoyMetricsService.port&lt;/code>&lt;/td>
&lt;td>``&lt;/td>
&lt;td>&lt;code>例如：15000&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.tracer&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;zipkin&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>指定要使用的跟踪器，lightstep 和 zipkin 其中之一。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.policyCheckFailOpen&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>policyCheckFailOpen 允许在无法访问 mixer 策略的情况下进行通信，默认值为 false，这意味着在客户端无法连接到 Mixer 时拒绝通信。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tracer.lightstep.address&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>例如：lightstep-satellite:443&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tracer.lightstep.accessToken&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>例如：abcdefg1234567&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tracer.lightstep.secure&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>例如：true\|false&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tracer.lightstep.cacertPath&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>例如：/etc/lightstep/cacert.pem&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tracer.zipkin.address&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.defaultNodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;code>默认 node selector 将应用于所有部署，以便可以限制所有特定的 Pod 节点，每个组件都可以通过在下面的相关部分中添加 node selector block 并设置所需的值来覆盖这些默认值。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.meshExpansion.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.meshExpansion.useILB&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设置为 true，则将在内部网关上暴露 pilot 和 citadel mtls 以及 plain text pilot portswill。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.multiCluster.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>当每个集群中的 Pod 无法直接相互通信时，设置为 true 可通过它们各自的 ingress gateway 服务连接两个 kubernetes 集群，所有群集都应使用 Istio mTLS，并且必须具有共享的根证书才能使该模型正常工作。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.defaultPodDisruptionBudget.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.useMCP&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>使用网格控制协议（MCP）来配置 Mixer 和 Pilot。需要 galley (--设置 galley.enabled=true)。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.trustDomain&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.outboundTrafficPolicy.mode&lt;/code>&lt;/td>
&lt;td>&lt;code>ALLOW_ANY&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.sds.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>是否启用 SDS。如果设置为 true，则将通过 SecretDiscoveryService 分发用于 sidecars 的 mTLS 证书，而不是使用 K8S secret 来挂载证书。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.sds.udsPath&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.sds.useTrustworthyJwt&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.sds.useNormalJwt&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.meshNetworks&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.enableHelmTest&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>指定是否启 helm 测试，默认情况下，此字段默认设置为 false，因此 'helm template ...' 将在生成模板时忽略 helm 测试的 yaml 文件。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-mixer-key-value-pairs">新增 &lt;code>mixer&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.env.GODEBUG&lt;/code>&lt;/td>
&lt;td>&lt;code>gctrace=1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.env.GOMAXPROCS&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;6&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>max procs should be ceil(cpu limit + 1)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果启用了策略，则 global.disablePolicyChecks 将生效。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.autoscaleMin&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.policy.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.autoscaleMin&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.sessionAffinityEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.loadshedding.mode&lt;/code>&lt;/td>
&lt;td>&lt;code>enforce&lt;/code>&lt;/td>
&lt;td>&lt;code>禁用，仅用于登录或强制执行。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.loadshedding.latencyThreshold&lt;/code>&lt;/td>
&lt;td>&lt;code>100ms&lt;/code>&lt;/td>
&lt;td>&lt;code>基于 100ms 的测量，p50 转换为 p99 不到 1s，对于本质上是异步的遥测来说是没问题的。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>1000m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>1G&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>4800m&lt;/code>&lt;/td>
&lt;td>&lt;code>最好使用适度的 cpu 进行分配使 mixer 水平缩放。我们通过实验发现这些值效果很好。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.telemetry.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>4G&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.podAnnotations&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.kubernetesenv.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.stdio.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.stdio.outputAsJson&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.prometheus.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.prometheus.metricsExpiryDuration&lt;/code>&lt;/td>
&lt;td>&lt;code>10m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.useAdapterCRDs&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设置为 false， 会将 useAdapterCRDs mixer 的启动参数设置为 false。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-3">新增 &lt;code>grafana&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>grafana.image.repository&lt;/code>&lt;/td>
&lt;td>&lt;code>grafana/grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.image.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>5.4.0&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.ingress.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>grafana.local&lt;/code>&lt;/td>
&lt;td>&lt;code>用来创建一个 Ingress record。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.persist&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.storageClassName&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.accessMode&lt;/code>&lt;/td>
&lt;td>&lt;code>ReadWriteMany&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.security.secretName&lt;/code>&lt;/td>
&lt;td>&lt;code>grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.security.usernameKey&lt;/code>&lt;/td>
&lt;td>&lt;code>username&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.security.passphraseKey&lt;/code>&lt;/td>
&lt;td>&lt;code>passphrase&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.contextPath&lt;/code>&lt;/td>
&lt;td>&lt;code>/grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.apiVersion&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.type&lt;/code>&lt;/td>
&lt;td>&lt;code>prometheus&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.orgId&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.url&lt;/code>&lt;/td>
&lt;td>&lt;code>http://prometheus:9090&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.access&lt;/code>&lt;/td>
&lt;td>&lt;code>proxy&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.isDefault&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.jsonData.timeInterval&lt;/code>&lt;/td>
&lt;td>&lt;code>5s&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.datasources.datasources.datasources.editable&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.apiVersion&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.orgId&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.folder&lt;/code>&lt;/td>
&lt;td>&lt;code>'istio'&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.type&lt;/code>&lt;/td>
&lt;td>&lt;code>file&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.disableDeletion&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.dashboardProviders.dashboardproviders.providers.options.path&lt;/code>&lt;/td>
&lt;td>&lt;code>/var/lib/grafana/dashboards/istio&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-4">新增 &lt;code>prometheus&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>prometheus.retention&lt;/code>&lt;/td>
&lt;td>&lt;code>6h&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.scrapeInterval&lt;/code>&lt;/td>
&lt;td>&lt;code>15s&lt;/code>&lt;/td>
&lt;td>&lt;code>控制 prometheus 在 scraping 时的频率。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.contextPath&lt;/code>&lt;/td>
&lt;td>&lt;code>/prometheus&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.ingress.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>prometheus.local&lt;/code>&lt;/td>
&lt;td>&lt;code>用来创建一个 Ingress record。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.security.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-gateways-key-value-pairs">新增 &lt;code>gateways&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.sds.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设置为 true，则入口网关从 SDS 服务器获取凭据以处理 TLS 连接。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.sds.image&lt;/code>&lt;/td>
&lt;td>&lt;code>node-agent-k8s&lt;/code>&lt;/td>
&lt;td>&lt;code>监视 kubernetes 的 secret 并向入口网关提供凭据的 SDS 服务器，该服务器与入口网关服务器在同一容器中运行。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.loadBalancerSourceRanges&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.externalIPs&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.podAnnotations&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15029&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>https-kiali&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>https-prometheus&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>https-grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15032&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>https-tracing&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15443&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15020&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>status-port&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15011&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tcp-pilot-grpc-tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15004&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tcp-mixer-grpc-tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>8060&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tcp-citadel-grpc-tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>853&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.meshExpansionPorts.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tcp-dns-tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.env.ISTIO_META_ROUTER_MODE&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;sni-dnat&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>具有此模式的网关可确保 pilot 为内部服务生成集群中的 additionalset，但无需 Istio mTLS，即可启用跨群集路由。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.podAnnotations&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15443&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.env.ISTIO_META_ROUTER_MODE&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;sni-dnat&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.podAnnotations&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-5">新增 &lt;code>kiali&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.contextPath&lt;/code>&lt;/td>
&lt;td>&lt;code>/kiali&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>kiali.local&lt;/code>&lt;/td>
&lt;td>&lt;code>用来创建一个 Ingress record。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.secretName&lt;/code>&lt;/td>
&lt;td>&lt;code>kiali&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.usernameKey&lt;/code>&lt;/td>
&lt;td>&lt;code>username&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.passphraseKey&lt;/code>&lt;/td>
&lt;td>&lt;code>passphrase&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.prometheusAddr&lt;/code>&lt;/td>
&lt;td>&lt;code>http://prometheus:9090&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.createDemoSecret&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>设置为 true 时，将使用默认的用户名和密码创建一个 secret， 对一些 demo 有用。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-6">新增 &lt;code>istiocoredns&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>istiocoredns.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.coreDNSImage&lt;/code>&lt;/td>
&lt;td>&lt;code>coredns/coredns:1.1.2&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.coreDNSPluginImage&lt;/code>&lt;/td>
&lt;td>&lt;code>istio/coredns-plugin:0.2-istio-1.1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-security-key-value-pairs">新增 &lt;code>security&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>security.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.createMeshPolicy&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-key-value-pairs-7">新增 &lt;code>nodeagent&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>nodeagent.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.image&lt;/code>&lt;/td>
&lt;td>&lt;code>node-agent-k8s&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.env.CA_PROVIDER&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>provider 的名称。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.env.CA_ADDR&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>CA 地址。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.env.Plugins&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>鉴别 provider 插件的名称。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-pilot-key-value-pairs">新增 &lt;code>pilot&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pilot.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.env.PILOT_PUSH_THROTTLE&lt;/code>&lt;/td>
&lt;td>&lt;code>100&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.env.GODEBUG&lt;/code>&lt;/td>
&lt;td>&lt;code>gctrace=1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.keepaliveMaxServerConnectionAge&lt;/code>&lt;/td>
&lt;td>&lt;code>30m&lt;/code>&lt;/td>
&lt;td>&lt;code>用于限制 sidecar 可以被 pilot 连接多久，平衡了 pilot 实例的负载，以损失系统资源为代价。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="removed-configuration-options">移除的配置选项&lt;/h2>
&lt;h3 id="removed-ingress-key-value-pairs">移除 &lt;code>ingress&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>ingress.service.ports.nodePort&lt;/code>&lt;/td>
&lt;td>&lt;code>32000&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.service.selector.istio&lt;/code>&lt;/td>
&lt;td>&lt;code>ingress&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.autoscaleMin&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.service.loadBalancerIP&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.service.annotations&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.service.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>http&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.service.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>https&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ingress.service.type&lt;/code>&lt;/td>
&lt;td>&lt;code>LoadBalancer #change to NodePort, ClusterIP or LoadBalancer if need be&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-key-value-pairs">移除 &lt;code>servicegraph&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>servicegraph&lt;/code>&lt;/td>
&lt;td>&lt;code>servicegraph.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.ingress&lt;/code>&lt;/td>
&lt;td>&lt;code>servicegraph.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.service.internalPort&lt;/code>&lt;/td>
&lt;td>&lt;code>8088&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-telemetry-gateway-key-value-pairs">移除 &lt;code>telemetry-gateway&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>telemetry-gateway.prometheusEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>telemetry-gateway.gatewayName&lt;/code>&lt;/td>
&lt;td>&lt;code>ingressgateway&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>telemetry-gateway.grafanaEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-global-key-value-pairs">移除 &lt;code>global&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.hyperkube.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>v1.7.6_coreos.0&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.k8sIngressHttps&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.crds&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.hyperkube.hub&lt;/code>&lt;/td>
&lt;td>&lt;code>quay.io/coreos&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.meshExpansion&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.k8sIngressSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>ingress&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.meshExpansionILB&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-mixer-key-value-pairs">移除 &lt;code>mixer&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.autoscaleMin&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-policy.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-telemetry.autoscaleMin&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.prometheusStatsdExporter.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.6.0&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-telemetry.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-telemetry.cpu.targetAverageUtilization&lt;/code>&lt;/td>
&lt;td>&lt;code>80&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-policy.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-telemetry.autoscaleEnabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.prometheusStatsdExporter.hub&lt;/code>&lt;/td>
&lt;td>&lt;code>docker.io/prom&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-policy.autoscaleMin&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.istio-policy.autoscaleMax&lt;/code>&lt;/td>
&lt;td>&lt;code>5&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-key-value-pairs-1">移除 &lt;code>grafana&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>grafana.image&lt;/code>&lt;/td>
&lt;td>&lt;code>grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.service.internalPort&lt;/code>&lt;/td>
&lt;td>&lt;code>3000&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.security.adminPassword&lt;/code>&lt;/td>
&lt;td>&lt;code>admin&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.security.adminUser&lt;/code>&lt;/td>
&lt;td>&lt;code>admin&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-gateways-key-value-pairs">移除 &lt;code>gateways&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tcp-pilot-grpc-tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>tcp-citadel-grpc-tls&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>http2-prometheus&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.name&lt;/code>&lt;/td>
&lt;td>&lt;code>http2-grafana&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>15011&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.ports.targetPort&lt;/code>&lt;/td>
&lt;td>&lt;code>8060&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-tracing-key-value-pairs">移除 &lt;code>tracing&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>tracing.service.internalPort&lt;/code>&lt;/td>
&lt;td>&lt;code>9411&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.ingress&lt;/code>&lt;/td>
&lt;td>&lt;code>jaeger.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.ingress&lt;/code>&lt;/td>
&lt;td>&lt;code>tracing.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger&lt;/code>&lt;/td>
&lt;td>&lt;code>jaeger.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing&lt;/code>&lt;/td>
&lt;td>&lt;code>jaeger.local tracing.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>jaeger.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.ingress.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>tracing.local&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.jaeger.ui.port&lt;/code>&lt;/td>
&lt;td>&lt;code>16686&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-key-value-pairs-2">移除 &lt;code>kiali&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.username&lt;/code>&lt;/td>
&lt;td>&lt;code>admin&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.passphrase&lt;/code>&lt;/td>
&lt;td>&lt;code>admin&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-pilot-key-value-pairs">移除 &lt;code>pilot&lt;/code> 键/值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pilot.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!-- 自动生成结束 --></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1/helm-changes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1/helm-changes/</guid><category>kubernetes</category><category>helm</category><category>install</category><category>options</category></item><item><title>Helm 变更</title><description>
&lt;p>下面的表格展示了 Istio 1.2 相比于 Istio 1.1 在使用 Helm 安装时关于自定义安装选项的一些变化。表格分为三类：&lt;/p>
&lt;ul>
&lt;li>安装选项在之前发行版本中就已经有了，但是在新发行版本中对其值作了修改。&lt;/li>
&lt;li>在新发行版本中增加的安装选项。&lt;/li>
&lt;li>在新发行版本中被移除的安装选项。&lt;/li>
&lt;/ul>
&lt;!-- Run python scripts/tablegen.py to generate this table -->
&lt;!-- AUTO-GENERATED-START -->
&lt;h2 id="modified-configuration-options">作了修改的配置选项&lt;/h2>
&lt;h3 id="modified-Kiali-key-value-pairs">修改 &lt;code>kiali&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.hub&lt;/code>&lt;/td>
&lt;td>&lt;code>docker.io/kiali&lt;/code>&lt;/td>
&lt;td>&lt;code>quay.io/kiali&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.14&lt;/code>&lt;/td>
&lt;td>&lt;code>v0.20&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-Prometheus-key-value-pairs">修改 &lt;code>prometheus&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>prometheus.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>v2.3.1&lt;/code>&lt;/td>
&lt;td>&lt;code>v2.8.0&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-global-key-value-pairs">修改 &lt;code>global&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>release-1.1-latest-daily&lt;/code>&lt;/td>
&lt;td>&lt;code>1.2.0-rc.3&lt;/code>&lt;/td>
&lt;td>&lt;code>Istio 镜像的默认标签。&lt;/code>&lt;/td>
&lt;td>&lt;code>Istio 镜像的默认标签。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>128Mi&lt;/code>&lt;/td>
&lt;td>&lt;code>1024Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.dnsRefreshRate&lt;/code>&lt;/td>
&lt;td>&lt;code>5s&lt;/code>&lt;/td>
&lt;td>&lt;code>300s&lt;/code>&lt;/td>
&lt;td>&lt;code>配置 STRICT_DNS 类型的 Envoy 集群的 DNS 刷新速率，默认值为 5 秒&lt;/code>&lt;/td>
&lt;td>&lt;code>配置 STRICT_DNS 类型的 Envoy 集群的 DNS 刷新速率，单位必须为秒。例如，可以 设为 300s，不能设为 5m&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-mixer-key-value-pairs">修改 &lt;code>mixer&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.adapters.useAdapterCRDs&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设这个值为 false，则 useAdapterCRDs mixer 的起始参数为 false&lt;/code>&lt;/td>
&lt;td>&lt;code>如果设这个值为 false，则 useAdapterCRDs mixer 的起始参数为 false&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="modified-Grafana-key-value-pairs">修改 &lt;code>grafana&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>旧默认值&lt;/th>
&lt;th>新默认值&lt;/th>
&lt;th>旧描述&lt;/th>
&lt;th>新描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>grafana.image.tag&lt;/code>&lt;/td>
&lt;td>&lt;code>5.4.0&lt;/code>&lt;/td>
&lt;td>&lt;code>6.1.6&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="new-configuration-options">新增的配置选项&lt;/h2>
&lt;h3 id="new-tracing-key-value-pairs">新增 &lt;code>tracing&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>tracing.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>tracing.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-sidecar-injector-webhook-key-value-pairs">新增 &lt;code>sidecarInjectorWebhook&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.neverInjectSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;code>你可以用alwaysInjectSelector 和 neverInjectSelector 两个值，分别表示强制注入 sidecar 和无视全局策略，跳过符合标签过滤条件的 pod。请查看 https://istio.io/docs/setup/kubernetes/additional-setup/sidecar-injection/more-control-adding-exceptions&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>sidecarInjectorWebhook.alwaysInjectSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-global-key-value-pairs">新增 &lt;code>global&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>global.logging.level&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;default:info&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.logLevel&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>代理的 log 等级，用于 gateway 和 sidecar。如果值为空，则使用 &amp;quot;warning&amp;quot;。可选的值为：trace\|debug\|info\|warning\|error\|critical\|off&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.componentLogLevel&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;code>代理的每一个组件的 log 等级，用于 gateway 和 sidecar。如果组件等级未设置，则使用全局的 &amp;quot;logLevel&amp;quot;。如果设置值为空，则使用 &amp;quot;misc:error&amp;quot;。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.proxy.excludeOutboundPorts&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.tracer.datadog.address&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;$(HOST_IP):8126&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.imagePullSecrets&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;code>列出你从一个安全的镜像仓库拉取 Istio 镜像时需要用的 secret&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>global.localityLbSetting&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-galley-key-value-pairs">新增 &lt;code>galley&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>galley.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>galley.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>galley.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>galley.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="新增-mixer-键值对">新增 &lt;code>mixer&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>mixer.templates.useTemplateCRDs&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Grafana-key-value-pairs">新增 &lt;code>grafana&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>grafana.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>grafana.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Prometheus-key-value-pairs">新增 &lt;code>prometheus&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>prometheus.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>prometheus.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-gateways-key-value-pairs">新增 &lt;code>gateways&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.sds.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>100m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.sds.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>128Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.sds.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>2000m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.sds.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>1024Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>100m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>128Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>2000m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>1024Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.applicationPorts&lt;/code>&lt;/td>
&lt;td>&lt;code>&amp;quot;&amp;quot;&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.resources.requests.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>100m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.resources.requests.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>128Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.resources.limits.cpu&lt;/code>&lt;/td>
&lt;td>&lt;code>2000m&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.resources.limits.memory&lt;/code>&lt;/td>
&lt;td>&lt;code>256Mi&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-egressgateway.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ilbgateway.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-cert-manager-key-value-pairs">新增 &lt;code>certmanager&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>certmanager.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>certmanager.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>certmanager.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>certmanager.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>certmanager.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Kiali-key-value-pairs">新增 &lt;code>kiali&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.viewOnlyMode&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;code>将一个服务账户与一个只读的角色绑定&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-Istio-CoreDNS-key-value-pairs">新增 &lt;code>istiocoredns&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>istiocoredns.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>istiocoredns.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-security-key-value-pairs">新增 &lt;code>security&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>security.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.citadelHealthCheck&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>security.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-node-agent-key-value-pairs">新增 &lt;code>nodeagent&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>nodeagent.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>nodeagent.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="new-pilot-key-value-pairs">新增 &lt;code>pilot&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>pilot.tolerations&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.podAntiAffinityLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>pilot.podAntiAffinityTermLabelSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>[]&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="removed-configuration-options">被移除的配置选项&lt;/h2>
&lt;h3 id="removed-Kiali-key-value-pairs">移除 &lt;code>kiali&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.usernameKey&lt;/code>&lt;/td>
&lt;td>&lt;code>username&lt;/code>&lt;/td>
&lt;td>&lt;code>secret 中用户名的键名。&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kiali.dashboard.passphraseKey&lt;/code>&lt;/td>
&lt;td>&lt;code>passphrase&lt;/code>&lt;/td>
&lt;td>&lt;code>secret 中密码的键名。&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-security-key-value-pairs">移除 &lt;code>security&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>security.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-gateways-key-value-pairs">移除 &lt;code>gateways&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>gateways.istio-ingressgateway.resources&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-mixer-key-value-pairs">移除 &lt;code>mixer&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>mixer.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>true&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="removed-service-graph-key-value-pairs">移除 &lt;code>servicegraph&lt;/code> 键值对&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>键&lt;/th>
&lt;th>默认值&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>servicegraph.ingress.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.service.name&lt;/code>&lt;/td>
&lt;td>&lt;code>http&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.replicaCount&lt;/code>&lt;/td>
&lt;td>&lt;code>1&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.service.type&lt;/code>&lt;/td>
&lt;td>&lt;code>ClusterIP&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.service.annotations&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.enabled&lt;/code>&lt;/td>
&lt;td>&lt;code>false&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.image&lt;/code>&lt;/td>
&lt;td>&lt;code>servicegraph&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.service.externalPort&lt;/code>&lt;/td>
&lt;td>&lt;code>8088&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.ingress.hosts&lt;/code>&lt;/td>
&lt;td>&lt;code>servicegraph.local&lt;/code>&lt;/td>
&lt;td>&lt;code>用来创建一条进入记录&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.nodeSelector&lt;/code>&lt;/td>
&lt;td>&lt;code>{}&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>servicegraph.prometheusAddr&lt;/code>&lt;/td>
&lt;td>&lt;code>http://prometheus:9090&lt;/code>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;!-- AUTO-GENERATED-END --></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2/helm-changes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2/helm-changes/</guid><category>kubernetes</category><category>helm</category><category>install</category><category>options</category></item><item><title>更新公告</title><description>
&lt;p>此页面描述了从 Istio 1.4.x 升级到 1.5.x 时需要注意的更改。在这里，我们详细介绍了有意不再向下兼容情况。还提到了保留向下兼容但引入了新行为的情况，熟悉 Istio 1.4 的使用和操作的人可能会感到惊讶。&lt;/p>
&lt;h2 id="control-plane-restructuring">重构控制平面&lt;/h2>
&lt;p>在 Istio 1.5 中，我们开始使用新的控制平面 deployment 模型，其中整合了许多组件。下面各功能迁移位置的说明。&lt;/p>
&lt;h3 id="istiod">Istiod&lt;/h3>
&lt;p>Istio 1.5，会有一个新的 deployment：&lt;code>istiod&lt;/code>。该组件是控制平面的核心，负责处理配置、证书分发以及 sidecar 注入等。&lt;/p>
&lt;h3 id="sidecar-injection">sidecar 注入&lt;/h3>
&lt;p>以前，sidecar 注入是通过一个可变的 webhook 处理的，该 webhook 由名为 &lt;code>istio-sidecar-injector&lt;/code> 的 deployment 处理。在 Istio 1.5 中，保留了相同的可变 webhook，但现在它指向 &lt;code>istiod&lt;/code> deployment，其它所有注入逻辑保持不变。&lt;/p>
&lt;h3 id="galley">Galley&lt;/h3>
&lt;ul>
&lt;li>配置验证。保持不变，但现在由 &lt;code>istiod&lt;/code> deployment 处理。&lt;/li>
&lt;li>MCP 服务器。默认情况下，MCP 服务器是禁用的。对于大多数用户，这是一个可实现细节。如果您依赖此功能，则需要运行 &lt;code>istio-galley&lt;/code> deployment。&lt;/li>
&lt;li>实验性功能（例如配置分析）。这些功能将需要 &lt;code>istio-galley&lt;/code> deployment。&lt;/li>
&lt;/ul>
&lt;h3 id="citadel">Citadel&lt;/h3>
&lt;p>以前，Citadel 有两个功能：将证书写入至每个命名空间中的 secret、在使用 SDS 时通过 gRPC 将 secret 提供给 &lt;code>nodeagent&lt;/code>。在 Istio 1.5 中，secret 不再写入至每个命名空间。而是仅通过 gRPC 提供服务。并且，此功能已迁移至 &lt;code>istiod&lt;/code> deployment。&lt;/p>
&lt;h3 id="sds-node-agent">SDS 节点代理&lt;/h3>
&lt;p>移除 &lt;code>nodeagent&lt;/code> deployment。现在，此功能存在于 Envoy sidecar 中。&lt;/p>
&lt;h3 id="sidecar">Sidecar&lt;/h3>
&lt;p>以前，sidecar 可以通过两种方式访问证书：通过作为文件挂载的 secret 或 SDS（通过 &lt;code>nodeagent&lt;/code>）。在 Istio 1.5 中，已对此进行了简化。所有 secret 信息将通过本地运行的 SDS 服务器提供。对于大多数用户而言，这些 secret 将从 &lt;code>istiod&lt;/code> deployment 中获取。对于具有自定义 CA 的用户，仍可以使用文件挂载的 secret，但是，本地 SDS 服务器仍将提供这些 secret。这意味着证书轮换不再需要重启 Envoy。&lt;/p>
&lt;h3 id="cni">CNI&lt;/h3>
&lt;p>&lt;code>istio-cni&lt;/code> deployment 没有变化。&lt;/p>
&lt;h3 id="pilot">Pilot&lt;/h3>
&lt;p>移除 &lt;code>istio-pilot&lt;/code> deployment，以便支持 &lt;code>istiod&lt;/code> deployment，&lt;code>istiod&lt;/code> 包含了 Pilot 曾经拥有的所有功能。为了向下兼容，保留了一些对 Pilot 的引用。&lt;/p>
&lt;h2 id="mixer-deprecation">弃用 Mixer&lt;/h2>
&lt;p>Mixer，即 &lt;code>istio-telemetry&lt;/code> 和 &lt;code>istio-policy&lt;/code> deployment 背后的过程，在 1.5 版本中被弃用了。Istio 1.3 开始，默认禁用了 &lt;code>istio-policy&lt;/code>，而 Istio 1.5 ，默认禁用了 &lt;code>istio-telemetry&lt;/code>。&lt;/p>
&lt;p>遥测现在是使用的不再需要 Mixer 的代理内扩展机制（Telemetry V2）收集的。&lt;/p>
&lt;p>如果您依赖 Mixer 的某些特有的特性，如进程外适配器，则可以手动重新启用 Mixer。在 Istio 1.7 之前，Mixer 将继续收到 bug 修复程序和安全修复程序。Mixer 支持的许多特性都能在&lt;a href="https://tinyurl.com/mixer-deprecation">弃用 Mixer&lt;/a> 文档中找到替代方法，包括基于 WebAssembly 沙箱 API 的&lt;a href="https://github.com/istio/proxy/tree/master/extensions">代理内扩展&lt;/a>。&lt;/p>
&lt;p>如果您需要 Mixer 没有的特性，我们建议您公开问题并在社区中进行讨论。&lt;/p>
&lt;p>查看&lt;a href="https://tinyurl.com/mixer-deprecation">弃用 Mixer&lt;/a> 获取详细信息。&lt;/p>
&lt;h3 id="feature-gaps-between-telemetry-v2-and-mixer-telemetry">Telemetry V2 和 Mixer Telemetry 的差异&lt;/h3>
&lt;ul>
&lt;li>不支持网格外遥测。如果流量源或目的地未注入 sidecar，则会缺少某些遥测数据。&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/istio/issues/19385">不支持&lt;/a> Egress gateway 遥测。&lt;/li>
&lt;li>仅支持基于 &lt;code>mtls&lt;/code> 的 TCP 遥测。&lt;/li>
&lt;li>不支持针对 TCP 和 HTTP 的黑洞遥测。&lt;/li>
&lt;li>直方图与 &lt;a href="https://github.com/istio/istio/issues/20483">Mixer Telemetry&lt;/a> 显著不同，且无法更改。&lt;/li>
&lt;/ul>
&lt;h2 id="authentication-policy">认证策略&lt;/h2>
&lt;p>Istio 1.5 引入了 &lt;a href="/v1.8/zh/docs/reference/config/security/peer_authentication/">&lt;code>PeerAuthentication&lt;/code>&lt;/a> 和 &lt;a href="/v1.8/zh/docs/reference/config/security/request_authentication">&lt;code>RequestAuthentication&lt;/code>&lt;/a> （它们取代了 Authentication API 的 Alpha 版本）。有关新 API 的更多信息，请参见 &lt;a href="/v1.8/zh/docs/tasks/security/authentication/authn-policy">authentication policy&lt;/a> 教程。&lt;/p>
&lt;ul>
&lt;li>&lt;p>升级 Istio 后，您 Alpha 版的身份验证策略将被保留并继续使用。您可以逐步将它们替换为等效的 &lt;code>PeerAuthentication&lt;/code> 和 &lt;code>RequestAuthentication&lt;/code>。新策略将根据定义的范围内接管旧策略。我们建议从 workload（最具体的范围）开始替换，然后是命名空间，最后是整个网格范围。&lt;/p>&lt;/li>
&lt;li>&lt;p>替换 workload、命名空间和整个网格的策略之后，您可以使用以下命令，安全地删除 alpha 版本的身份验证策略：&lt;/p>&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete policies.authentication.istio.io --all-namespaces --all
$ kubectl delete meshpolicies.authentication.istio.io --all
&lt;/code>&lt;/pre>
&lt;h2 id="Istio-workload-key-and-certificate-provisioning">Istio workload 密钥及证书配置&lt;/h2>
&lt;ul>
&lt;li>我们已经稳定了 SDS 证书和密钥配置流程。现在，Istio workload 使用 SDS 来提供证书。不建议再使用通过 secret 卷挂载的方法。&lt;/li>
&lt;li>请注意，启用双向 TLS 后，需要手动修改 Prometheus deployment 以监控 workload。详细信息在此 &lt;a href="https://github.com/istio/istio/issues/21843">issue&lt;/a> 中。该问题将在 1.5.1 中解决。&lt;/li>
&lt;/ul>
&lt;h2 id="control-plane-security">控制平面安全&lt;/h2>
&lt;p>作为 Istiod 努力的一部分，我们已经更改了代理与控制平面安全通信的方式。在以前的版本中，当配置了 &lt;code>values.global.controlPlaneSecurityEnabled=true&lt;/code> 设置时，代理将安全地连接到控制平面，这也是 Istio 1.4 的默认设置。每个控制平面组件都运行带有 Citadel 证书的 sidecar，并且代理通过端口 15011 连接到 Pilot。&lt;/p>
&lt;p>在 Istio 1.5 中，代理与控制平面连接的推荐或默认方式不再是这样；相反，可以使用由 Kubernetes 或 Istiod 签名的 DNS 证书，通过 15012 端口连接到 Istiod。&lt;/p>
&lt;p>注意：尽管如此，但在 Istio 1.5 中，将 &lt;code>controlPlaneSecurityEnabled&lt;/code> 设置为 &lt;code>false&lt;/code> 时，默认情况下控制平面之间的通信已经是安全的。&lt;/p>
&lt;h2 id="multicluster-setup">多集群安装&lt;/h2>
&lt;div>
&lt;aside class="callout warning">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-warning"/>&lt;/svg>
&lt;/div>
&lt;div class="content">&lt;p>如果您使用的是多集群，建议您不要升级到 Istio 1.5.0!&lt;/p>
&lt;p>多集群 Istio 1.5.0 目前存在几个已知问题，这些问题（&lt;a href="https://github.com/istio/istio/issues/21702">27102&lt;/a>, &lt;a href="https://github.com/istio/istio/issues/21676">21676&lt;/a>）使其在共享控制平面和控制平面副本集 deployment 中均无法使用。这些问题将在 Istio 1.5.1 中解决。&lt;/p>
&lt;/div>
&lt;/aside>
&lt;/div>
&lt;h2 id="helm-upgrade">Helm 升级&lt;/h2>
&lt;p>如果您使用 &lt;code>helm upgrade&lt;/code> 将群集更新到较新的 Istio 版本，则建议您使用 &lt;a href="/v1.8/zh/docs/setup/upgrade/istioctl-upgrade/">&lt;code>istioctl upgrade&lt;/code>&lt;/a> 或遵循 &lt;a href="/v1.8/zh/docs/setup/upgrade/cni-helm-upgrade/">helm template&lt;/a> 的步骤。&lt;/p></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.5.x/announcing-1.5/upgrade-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.5.x/announcing-1.5/upgrade-notes/</guid></item><item><title>升级说明</title><description>
&lt;p>此页面描述了当你从 Istio 1.3 升级到 1.4 时需要注意的一些变化。这里我们主要说明在哪我们有意的取消了向后兼容。
同时我们也会说明哪些向后兼容被保留后并可能会产生一些不同于 Istio 1.3 的奇怪行为。&lt;/p>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;h3 id="http-services-on-port-four-four-three">443 端口的 HTTP 服务&lt;/h3>
&lt;p>&lt;code>http&lt;/code>类型的服务将不再允许使用 443 端口，这个改动是为了保护协议不与外部的 HTTPS 服务所冲突。&lt;/p>
&lt;p>如果你依赖这个行为，那么有下面一些选项：&lt;/p>
&lt;ul>
&lt;li>把应用替换为其他端口。&lt;/li>
&lt;li>把协议类型从 &lt;code>http&lt;/code> 替换为 &lt;code>tcp&lt;/code>。&lt;/li>
&lt;li>给 Pilot deployment 指定环境变量 &lt;code>PILOT_BLOCK_HTTP_ON_443=false&lt;/code>。注意：这会在未来的发布中移除。&lt;/li>
&lt;/ul>
&lt;p>查看 &lt;a href="/v1.8/zh/docs/ops/configuration/traffic-management/protocol-selection/">Protocol Selection&lt;/a> 获取更多关于指定协议端口的信息。&lt;/p>
&lt;h3 id="regex-engine-changes">正则引擎变化&lt;/h3>
&lt;p>为了防止过大的正则表达式消耗过多的资源，Envoy 选择了一个新的正则表达式引擎 &lt;a href="https://github.com/google/re2">&lt;code>re2&lt;/code>&lt;/a> ，这之前用的是 &lt;code>std::regex&lt;/code>。这两个引擎有着很明显的语法差异，尤其是，现在的正则字段被限制在 100 bytes 以内。&lt;/p>
&lt;p>如果你依赖了旧正则表达式引擎的某个特定的行为，你可以通过给 Pilot deployment 指定环境变量 &lt;code>PILOT_ENABLE_UNSAFE_REGEX=true&lt;/code> 来避免这个变化。注意：这会在未来的发布中移除。&lt;/p>
&lt;h2 id="configuration-management">配置管理&lt;/h2>
&lt;p>我们已经在 Istio 资源 的 Kubernetes schema 中介绍过 OpenAPI V3 &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions">Custom Resource Definitions (CRD)&lt;/a>，此 schema 描述 Istio 资源并且确保你创建和修改的 Istio 资源能够结构化并且保持正确。&lt;/p>
&lt;p>如果配置的某个或者多个字段是 unknown 或者错误的类型，那么当你创建或者修改 Istio 资源的时候 Kubernetes API server 会拒绝。这个特性，&lt;code>CustomResourceValidation&lt;/code> 是 Kubernetes 1.9+ 版本的默认选项。需要注意的是如果某个之前已经存在的配置并且没有被修改过那么他们 &lt;strong>不会&lt;/strong> 受到影响。&lt;/p>
&lt;p>为了帮助你升级，这里有一些你可以参照的步骤：&lt;/p>
&lt;ul>
&lt;li>升级 Istio 之后，用 &lt;code>kubectl apply --dry-run&lt;/code> 来跑一遍你的 Istio 配置，这样你就可以知道这些配置对于 API server 来说是不是 unknown 或者无效的字段。（&lt;code>DryRun&lt;/code> 特性是 Kubernetes 1.13+ 版本开始的默认选项）&lt;/li>
&lt;li>查看 &lt;a href="/v1.8/zh/docs/reference/config/">reference documentation&lt;/a> 来确认修正字段名和数据类型。&lt;/li>
&lt;li>另外，为了能够结构化验证，你也可以使用 &lt;code>istioctl x analyze&lt;/code> 来帮助检查到你的 Istio 配置的潜在问题。参考 &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">here&lt;/a> 获取更多细节。&lt;/li>
&lt;/ul>
&lt;p>如果你想忽略验证错误，当你创建或者修改 Istio 资源的时候可以给 &lt;code>kubectl&lt;/code> 添加 &lt;code>--validate=false&lt;/code> 参数。由于这会导致错误的配置，我们非常不推荐这么做。&lt;/p></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes/</guid></item><item><title>升级说明</title><description>
&lt;p>此页面描述了从 Istio 1.2 升级到 1.3 时需要注意的更改。我们在这里详细介绍了有意破坏向后兼容性的情况。我们还提到了保留向后兼容性但引入新行为的情况，这对于熟悉 Istio 1.2 的使用和操作的人来说是令人惊讶的。&lt;/p>
&lt;h2 id="installation-and-upgrade">安装与升级&lt;/h2>
&lt;p>我们简化了 Mixer 的配置模型，并在 1.3 中完全删除了对特定适配器和特定模板的自定义资源定义（CRD）的支持。请转向新的配置模型。&lt;/p>
&lt;p>我们从系统中删除了 Mixer CRD，以简化配置模型，提高 Kubernetes 部署中 Mixer 的性能，并提高各种 Kubernetes 环境中的可靠性。&lt;/p>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;p>Istio 现在默认情况下会捕获所有端口。如果您没有指定容器端口来故意绕过 Envoy，则必须使用 &lt;code>traffic.sidecar.istio.io/excludeInboundPorts&lt;/code> 选项来选择退出端口捕获。&lt;/p>
&lt;p>现在默认情况下启用协议嗅探。当您想升级来获得以前的行为时请使用 &lt;code>--set pilot.enableProtocolSniffing=false&lt;/code> 选项来禁用协议嗅探。要了解更多信息，请参考我们的&lt;a href="/v1.8/zh/docs/ops/configuration/traffic-management/protocol-selection/">协议选择&lt;/a>。&lt;/p>
&lt;p>要想在多个命名空间指定一个主机名，您必须使用 &lt;a href="/v1.8/zh/docs/reference/config/networking/sidecar/">&lt;code>Sidecar&lt;/code> 资源&lt;/a>来选择单个主机。&lt;/p>
&lt;h2 id="trust-domain-validation">信任域名验证&lt;/h2>
&lt;p>信任域名验证是 Istio 1.3 中的新增功能。如果您只有一个信任域名，或者没有通过身份验证策略启用双向 TLS，则无需执行任何操作。&lt;/p>
&lt;p>要选择退出信任域名验证，请在升级到 Istio 1.3 之前在 Helm 模板中添加以下标志:
&lt;code>--set pilot.env.PILOT_SKIP_VALIDATE_TRUST_DOMAIN=true&lt;/code>&lt;/p>
&lt;h2 id="secret-discovery-service">Secret 发现服务&lt;/h2>
&lt;p>在 Istio 1.3 中，我们正在利用 Kubernetes 的改进来更安全地为工作负载实例颁发证书。&lt;/p>
&lt;p>Kubernetes 1.12 引入了 &lt;code>值得信赖的&lt;/code> JWTs 来解决这些问题。
&lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.13.md">Kubernetes 1.13&lt;/a> 引入了将 &lt;code>aud&lt;/code> 字段的值更改为 API server 以外的值的功能。&lt;code>aud&lt;/code> 字段代表了 Kubernetes 的 audience 。为了更好地保护网格，Istio 1.3 仅支持 &lt;code>值得信赖的&lt;/code> JWT，并且当您启用 SDS 后，要求 audience ，也就是 &lt;code>aud&lt;/code> 字段的值，为 &lt;code>istio-ca&lt;/code>。&lt;/p>
&lt;p>在启用 SDS 的情况下升级到 Istio 1.3 之前，请参阅我们的博客文章&lt;a href="/v1.8/zh/blog/2019/trustworthy-jwt-sds/">可信赖的 JWT 和 SDS&lt;/a>。&lt;/p></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3/upgrade-notes/</guid></item><item><title>升级说明</title><description>
&lt;p>本页描述了您在从 Istio 1.1.x 升级至 1.2.x 版本时的注意事项。这里我们详细描述了向后不兼容的情况。同时介绍那些向后兼容但引入了新行为的情况，这对于熟悉 Istio 1.1 使用和操作的人来说可能令人惊讶。&lt;/p>
&lt;h2 id="installation-and-upgrade">安装与升级&lt;/h2>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">Mixer 的配置模型得以简化。面向适配器、面向模板的定制资源支持在 1.2 中默认被删除，并会在 1.3 中完全删除。请迁移到新的配置模型。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>为简化配置模型、提高 Mixer 与 Kubernetes 一起使用时的性能以及在各种 Kubernetes 环境中的可靠性，大部分 Mixer CRD 被删除。&lt;/p>
&lt;p>以下 CRD 保留：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>定制资源定义名称&lt;/th>
&lt;th>目的&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>adapter&lt;/code>&lt;/td>
&lt;td>Istio 扩展声明规范&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>attributemanifest&lt;/code>&lt;/td>
&lt;td>Istio 扩展声明规范&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>template&lt;/code>&lt;/td>
&lt;td>Istio 扩展声明规范&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>handler&lt;/code>&lt;/td>
&lt;td>Istio 扩展声明规范&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>rule&lt;/code>&lt;/td>
&lt;td>Istio 扩展声明规范&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>instance&lt;/code>&lt;/td>
&lt;td>Istio 扩展声明规范&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>如果您在使用已被删除的 Mixer 配置模式，在升级 Helm chart 时需设置以下 Helm 标志:
&lt;code>--set mixer.templates.useTemplateCRDs=true --set mixer.adapters.useAdapterCRDs=true&lt;/code>&lt;/p></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2/upgrade-notes/</guid></item><item><title>升级说明</title><description>
&lt;p>本页描述了从 Istio 1.0 升级到 1.1 时需要注意的变化。在这里我们详细介绍了一些故意破坏向后兼容性的情况。我们还提到保留向后兼容性的情况，但是引入了一些新的行为，这对于熟悉 Istio 1.0 的使用者和操作人员来说很吃惊。&lt;/p>
&lt;p>有关 Istio 1.1 引入的新特性的概述，请参阅 &lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/change-notes/">1.1 更改说明&lt;/a>。&lt;/p>
&lt;h2 id="installation">安装&lt;/h2>
&lt;ul>
&lt;li>&lt;p>我们增加了控制平面和 envoy sidecar 所需的 CPU 和 内存。在进行更新之前，确保集群具有足够的资源至关重要。&lt;/p>&lt;/li>
&lt;li>&lt;p>Istio 的 CRD 已放置在它们自己的 Helm 图表 &lt;code>istio-init&lt;/code> 中。这样可以防止丢失自定义资源数据，简化升级过程，并在基于 Helm 的安装之外推动 Istio 的发展。
&lt;a href="/v1.8/zh/docs/setup/upgrade/">升级文档&lt;/a>提供了从 Istio 1.0.6 升级到 Istio 1.1 的正确步骤。当升级时，请仔细遵循这些说明。当使用 &lt;code>template&lt;/code> 或者 &lt;code>tiller&lt;/code> 安装模式来安装 &lt;code>istio-init&lt;/code>和 Istio 图表时，如果需要 &lt;code>certmanager&lt;/code>，请使用 &lt;code>--set certmanager=true&lt;/code> 标志。&lt;/p>&lt;/li>
&lt;li>&lt;p>许多安装选项已被添加、删除或者更改。请参阅&lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/helm-changes/">安装选项更改&lt;/a>来获得详细的更改概要。&lt;/p>&lt;/li>
&lt;li>&lt;p>用于&lt;a href="/v1.8/zh/docs/setup/install/multicluster/shared-vpn/">多集群 VPN&lt;/a> 的 1.0 &lt;code>istio-remote&lt;/code> 图表和&lt;a href="/v1.8/zh/docs/setup/install/multicluster/shared-gateways/">多集群共享网关&lt;/a>的远程集群安装已经被合并到 Istio 图表中。为了生成等价的 &lt;code>istio-remote&lt;/code> 图表，请使用 &lt;code>--set global.istioRemote=true&lt;/code> 标志。&lt;/p>&lt;/li>
&lt;li>&lt;p>插件不再通过单独的负载均衡器暴露。现在可以通过选择 Ingress 网关暴露插件。当通过 Ingress 网关暴露插件时，请遵循&lt;a href="/v1.8/zh/docs/tasks/observability/gateways/">远程访问遥测插件&lt;/a>指南进行操作。&lt;/p>&lt;/li>
&lt;li>&lt;p>内置的 Istio Statsd 收集器已经被删除。Istio 保留了与您自己的 Statsd 收集器集成的功能，可以使用 &lt;code>--set global.envoyStatsd.enabled=true&lt;/code> 标志。&lt;/p>&lt;/li>
&lt;li>&lt;p>用于配置 Kubernetes 入口的一系列 &lt;code>ingress&lt;/code> 选项已经被删除。使用 &lt;code>--set global.k8sIngress.enabled=true&lt;/code> 标志依然可以开启并使用 Kubernetes Ingress。请参阅&lt;a href="/v1.8/zh/docs/ops/integrations/certmanager/">使用 Cert-Manager 确保 Kubernetes Ingress 安全&lt;/a>的文档了解如何保护 Kubernetes 入口资源。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;ul>
&lt;li>&lt;p>现在出站流量的默认策略为 &lt;code>ALLOW_ANY&lt;/code>。到达未知端口的流量将按原样转发。到达已知端口（例如 80 端口）的流量将与系统中的一个服务匹配并进行相应的转发。&lt;/p>&lt;/li>
&lt;li>&lt;p>将 sidecar 路由到服务期间，与 sidecar 相同命名空间中的目标服务的 destination rule 将优先使用，随后是服务命名空间的 destination rule，最后是在其他命名空间的 destination rule（如果适用）。&lt;/p>&lt;/li>
&lt;li>&lt;p>我们建议将网关资源存储在与网关工作负载相同的命名空间中（例如在 &lt;code>istio-ingressgateway&lt;/code> 情况下使用 &lt;code>istio-system&lt;/code> 命名空间）。
当在虚拟服务中提到网关资源时，使用命名空间/名称格式而不要使用 &lt;code>name.namespace.svc.cluster.local&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>现在默认情况下禁用可选的出口网关。在 demo 配置文件中启用它，以供用户浏览，但默认情况下在所有的其他配置文件中已禁用。
如果您需要通过出口网关控制和保护出站流量，则需要在任何非演示配置文件中，手动启用 &lt;code>gateways.istio-egressgateway.enabled=true&lt;/code>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="policy-telemetry">策略和遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;p>现在默认禁用 &lt;code>istio-policy&lt;/code> 检查。demo 配置文件中启用它，供用户评测，但在所有的其他配置文件已禁用该检查。这个改变仅针对 &lt;code>istio-policy&lt;/code> 而不针对 &lt;code>istio-telemetry&lt;/code>。若想重新启用该策略检查，请运行 &lt;code>helm template&lt;/code> 并附带 &lt;code>--set global.disablePolicyChecks=false&lt;/code> 参数，重新应用配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>Service Graph 组件已被弃用，推荐使用 &lt;a href="https://www.kiali.io/">Kiali&lt;/a>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>RBAC 配置已被修改来实现集群作用域。&lt;code>RbacConfig&lt;/code> 资源已经被替换成 &lt;code>ClusterRbacConfig&lt;/code> 资源。请参阅&lt;a href="https://archive.istio.io/v1.1/docs/setup/kubernetes/upgrade/steps/#migrating-from-rbacconfig-to-clusterrbacconfig">将 &lt;code>RbacConfig&lt;/code> 迁移到 &lt;code>ClusterRbacConfig&lt;/code>&lt;/a> 的文档获得更多的迁移说明。&lt;/li>
&lt;/ul></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes/</guid></item><item><title>变更说明</title><description>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong> 通过避免不必要的完全推送 &lt;a href="https://github.com/istio/istio/pull/18164">#19305&lt;/a>，提高 &lt;code>ServiceEntry&lt;/code> 性能。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> Envoy sidecar 就绪状态探测，可以更加准确地确定就绪状态 &lt;a href="https://github.com/istio/istio/pull/18164">#18164&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 在可能的情况下，通过 xDS 发送部分更新，以增强 Envoy 代理配置更新性能 &lt;a href="https://github.com/istio/istio/pull/18354">#18354&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 可通过目标规则为每个目标服务配置本地负载均衡设置 &lt;a href="https://github.com/istio/istio/pull/18406">#18406&lt;/a>。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> Pod 崩溃会触发过多 Envoy 代理配置推送的问题 &lt;a href="https://github.com/istio/istio/pull/18574">#18574&lt;/a>。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 应用程序（如 headless 服务）无需通过 Envoy 代理即可直接调用自己的问题 &lt;a href="https://github.com/istio/istio/pull/19308">#19308&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 当使用 Istio CNI 时，支持 &lt;code>iptables&lt;/code> 故障检测 &lt;a href="https://github.com/istio/istio/pull/19534">#19534&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 在目标规则中添加 &lt;code>consecutiveGatewayErrors&lt;/code> 和 &lt;code>consecutive5xxErrors&lt;/code> 作为异常检测选项 &lt;a href="https://github.com/istio/istio/pull/19771">#19771&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;code>EnvoyFilter&lt;/code> 的匹配性能 &lt;a href="https://github.com/istio/istio/pull/19786">#19786&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;code>HTTP_PROXY&lt;/code> 协议支持 &lt;a href="https://github.com/istio/istio/pull/19919">#19919&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;code>iptables&lt;/code> 默认设置使用 &lt;code>iptables-restore&lt;/code>&lt;a href="https://github.com/istio/istio/pull/18847">#18847&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 通过过滤未使用的集群，提高网关性能。默认情况下禁用该设置 &lt;a href="https://github.com/istio/istio/pull/20124">#20124&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>毕业&lt;/strong> SDS 稳定，并默认启用。它为 Istio Envoy 代理提供身份配置。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> Beta 身份认证 API。新的 API 将对等体（即双向 TLS）和源（JWT）身份验证分别分离到 &lt;a href="https://github.com/istio/api/blob/master/security/v1beta1/peer_authentication.proto">&lt;code>PeerAuthentication&lt;/code>&lt;/a> 和 &lt;a href="https://github.com/istio/api/blob/master/security/v1beta1/request_authentication.proto">&lt;code>RequestAuthentication&lt;/code>&lt;/a> 中。
两个新 API 都是面向工作负载的，在 alpha 版本的 &lt;code>AuthenticationPolicy&lt;/code> 中它们是面向服务的。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 在授权策略中添加&lt;a href="https://github.com/istio/api/blob/master/security/v1beta1/authorization.proto#L28">拒绝语义&lt;/a>。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/tasks/security/authentication/authn-policy/#auto-mutual-TLS">自动双向 TLS&lt;/a> 从 alpha 转到 beta。该特性现在默认启用。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 通过将 Node Agent 与 Pilot Agent 作为 Istio Agent 合并，并删除跨 Pod UDS，从而提高了 &lt;a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret">SDS 安全性&lt;/a> ，不再需要用户为 UDS 连接部署 Kubernetes Pod 安全策略。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 通过在 istiod 中包含证书来改进 Istio。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/authentication/#service-account-tokens">&lt;code>first-party-jwt&lt;/code>&lt;/a> 在 &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">&lt;code>third-party-jwt&lt;/code>&lt;/a> 不支持的集群中添加了支持 Kubernetes 作为 CSR 身份验证的后备令牌。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 支持 Istio CA 和 Kubernetes CA 为控制平面提供证书，可以通过 &lt;code>values.global.pilotCertProvider&lt;/code> 进行配置。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> Istio Agent 为 Prometheus 设置了密钥和证书。&lt;/li>
&lt;/ul>
&lt;h2 id="telemetry">遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增&lt;/strong> 对 v2 版本遥测的 TCP 协议支持。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 在指标、日志中添加 gRPC 响应状态码。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 支持 Istio Canonical Service。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> v2 遥测管道的稳定性。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 对 v2 遥测中可配置性的 alpha 级支持。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 对在 Envoy 节点元数据中填充 AWS 平台元数据的支持。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 用于 Mixer 的 Stackdriver 适配器，以通过可配置的刷新间隔跟踪数据。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 在 Jaeger 插件中增加了对 headless 收集器服务的支持。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> &lt;code>kubernetesenv&lt;/code> 适配器可为名字中包含点的 Pod 提供适当支持。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 用于 Mixer 的 Fluentd 适配器，以在导出的时间戳中提供毫秒级支持。&lt;/li>
&lt;/ul>
&lt;h2 id="configuration-management">配置管理&lt;/h2>
&lt;h2 id="operator">Operator&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>替换&lt;/strong> 将 Alpha &lt;code>IstioControlPlane&lt;/code> API 替换为新的 &lt;a href="/v1.8/zh/docs/reference/config/istio.operator.v1alpha1/">&lt;code>IstioOperator&lt;/code>&lt;/a> API，以便与现有的 &lt;code>MeshConfig&lt;/code> API 保持一致。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;code>istioctl operator init&lt;/code> 和 &lt;code>istioctl operator remove&lt;/code> 命令。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> 使用缓存 &lt;a href="https://github.com/istio/operator/pull/667">&lt;code>operator#667&lt;/code>&lt;/a> 提高协调速度。&lt;/li>
&lt;/ul>
&lt;h2 id="istioctl">&lt;code>istioctl&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>Istioctl Analyze&lt;/code>&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 各种分析器：双向 TLS、JWT、&lt;code>ServiceAssociation&lt;/code>、Secret、sidecar 镜像、端口名称和不建议使用的分析器。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong> 支持更多针对 &lt;code>RequestAuthentication&lt;/code> 的验证规则。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 添加新参数 &lt;code>-A|--all-namespaces&lt;/code> 以分析整个集群。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 对标准输入流传递的内容进行分析的支持。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze -L&lt;/code>&lt;/a> 打印全部分析变量。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> 功能抑制来自 &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 的消息。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 添加结构化格式选项。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 输出中添加指向相关内容的链接。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong> Istio API 在 &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>Istioctl Analyze&lt;/code>&lt;/a> 中提供的更新注释方法。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 现在可从目录加载文件。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 以尝试将消息与其源文件名关联。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 打印正在分析的命名空间。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 默认情况下分析群集内资源。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 抑制群集级资源消息的错误。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;code>istioctl manifest&lt;/code> 对多个输入文件的支持。&lt;/li>
&lt;li>&lt;strong>替换&lt;/strong> 使用 &lt;code>IstioOperator&lt;/code> API 替换 &lt;code>IstioControlPlane&lt;/code> API。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-dashboard">&lt;code>istioctl dashboard&lt;/code>&lt;/a> 选择器。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-manifest">&lt;code>istioctl manifest --set&lt;/code>&lt;/a> 支持切片和列表。&lt;/li>
&lt;li>&lt;strong>新增&lt;/strong> &lt;code>docker/istioctl&lt;/code> Docker 镜像（#19079）。&lt;/li>
&lt;/ul></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.5.x/announcing-1.5/change-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.5.x/announcing-1.5/change-notes/</guid></item><item><title>变更说明</title><description>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增了&lt;/strong> 对 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/mirroring/">mirroring&lt;/a> 百分比的流量支持。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> &lt;code>Envoy sidecar&lt;/code>。当 &lt;code>Envoy sidecar&lt;/code> 崩溃退出时，可以更轻松地查看 &lt;code>Envoy sidecar&lt;/code> 的状态。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> &lt;code>Pilot&lt;/code> 的功能，当无需修改时，即可跳过向 &lt;code>Envoy&lt;/code> 发送冗余配置的操作。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> &lt;code>headless&lt;/code> 服务，以避免与同一端口上的不同服务发生冲突。&lt;/li>
&lt;li>&lt;strong>禁用了&lt;/strong> 默认的 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/circuit-breaking/">circuit breakers&lt;/a>。&lt;/li>
&lt;li>&lt;strong>更新了&lt;/strong> 正则表达式引擎为 &lt;code>re2&lt;/code>。有关详细信息，请参阅&lt;a href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes">升级说明&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增了&lt;/strong> &lt;a href="/v1.8/zh/blog/2019/v1beta1-authorization-policy/">&lt;code>v1beta1&lt;/code> authorization policy model&lt;/a> 用于执行访问控制。最终将取代 &lt;a href="/v1.8/zh/docs/reference/config/security/istio.rbac.v1alpha1/">&lt;code>v1alpha1&lt;/code> RBAC policy&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> &lt;a href="/v1.8/zh/docs/tasks/security/authentication/auto-mtls/">automatic mutual TLS&lt;/a> 的实验性支持，以启用 &lt;code>mutual TLS&lt;/code>，而无需配置目标规则。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 对 &lt;a href="/v1.8/zh/docs/tasks/security/authorization/authz-td-migration/">authorization policy trust domain migration&lt;/a> 的实验性支持。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 实验性的 &lt;a href="/v1.8/zh/blog/2019/dns-cert/">DNS certificate management&lt;/a> 以安全地配置和管理 &lt;code>Kubernetes CA&lt;/code> 签名的 &lt;code>DNS&lt;/code> 证书。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> &lt;code>Citadel&lt;/code> ，以在自签名 &lt;code>CA&lt;/code> 模式下运行时定期检查和更换过期的根证书。&lt;/li>
&lt;li>&lt;strong>更新了&lt;/strong> JWT 身份验证，将&lt;a href="https://github.com/istio/istio/issues/13565">以空格分隔的声明&lt;/a>视为声明列表。&lt;/li>
&lt;/ul>
&lt;h2 id="telemetry">遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增了&lt;/strong> 在 &lt;a href="https://github.com/istio/proxy/blob/release-1.8/extensions/stackdriver/README.md">Stackdriver&lt;/a> 中的实验性的代理遥测报告。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> 对 &lt;code>HTTP&lt;/code> 服务指标监控的&lt;a href="/v1.8/zh/docs/ops/configuration/telemetry/in-proxy-service-telemetry/">代理&lt;/a> &lt;code>Prometheus&lt;/code> ，(从实验到 &lt;code>alpha&lt;/code>)。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> 遥测收集功能，用于&lt;a href="/v1.8/zh/blog/2019/monitoring-external-service-traffic/">阻止和传递外部流量&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 为 &lt;code>Envoy&lt;/code> &lt;a href="/v1.8/zh/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig">静态模式&lt;/a>配置的选项。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> &lt;code>inbound&lt;/code> 和 &lt;code>outbound&lt;/code> 对 &lt;code>Envoy HTTP stats&lt;/code> 特定通信方向的描述。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> 对通过出口网关流量的遥测报告。&lt;/li>
&lt;/ul>
&lt;h2 id="configuration-management">配置管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增了&lt;/strong> 多个验证和检查在 &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">&lt;code>istioctl analyze&lt;/code>&lt;/a> 子命令中。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 实验性选项，以启用 &lt;code>Istio&lt;/code> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/#enabling-validation-messages-for-resource-status">resource statuses&lt;/a> 的验证消息。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 对自定义资源 (&lt;code>CRDs&lt;/code>) 的 &lt;code>OpenAPI v3&lt;/code> 模式验证，有关详细信息，请参阅&lt;a href="/v1.8/zh/news/releases/1.4.x/announcing-1.4/upgrade-notes">升级说明&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> &lt;a href="https://github.com/istio/client-go">client-go&lt;/a> 存储库来访问 &lt;code>Istio APIs&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="installation">安装&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增了&lt;/strong> 对 &lt;code>Istio&lt;/code> 动态安装更新的实验性 &lt;a href="/v1.8/zh/docs/setup/install/standalone-operator/">operator controller&lt;/a>。&lt;/li>
&lt;li>&lt;strong>移除了&lt;/strong> &lt;code>proxy_init&lt;/code> 镜像，&lt;code>istio-init&lt;/code> 容器重新使用 &lt;code>proxyv2&lt;/code> 镜像。&lt;/li>
&lt;li>&lt;strong>更新了&lt;/strong> 基础镜像为 &lt;code>ubuntu:bionic&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="istioctl">&lt;code>istioctl&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>新增了&lt;/strong> 子命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-proxy-config-log">&lt;code>istioctl proxy-config logs&lt;/code>&lt;/a>，检索和更新 &lt;code>Envoy&lt;/code> 日志记录级别。&lt;/li>
&lt;li>&lt;strong>更新了&lt;/strong> 子命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-authn-tls-check">&lt;code>istioctl authn tls-check&lt;/code>&lt;/a>，以显示正在使用的策略。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 实验性子命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-wait">&lt;code>istioctl experimental wait&lt;/code>&lt;/a>，以使 &lt;code>Istio&lt;/code> 等待，直到它已将配置推送到所有的 &lt;code>Envoy sidecars&lt;/code>。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 实验性子命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-multicluster">&lt;code>istioctl experimental multicluster&lt;/code>&lt;/a>，以帮助跨集群管理 &lt;code>Istio&lt;/code>。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 实验性子命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-post-install-webhook">&lt;code>istioctl experimental post-install webhook&lt;/code>&lt;/a> 去&lt;a href="/v1.8/zh/blog/2019/webhook/">安全配管 webhook&lt;/a>。&lt;/li>
&lt;li>&lt;strong>新增了&lt;/strong> 实验性子命令 &lt;a href="/v1.8/zh/docs/setup/upgrade/istioctl-upgrade/">&lt;code>istioctl experimental upgrade&lt;/code>&lt;/a> 去执行 &lt;code>Istio&lt;/code> 的升级。&lt;/li>
&lt;li>&lt;strong>改进了&lt;/strong> 子命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-version">&lt;code>istioctl version&lt;/code>&lt;/a>，它现在显示的是 &lt;code>Envoy proxy&lt;/code> 的版本。&lt;/li>
&lt;/ul></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.4.x/announcing-1.4/change-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.4.x/announcing-1.4/change-notes/</guid></item><item><title>变更说明</title><description>
&lt;h2 id="installation">安装&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong> 实验性的&lt;a href="/v1.8/zh/docs/setup/install/istioctl/">清单和配置文件命令&lt;/a>，用于安装和管理 Istio 控制平面，以便进行评估。&lt;/li>
&lt;/ul>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong>。当未根据 Istio 的&lt;a href="/v1.8/zh/docs/ops/deployment/requirements/">约定&lt;/a>命名端口时，添加了对 HTTP、TCP 出站流量&lt;a href="/v1.8/zh/docs/ops/configuration/traffic-management/protocol-selection/">自动检测协议&lt;/a>的功能。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。为实现双向 TLS 操作，添加了一个模型至 Gateway API。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong>。修复了当服务第一次使用宽容双向 TLS 模式，与 MySQL 和 MongoDB 之类的协议进行网络通信时会出现的问题。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 Envoy 代理的就绪检查。现在会检查 Envoy 的就绪状态。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。pod spec 中不再需要的容器端口，所有端口均为&lt;a href="/v1.8/zh/faq/traffic-management/#controlling-inbound-ports">默认捕获&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 &lt;code>EnvoyFilter&lt;/code> API。您现在可以添加或更新所有配置。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。使用 Redis 代理时，改进了 Redis 负载均衡，现在默认为 &lt;a href="https://www.envoyproxy.io/docs/envoy/v1.6.0/intro/arch_overview/load_balancing#maglev">&lt;code>MAGLEV&lt;/code>&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了负载均衡，默认会直接将流量导向&lt;a href="/v1.8/zh/faq/traffic-management/#controlling-inbound-ports">相同的地区和区域&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 Pilot 的 CPU 利用率。在特殊部署场景，减少幅度接近 90%。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 &lt;code>ServiceEntry&lt;/code> API，允许在不同命名空间中使用相同的主机名。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。针对自定义 &lt;code>OutboundTrafficPolicy&lt;/code> 策略，改进了 &lt;a href="/v1.8/zh/docs/reference/config/networking/sidecar/#OutboundTrafficPolicy">Sidecar API&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong>。为使用双向 TLS 的服务添加了信任域验证。默认情况下，服务器仅对来自同一信任域的请求进行身份验证。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了一些&lt;a href="/v1.8/zh/docs/ops/configuration/mesh/secret-creation/">标签&lt;/a>，其用于按命名空间控制服务帐户密码的生成。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 SDS 支持，以实现向每个 Istio 控制平面服务传递私钥和证书。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。为 Citadel 添加了对&lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/controlz/">自检&lt;/a>支持。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。为 15014 端口的 Citadel Agent 的 &lt;code>/metrics&lt;/code> endpoint 添加了指标，用于监控 SDS 服务。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。使用 8080 端口上的 &lt;code>/debug/sds/workload&lt;/code> 和 &lt;code>/debug/sds/gateway&lt;/code> 向 Citadel Agent 添加了诊断程序。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 ingress gateway，以实现使用 SDS 时&lt;a href="/v1.8/zh/docs/tasks/traffic-management/ingress/secure-ingress-sds/#configure-a-mutual-TLS-ingress-gateway">从另一个 secret 加载受信任的 CA 证书&lt;/a>。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。通过强制使用 &lt;a href="/v1.8/zh/blog/2019/trustworthy-jwt-sds">Kubernetes Trustworthy JWT&lt;/a> 改进了 SDS 的安全性。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。通过统一日志记录模式，改进了 Citadel Agent 日志记录。&lt;/li>
&lt;li>&lt;strong>移除&lt;/strong>。移除对 &lt;a href="/v1.8/zh/blog/2019/trustworthy-jwt-sds">Kubernetes 1.13 之前版本&lt;/a>的 Istio SDS 支持。&lt;/li>
&lt;li>&lt;strong>移除&lt;/strong>。暂时移除与 Vault CA 的集成。SDS 的一些要求导致了本次临时移除，但我们将在之后的版本中重新引入 Vault CA 集成。&lt;/li>
&lt;li>&lt;strong>启用&lt;/strong>。默认情况下启用 Envoy JWT 过滤器以提高安全性和可靠性。&lt;/li>
&lt;/ul>
&lt;h2 id="telemetry">遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong>。为 Envoy gRPC 添加了访问日志服务 &lt;a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/service/accesslog/v2/als.proto#grpc-access-log-service-als">ALS&lt;/a> 的支持。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。为 Citadel 监控添加了一个 Grafana 仪表盘。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。为 sidecar 注入 webhook 监控添加了&lt;a href="/v1.8/zh/docs/reference/commands/sidecar-injector/#metrics">指标&lt;/a>。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了控制平面指标，用于监控 Istio 的配置状态。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了流向目标是 &lt;code>Passthrough&lt;/code> 和 &lt;code>BlackHole&lt;/code> 集群的流量的遥测报告。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了对使用 Prometheus 代理生成服务指标的 alpha 支持。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。在 Envoy 节点 metadata 中添加了对环境 metadata 的 alpha 支持。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了对代理 Metadata 交换的 alpha 支持。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了对 OpenCensus 追踪驱动的 alpha 支持。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。通过移除添加服务条目的要求，改进了对外部服务的报告。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了网格仪表板，以提供对 Istio 配置状态的监控。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 Pilot 仪表板，以显示更多的关键指标，并能更清楚地识别错误。&lt;/li>
&lt;li>&lt;strong>移除&lt;/strong>。移除了不推荐使用的 &lt;code>Adapter&lt;/code> 和 &lt;code>Template&lt;/code> 自定义资源（CRD）。&lt;/li>
&lt;li>&lt;strong>弃用&lt;/strong>。弃用可用于产生 API 属性的 HTTP API 规范。我们将在 Istio 1.4 中移除对生成 API 属性的支持。&lt;/li>
&lt;/ul>
&lt;h2 id="policy">策略&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong>。改进了速率限制的实现，当配额后端不可用时，仍允许通信。&lt;/li>
&lt;/ul>
&lt;h2 id="configuration-management">配置管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong>。修复了阻止过多 gRPC ping 关闭连接的情况。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 Galley，以避免控制平面升级失败。&lt;/li>
&lt;/ul>
&lt;h2 id="istioctl">&lt;code>istioctl&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-manifest">&lt;code>istioctl&lt;/code> 实验清单&lt;/a>来管理新的实验安装清单。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-profile">&lt;code>istioctl&lt;/code> 实验配置文件&lt;/a>来管理新的实验安装配置文件。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-metrics">&lt;code>istioctl experimental metrics&lt;/code>&lt;/a>&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-describe-pod">&lt;code>istioctl experimental describe pod&lt;/code>&lt;/a>，其用于描述 Istio pod 的配置。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-add-to-mesh">&lt;code>istioctl experimental add-to-mesh&lt;/code>&lt;/a>，其用于将 Kubernetes 服务或虚拟机添加到现有 Istio 服务网格中。&lt;/li>
&lt;li>&lt;strong>添加&lt;/strong>。添加了 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-remove-from-mesh">&lt;code>istioctl experimental remove-from-mesh&lt;/code>&lt;/a>，其用于从已存在的 Istio 服务网格中移除 Kubernetes 服务或虚拟机。&lt;/li>
&lt;li>&lt;strong>提升&lt;/strong>。将命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-convert-ingress">&lt;code>istioctl experimental convert-ingress&lt;/code>&lt;/a> 提升为 &lt;code>istioctl convert-ingress&lt;/code>。&lt;/li>
&lt;li>&lt;strong>提升&lt;/strong>。将命令 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-dashboard">&lt;code>istioctl experimental dashboard&lt;/code>&lt;/a> 提升为 &lt;code>istioctl dashboard&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="miscellaneous">杂项&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>添加&lt;/strong>。添加了基于 &lt;a href="/v1.8/zh/docs/ops/configuration/security/harden-docker-images/">distroless&lt;/a> 基础镜像的新镜像。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 Istio CNI Helm 图表，使其具有与 Istio 一致的版本。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong>。改进了 Kubernetes Job 的行为。当 Job 手动调用 &lt;code>/quitquitquit&lt;/code> endpoint 时，Kubernetes Job 现在可以正常退出。&lt;/li>
&lt;/ul></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.3.x/announcing-1.3/change-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.3.x/announcing-1.3/change-notes/</guid></item><item><title>变更说明</title><description>
&lt;h2 id="general">通用功能&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>traffic.sidecar.istio.io/includeInboundPorts&lt;/code> 标注可以让服务所有者不需要在 deployment yaml 文件中配置 &lt;code>containerPort&lt;/code> 字段。这会是未来版本中的默认做法。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 对 Kubernetes 集群的 IPv6 试验性支持。&lt;/li>
&lt;/ul>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong> 在多集群环境中&lt;a href="/v1.8/zh/docs/ops/configuration/traffic-management/locality-load-balancing/">基于位置的路由&lt;/a>功能。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;a href="/v1.8/zh/docs/reference/config/installation-options/#global-options">&lt;code>ALLOW_ANY&lt;/code> 模式&lt;/a>出站流量策略。在一个已存在端口上的未知 HTTP/HTTPS 主机流量将会被&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-control/#envoy-passthrough-to-external-services">按原样转发&lt;/a>。未知流量会被记录在 Envoy 的访问日志中。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 支持为上游服务设置 HTTP 空闲超时时间。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> Sidecar 支持 &lt;a href="/v1.8/zh/docs/reference/config/networking/sidecar/#CaptureMode">NONE 模式&lt;/a> （不用 iptables）。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 给 Envoy sidecar 配置 &lt;a href="/v1.8/zh/docs/reference/config/installation-options/#global-options">DNS 刷新频率&lt;/a>的能力。减轻 DNS 服务的压力。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/reference/config/networking/sidecar/">Sidecar API&lt;/a> 从 Alpha 版本发展到 Alpha API 和 Beta 运行时。&lt;/li>
&lt;/ul>
&lt;h2 id="security">安全&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong> 将自签名 Citadel 根证书的默认生存期延长到 10 年。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 通过 &lt;a href="/v1.8/zh/docs/ops/configuration/mesh/app-health-check/#use-annotations-on-pod">标注&lt;/a> &lt;code>PodSpec&lt;/code> 中&lt;code>sidecar.istio.io/rewriteAppHTTPProbers: &amp;quot;true&amp;quot;&lt;/code> 字段，Kubernetes 的健康检查探测器会重写每个 deployment。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 支持给 Istio 双向 TLS 证书配置密钥路径。更多信息请看&lt;a href="https://github.com/istio/istio/issues/11984">这里&lt;/a>。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 通过启用 Citadel 上的 &lt;code>pkcs8-keys&lt;/code> 来支持 workload 使用 &lt;a href="https://en.wikipedia.org/wiki/PKCS_8">PKCS 8&lt;/a> 私钥。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> JWT 公钥获取逻辑在网络失败的时候更可靠。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> workload 证书中的 &lt;a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.6">SAN&lt;/a> 字段设置为 &lt;code>critical&lt;/code>。这是修复了一些自定义证书验证服务无法验证 Istio 证书的问题。&lt;/li>
&lt;li>&lt;strong>修复&lt;/strong> 重写了 HTTPS 的双向 TLS 探测。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/reference/config/networking/gateway/">入口网关多证书支持的 SNI&lt;/a> 从 Alpha 版本发展到了稳定版。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/tasks/traffic-management/ingress/secure-ingress-sds/">入口网关证书管理&lt;/a>从 Alpha 版本发展到了 Beta 版。&lt;/li>
&lt;/ul>
&lt;h2 id="telemetry">遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>增加&lt;/strong> 通过用户标注统计字段前缀、后缀和正则表达式的方式，全面支持对 Envoy 统计生成的控制。&lt;/li>
&lt;li>&lt;strong>修改&lt;/strong> Prometheus 产生的流量排除在统计度量之外。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 支持发送追踪信息到 Datadog。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/tasks/observability/distributed-tracing/">分布式追踪&lt;/a>从 Beta 版本发展到了稳定版。&lt;/li>
&lt;/ul>
&lt;h2 id="policy">策略&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>修复&lt;/strong> &lt;a href="https://github.com/istio/istio/issues/13868">基于 Mixer&lt;/a> 的 TCP 策略执行。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;a href="/v1.8/zh/docs/reference/config/security/istio.rbac.v1alpha1/">认证 (RBAC)&lt;/a> 从 Alpha 版本发展到 Alpha API 和 Beta 运行时。&lt;/li>
&lt;/ul>
&lt;h2 id="configuration-management">配置管理&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>改进&lt;/strong> 对策略和 CRD 遥测的验证。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> 基本资源配置验证从 Alpha 版本发展到了 Beta 版。&lt;/li>
&lt;/ul>
&lt;h2 id="installation-and-upgrade">安装和升级&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>更新&lt;/strong> 默认代理内存大小限制 (&lt;code>global.proxy.resources.limits.memory&lt;/code>) 从 &lt;code>128Mi&lt;/code> 扩大到 &lt;code>1024Mi&lt;/code>，以此保证代理有充足的内存。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> pod 的&lt;a href="https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity">反亲和性&lt;/a>和&lt;a href="https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/">容错&lt;/a>功能支持了所有的控制平面组件。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>sidecarInjectorWebhook.neverInjectSelector&lt;/code> 和 &lt;code>sidecarInjectorWebhook.alwaysInjectSelector&lt;/code> 配置，通过标签选择器让用户可以进一步控制 workload 是否应该自动注入 sidecar。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>global.logging.level&lt;/code> 和 &lt;code>global.proxy.logLevel&lt;/code> 配置，允许用户方便的给控制平面和数据平面组件全局的配置日志。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 支持通过设置 &lt;a href="/v1.8/zh/docs/reference/config/installation-options/#global-options">&lt;code>global.tracer.datadog.address&lt;/code>&lt;/a> 来配置 Datadog 的地址。&lt;/li>
&lt;li>&lt;strong>移除&lt;/strong> 默认情况下禁止使用早期&lt;a href="https://discuss.istio.io/t/deprecation-notice-custom-mixer-adapter-crds/2055">被弃用&lt;/a>的适配器和 CRD 模版。可以使用 &lt;code>mixer.templates.useTemplateCRDs=true&lt;/code> 和 &lt;code>mixer.adapters.useAdapterCRDs=true&lt;/code> 安装配置项来重新启用这两个功能。&lt;/li>
&lt;/ul>
&lt;p>要看全部的变动，请参阅&lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2/helm-changes/">安装选项变动页面&lt;/a>。&lt;/p>
&lt;h2 id="Istio-control-and-Kube-control">&lt;code>istioctl&lt;/code> 和 &lt;code>kubectl&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>毕业&lt;/strong> &lt;code>istioctl verify-install&lt;/code> 走出实验标签。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;code>istioctl verify-install&lt;/code> 可以验证给定的 Kubernetes 环境是否满足 Istio 的要求。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>istioctl&lt;/code> 支持自动完成功能。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>istioctl experimental dashboard&lt;/code> 允许用户方便的打开任意 Istio 插件的 web UI。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;code>istioctl x&lt;/code> 别名可以方便的运行 &lt;code>istioctl experimental&lt;/code> 命令。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;code>istioctl version&lt;/code> 默认展示 Istio 控制平面和 &lt;code>istioctl&lt;/code> 自己的版本信息。&lt;/li>
&lt;li>&lt;strong>改进&lt;/strong> &lt;code>istioctl validate&lt;/code> 验证 Mixer 配置，并且支持完整关联的深度验证。&lt;/li>
&lt;/ul>
&lt;h2 id="miscellaneous">杂项&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>增加&lt;/strong> &lt;a href="/v1.8/zh/docs/setup/additional-setup/cni/">Istio CNI 支持&lt;/a>以设置 sidecar 网络重定向，并移除需要 &lt;code>NET_ADMIN&lt;/code> 功能的 &lt;code>istio-init&lt;/code> 容器。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 新实验功能 &lt;a href="https://github.com/istio/installer/wiki">&amp;lsquo;a-la-carte&amp;rsquo; Istio 安装器&lt;/a>可以让用户以所希望的独立和安全的方式安装和升级 Istio。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 除了命令行参数外，&lt;a href="https://docs.google.com/document/d/1M-qqBMNbhbAxl3S_8qQfaeOLAiRqSBpSgfWebFBRuu8/edit">支持以环境变量和配置文件&lt;/a>的方式来配置 Galley。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> &lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/controlz/">ControlZ&lt;/a> 支持在 Galley 中可视化 MCP 服务的状态。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> 在 Galley 中通过 &lt;a href="/v1.8/zh/docs/reference/commands/galley/#galley-server">&lt;code>enableServiceDiscovery&lt;/code> 命令行参数&lt;/a>来控制服务发现模块。&lt;/li>
&lt;li>&lt;strong>增加&lt;/strong> Galley 和 Pilot 中的 &lt;code>InitialWindowSize&lt;/code> 和 &lt;code>InitialConnWindowSize&lt;/code> 参数允许微调 MCP (gRPC) 的链接设置。&lt;/li>
&lt;li>&lt;strong>毕业&lt;/strong> Galley 的配置处理从 Alpha 版本发展到了 Beta 版。&lt;/li>
&lt;/ul></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.2.x/announcing-1.2/change-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.2.x/announcing-1.2/change-notes/</guid></item><item><title>变更说明</title><description>
&lt;h2 id="incompatible-changes-from-1-0">从 1.0 开始的不兼容变更&lt;/h2>
&lt;p>除了下面列出的新功能和改进之外，Istio 从 1.0 开始就引入了许多重要改进，这些改进可以更改应用程序的行为。在&lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes">升级说明&lt;/a>中可以找到这些改进的简明清单。&lt;/p>
&lt;h2 id="upgrades">升级&lt;/h2>
&lt;p>我们建议手动将控制平面和数据平面升级到 1.1。有关更多信息，请参见&lt;a href="/v1.8/zh/docs/setup/upgrade/">升级文档&lt;/a>。&lt;/p>
&lt;div>
&lt;aside class="callout warning">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-warning"/>&lt;/svg>
&lt;/div>
&lt;div class="content">在将 deployment 升级到 Istio 1.1 之前，请务必查看&lt;a href="/v1.8/zh/news/releases/1.1.x/announcing-1.1/upgrade-notes">升级说明&lt;/a>以获得您应该了解的简要清单。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;h2 id="installation">安装&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>将 CRD 安装从 Istio 安装中分离出来&lt;/strong>。将 Istio 的自定义资源（CRD）放入 &lt;code>istio-init&lt;/code> Helm chart 中。将 CRD 放置在自己的 Helm chart 中，可以在升级过程中保留自定义资源内容的数据连续性，并进一步使 Istio 能够超越基于 Helm 的安装。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>安装配置文件&lt;/strong>。添加了几个安装配置文件，以便使用成熟的且经过测试的方式简化安装过程。&lt;a href="/v1.8/zh/docs/setup/additional-setup/config-profiles/">安装配置文件功能&lt;/a>为用户提供了更好的体验，以便您详细了解。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改进多集群集成&lt;/strong>。将 &lt;code>istio-remote&lt;/code> chart 1.0 合并到 Istio Helm chart 中，从而简化操作体验，其先前用于&lt;a href="/v1.8/zh/docs/setup/install/multicluster/shared-vpn/">多集群 VPN&lt;/a> 和&lt;a href="/v1.8/zh/docs/setup/install/multicluster/shared-gateways/">多集群水平拆分&lt;/a>远程集群安装。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="traffic-management">流量管理&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>新的 &lt;code>Sidecar&lt;/code> 资源&lt;/strong>。通过新的 &lt;a href="/v1.8/zh/docs/concepts/traffic-management/#sidecars">sidecar&lt;/a> 资源，可以更精细地控制附加到命名空间中工作负载的 sidecar 代理的行为。特别是，它增加了对限制 sidecar 向其发送流量的服务集的支持。这减少了计算和传输给代理的配置量，从而改善了启动时间、资源消耗和控制平面可伸缩性。对于复杂部署，我们建议为每个命名空间添加 sidecar 资源。我们还为高级用例的端口、协议和流量捕获提供了控件。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>限制服务的可见性&lt;/strong>。添加了新的 &lt;code>exportTo&lt;/code> 功能，该功能允许服务所有者控制哪些命名空间可以引用其服务。此功能已添加到&lt;code>ServiceEntry&lt;/code>，&lt;code>VirtualService&lt;/code> 中，并且 Kubernetes 服务也通过 &lt;code>networking.istio.io/exportTo&lt;/code> 批注支持该功能。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>命名空间范围&lt;/strong>。当在网关中引用 &lt;code>VirtualService&lt;/code> 时，我们在配置模型中使用基于 DNS 的名称匹配。当多个命名空间为同一主机名定义虚拟服务时，这会造成模棱两可的情况。为了解决歧义，现在可以在 &lt;code>hosts&lt;/code> 字段中使用 &lt;strong>&lt;code>[{namespace-name}]/{hostname-match}&lt;/code>&lt;/strong> 形式的语法按命名空间显式定义这些引用的范围。在 egress &lt;code>Sidecar&lt;/code> 中也可以使用相同功能。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>更新 &lt;code>ServiceEntry&lt;/code> 资源&lt;/strong>。现在支持指定，与双向 TLS 一起使用的服务及相关 SAN 的位置。具有 HTTPS 端口的服务条目不再需要其他虚拟服务来启用基于 SNI 的路由。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>位置感知路由&lt;/strong>。添加了对在选择其他地区的服务之前路由到相同地区的服务的完整支持。请参阅&lt;a href="/v1.8/zh/docs/reference/config/networking/destination-rule#LocalityLoadBalancerSetting">本地负载均衡器设置&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>完善多集群路由&lt;/strong>。简化了多集群设置并启用了其他部署模式。现在，您可以简单地使用它们的入口网关连接多个集群，而无需 Pod 级的 VPN，针对高可用性情况在每个集群中部署控制平面，并跨多个集群创建命名空间以实现创建全局命名空间。高可用控制平面解决方案默认启用位置感知路由。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>弃用 Istio Ingress&lt;/strong>。删除了以前不推荐使用的 Istio ingress。有关如何在&lt;a href="/v1.8/zh/docs/concepts/traffic-management/#gateways">网关&lt;/a>中使用 Kubernetes Ingress 资源的更多详细信息，请参考&lt;a href="/v1.8/zh/docs/ops/integrations/certmanager/">使用 Cert-Manager 保护 Kubernetes Ingress&lt;/a> 示例。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>改进性能和可伸缩性&lt;/strong>。调整 Istio 和 Envoy 的性能和可伸缩性。阅读&lt;a href="/v1.8/zh/docs/ops/deployment/performance-and-scalability/">性能和可伸缩性&lt;/a>获取更多信息。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>默认关闭访问日志&lt;/strong>。默认情况下，禁用所有 Envoy sidecar 的访问日志以提高性能。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="security">安全&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>就绪和存活探针&lt;/strong>。添加了对 Kubernetes HTTP &lt;a href="/v1.8/zh/faq/security/#k8s-health-checks">就绪和存活探针&lt;/a>的支持（启用双向 TLS 时）。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>群集 RBAC 配置&lt;/strong>。用 &lt;code>ClusterRbacConfig&lt;/code> 资源替换了 &lt;code>RbacConfig&lt;/code> 资源，以实现正确的集群范围。关于迁移说明，请参见&lt;a href="https://archive.istio.io/v1.1/docs/setup/kubernetes/upgrade/steps/#migrating-from-rbacconfig-to-clusterrbacconfig">将 &lt;code>RbacConfig&lt;/code> 迁移到 &lt;code>ClusterRbacConfig&lt;/code>&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>通过 SDS 进行身份认证&lt;/strong>。添加了 SDS 支持，通过节点密钥生成以及动态证书轮换，来提供更强的安全性，并且无需重启 Envoy。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>TCP 服务授权&lt;/strong>。除了 HTTP 和 gRPC 服务之外，还增加了对 TCP 服务的授权支持。有关更多信息，请参见 &lt;a href="/v1.8/zh/docs/tasks/security/authorization/authz-tcp">TCP 服务授权&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>终端用户组的授权&lt;/strong>。添加了基于 &lt;code>组&lt;/code> 声明或 JWT 中任何列表类型声明的授权。有关更多信息，请参见&lt;a href="/v1.8/zh/docs/tasks/security/authorization/authz-jwt">基于 JWT 授权&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Ingress Gateway 控制器的外部证书管理&lt;/strong>。添加了一个控制器以动态加载和轮转外部证书。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>自定义 PKI 集成&lt;/strong>。添加了 Vault PKI 集成，并支持受 Vault 保护的签名密钥，并能直接与现有的 Vault PKI 集成。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>自定义信任域（非&lt;code>cluster.local&lt;/code>）&lt;/strong>。在标识中增加了对特定于组织或群集的信任域的支持。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="policies-and-telemetry">策略和遥测&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>默认关闭策略检查&lt;/strong>。默认情况下，修改后的策略检查是关闭的，以提高大多数客户方案的性能。&lt;a href="/v1.8/zh/docs/tasks/policy-enforcement/enabling-policy/">启用策略执行&lt;/a>详细说明了如何根据需要开启 Istio 策略检查。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>Kiali&lt;/strong>。用 &lt;a href="https://www.kiali.io">Kiali&lt;/a> 替换了 &lt;a href="https://github.com/istio/istio/issues/9066">Service Graph addon&lt;/a>，以提供更丰富的可视化体验。有关更多详细信息，请参见 &lt;a href="/v1.8/zh/docs/tasks/observability/kiali/">Kiali 任务&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>减少开销&lt;/strong>。添加了一些性能和规模改进，包括：&lt;/p>
&lt;ul>
&lt;li>&lt;p>大大减少了 Envoy 默认收集生成的统计信息的开销。&lt;/p>&lt;/li>
&lt;li>&lt;p>为 Mixer 工作负载添加了负载削减功能。&lt;/p>&lt;/li>
&lt;li>&lt;p>改进了 Envoy 和 Mixer 之间的协议。&lt;/p>&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;p>&lt;strong>请求头和路由控制&lt;/strong>。添加了创建适配器以影响传入请求 header 和路由的选项。有关更多信息，请参见&lt;a href="/v1.8/zh/docs/tasks/policy-enforcement/control-headers">请求头和路由控制&lt;/a>任务。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>进程外适配器&lt;/strong>。添加了生产可用的进程外适配器功能。然后，我们在此版本中弃用了进程内适配器模型。所有新的适配器开发都应使用进程外模型。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>追踪改进&lt;/strong>。在我们的总体追踪故事中进行了许多改进：&lt;/p>
&lt;ul>
&lt;li>&lt;p>跟踪 ID 的位宽现在是 128。&lt;/p>&lt;/li>
&lt;li>&lt;p>现在支持将追踪数据发送到 &lt;a href="/v1.8/zh/docs/tasks/observability/distributed-tracing/lightstep/">LightStep&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加了一个选项，可用于完全禁用由 Mixer 支持的服务的跟踪功能。&lt;/p>&lt;/li>
&lt;li>&lt;p>添加了策略 decision-aware 跟踪。&lt;/p>&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>&lt;p>&lt;strong>默认的 TCP 指标&lt;/strong>。为追踪 TCP 连接增加默认指标&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>降低插件的负载均衡的要求&lt;/strong>。不再通过单独的负载均衡公开插件。而是通过 Istio 网关公开插件。要使用 HTTP 或 HTTPS 协议从外部公开插件，请使用 &lt;a href="/v1.8/zh/docs/tasks/observability/gateways/">Addon Gateway 文档&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>附加安全凭证&lt;/strong>。更改了附加凭证的存储。为了提高安全性与合规性，Grafana、Kiali 以及 Jaeger 的用户名密码现在存储在 &lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes secret&lt;/a> 中。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>更加灵活的 &lt;code>statsd&lt;/code> 收集器&lt;/strong>。删除了内置的 &lt;code>statsd&lt;/code> 收集器。Istio 现在支持您自己的 &lt;code>statsd&lt;/code>，以提高现有 Kubernetes 部署的灵活性。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="configuration-management">配置管理&lt;/h3>
&lt;ul>
&lt;li>&lt;p>&lt;strong>Galley&lt;/strong>。添加 &lt;a href="/v1.8/zh/docs/ops/deployment/architecture/#galley">Galley&lt;/a> 作为 Istio 主要的配置收集和分发装置。它提供了一个健壮的模型来验证，转换配置状态并将其分配给 Istio 组件，从而将 Istio 组件与 Kubernetes 详细信息隔离开来。Galley 使用&lt;a href="https://github.com/istio/api/tree/release-1.8/mcp">网格配置协议&lt;/a>与组件进行交互。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>监听端口&lt;/strong>。将 Galley 的默认监听端口从 9093 修改为 15014。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="Istio-and-Kube">&lt;code>istioctl&lt;/code> 和 &lt;code>kubectl&lt;/code>&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;strong>验证命名&lt;/strong>。添加 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-validate">&lt;code>istioctl validate&lt;/code>&lt;/a> 命令，用于 Istio Kubernetes 资源的离线验证。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>安装验证命令&lt;/strong>。添加 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-verify-install">&lt;code>istioctl verify-install&lt;/code>&lt;/a> 命令，用于验证指定了 YAML 文件的 Istio 安装的状态。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>弃用命令&lt;/strong>。弃用 &lt;code>istioctl create&lt;/code>、&lt;code>istioctl replace&lt;/code>、&lt;code>istioctl get&lt;/code> 和 &lt;code>istioctl delete&lt;/code> 命令。
请使用 &lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl">&lt;code>kubectl&lt;/code>&lt;/a> 替代。&lt;code>istioctl gen-deploy&lt;/code> 命令也被弃用。请改用 &lt;a href="/v1.8/zh/docs/setup/install/helm/#option-1-install-with-helm-via-helm-template">&lt;code>helm template&lt;/code>&lt;/a>。这些命令将在 1.2 版被删除。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>短命令&lt;/strong>。&lt;code>kubectl&lt;/code> 包含了一些简短命令，可用于 gateway，虚拟服务，目标规则和服务条目。&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><link>/v1.8/zh/news/releases/1.1.x/announcing-1.1/change-notes/</link><author/><guid isPermaLink="true">/v1.8/zh/news/releases/1.1.x/announcing-1.1/change-notes/</guid></item><item><title>在 Istio 中使用 MOSN：另一个数据平面</title><description>
&lt;p>MOSN（Modular Open Smart Network）是用 GoLang 编写的网络代理服务器。它是 &lt;a href="https://www.antfin.com/">蚂蚁集团&lt;/a> 为 Sidecar、API Gateway、云原生 Ingress、Layer 4 或 Layer 7 负载均衡器等场景构建的。随着时间的推移，我们添加了额外的功能，例如多协议框架，多进程插件机制，DSL 和对 &lt;a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol">xDS API&lt;/a> 的支持。支持 xDS 意味着我们现在可以将 MOSN 用作 Istio 的数据平面。Istio 项目不支持此配置。如需帮助，请参阅下面的&lt;a href="#了解更多">了解更多&lt;/a>。&lt;/p>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在 Service Mesh 领域，使用 Istio 作为控制平面已成为主流。由于 Istio 的数据面默认是基于 Envoy 构建的，因此它使用了 Envoy 的数据平面 API（统称为 xDS API）。这些 API 已与 Envoy 分开并进行了标准化，因此，通过在 MOSN 中实现它们，我们就可以使用 MOSN 替代 Envoy。Istio 的第三方数据平面集成可以通过以下三个步骤实现：&lt;/p>
&lt;ul>
&lt;li>实现 xDS 协议，对齐数据面相关服务治理能力;&lt;/li>
&lt;li>使用 Istio 的脚本并设置相关 &lt;code>SIDECAR&lt;/code> 等参数构建 &lt;code>proxyv2&lt;/code> 镜像;&lt;/li>
&lt;li>通过 istioctl 工具并设置 proxy 相关配置指定具体的数据面;&lt;/li>
&lt;/ul>
&lt;h2 id="mosn-架构">MOSN 架构&lt;/h2>
&lt;p>MOSN 是一个分层的体系结构，其系统分为 NET/IO、Protocol、Stream、Proxy 四层，如下图所示：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:45.77056778679027%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/mosn-proxy/mosn-arch.png" title="MOSN 架构图">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/mosn-proxy/mosn-arch.png" alt="MOSN 架构图" />
&lt;/a>
&lt;/div>
&lt;figcaption>MOSN 架构图&lt;/figcaption>
&lt;/figure>
&lt;ul>
&lt;li>NET/IO 作为网络层，监测连接和数据包的到来，同时作为 listener filter 和 network filter 的挂载点;&lt;/li>
&lt;li>Protocol 作为多协议引擎层，对数据包进行检测，并使用对应协议做 decode/encode 处理;&lt;/li>
&lt;li>Stream 对 decode 的数据包做二次封装为 stream，作为 stream filter 的挂载点;&lt;/li>
&lt;li>Proxy 作为 MOSN 的转发框架，对封装的 stream 做 proxy 处理;&lt;/li>
&lt;/ul>
&lt;h2 id="为什么要使用-mosn">为什么要使用 MOSN ？&lt;/h2>
&lt;p>蚂蚁集团在进行 Mesh 改造前，已经预料到作为下一代蚂蚁集团的基础架构，Mesh 化势必带来革命性的变革以及演进成本，我们有非常宏大的蓝图：准备将原有的网络和中间件方面的各种能力重新沉淀和打磨，打造成为未来新一代架构的底层平台，承载各种服务通讯的职责。&lt;/p>
&lt;p>这是一个需要多年时间打造，满足未来五年乃至十年需求的长期规划项目，合作共建团队跨业务、SRE、中间件、基础架构等部门。我们必须有一个具备灵活扩展、高性能、满足长期演进的网络代理转发平面。Nginx、Envoy 在网络代理领域有非常长期的能力积累和活跃的社区，我们也同时借鉴了 Nginx、Envoy 等其他优秀的开源网络代理，同时在研发效率、灵活扩展等方面进行了加强，同时整个 Mesh 改造涉及到非常多的部门和研发人员，必须考虑到跨团队合作的落地成本，所以我们基于 GoLang 自研了云原生场景下的新型网络代理 MOSN。对于 GoLang 的性能，我们前期也做了充分的调研和测试，满足蚂蚁集团业务对性能的要求。&lt;/p>
&lt;p>同时我们从社区用户方面收到了很多的反馈和需求，大家有同样的需求以及思考，所以我们结合社区与自身的实际情况，从满足社区以及用户角度出发进行了 MOSN 的研发工作，我们认为开源的竞争主要是标准与规范的竞争，我们需要基于开源标准做最适合自身的实现选择。&lt;/p>
&lt;h2 id="mosn-和-istio-默认的-proxy-的不同点是什么">MOSN 和 Istio 默认的 Proxy 的不同点是什么？&lt;/h2>
&lt;h3 id="语言栈的不同">语言栈的不同&lt;/h3>
&lt;p>MOSN 使用 GoLang 语言编写，GoLang 语言在生产效率，内存安全上有比较强的保障，同时 GoLang 在云原生时代有广泛的库生态系统，性能在 Mesh 场景下我们评估以及实践是可以接受的。另外 MOSN 对于使用 GoLang、Java 等语言的公司和个人的心智成本更低。&lt;/p>
&lt;h3 id="核心能力的差异化">核心能力的差异化&lt;/h3>
&lt;ul>
&lt;li>MOSN 支持多协议框架，用户可以比较容易的接入私有协议，具有统一的路由框架；&lt;/li>
&lt;li>多进程的插件机制，可以通过插件框架很方便的扩展独立 MOSN 进程的插件，做一些其他管理，旁路等的功能模块扩展；&lt;/li>
&lt;li>具备中国密码合规的传输层国密算法支持；&lt;/li>
&lt;/ul>
&lt;h3 id="mosn-的不足">MOSN 的不足&lt;/h3>
&lt;ul>
&lt;li>由于 MOSN 是用 GoLang 编写的，因此它的性能不如 Istio 的默认代理（默认代理使用的是 C++ 语言），但是在服务网格场景中该性能是可以接受的并且可以使用；&lt;/li>
&lt;li>与 Istio 默认代理相比，不完全支持某些功能，例如 WASM、HTTP3、Lua 等。但是，这些功能在 MOSN 的 &lt;a href="https://docs.google.com/spreadsheets/d/1fALompY9nKZNImOuxQw23xtMD-5rCBrXWziJZkj76bo/edit?usp=sharing">roadmap&lt;/a> 计划之中，我们的目标是和 Istio 完全兼容；&lt;/li>
&lt;/ul>
&lt;h2 id="mosn-结合-istio">MOSN 结合 Istio&lt;/h2>
&lt;p>下面介绍如何将 MOSN 设置为 Istio 的数据平面。&lt;/p>
&lt;h2 id="安装-istio">安装 Istio&lt;/h2>
&lt;p>您可以在 &lt;a href="https://github.com/istio/istio/releases/tag/1.5.2">Istio release&lt;/a> 页面下载与您操作系统匹配的压缩文件，该文件中包含：安装文件、示例和 istioctl 命令行工具。使用如下命令来下载 Istio（本文示例使用的是 Istio 1.5.2）：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export ISTIO_VERSION=1.5.2 &amp;amp;&amp;amp; curl -L https://istio.io/downloadIstio | sh -
&lt;/code>&lt;/pre>
&lt;p>下载的 Istio 包名为 &lt;code>istio-1.5.2&lt;/code>，包含：&lt;/p>
&lt;ul>
&lt;li>&lt;code>install/kubernetesi&lt;/code>：包含 Kubernetes 相关的 YAML 安装文件;&lt;/li>
&lt;li>&lt;code>examples/&lt;/code>：包含示例应用程序;&lt;/li>
&lt;li>&lt;code>bin/&lt;/code>：包含 istioctl 的客户端文件;&lt;/li>
&lt;/ul>
&lt;p>切换到 Istio 包所在目录：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cd istio-$ISTIO_VERSION/
&lt;/code>&lt;/pre>
&lt;p>使用如下命令将 istioctl 客户端路径加入 $PATH 中：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export PATH=$PATH:$(pwd)/bin
&lt;/code>&lt;/pre>
&lt;p>截止目前，我们已经可以通过 istioctl 命令行工具来灵活的自定义 Istio 控制平面和数据平面配置参数。&lt;/p>
&lt;h2 id="设置-mosn-作为-istio-的-sidecar">设置 MOSN 作为 Istio 的 Sidecar&lt;/h2>
&lt;p>通过 istioctl 命令的参数指定 MOSN 作为 Istio 中的数据面：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl manifest apply --set .values.global.proxy.image=&amp;#34;mosnio/proxyv2:1.5.2-mosn&amp;#34; --set meshConfig.defaultConfig.binaryPath=&amp;#34;/usr/local/bin/mosn&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>检查 Istio 相关 pod 服务是否部署成功：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get svc -n istio-system
&lt;/code>&lt;/pre>
&lt;p>如果服务状态 STATUS 为 Running，则表示 Istio 已经成功安装，后面就可以部署 Bookinfo 示例了。&lt;/p>
&lt;h2 id="bookinfo-示例">Bookinfo 示例&lt;/h2>
&lt;p>可以通过 &lt;a href="https://katacoda.com/mosn/courses/istio/mosn-with-istio">MOSN with Istio&lt;/a> 的教程来进行 Bookinfo 示例的演示操作，另外在该教程中您也可以找到更多关于使用 MOSN 和 Istio 的说明。&lt;/p>
&lt;h2 id="展望">展望&lt;/h2>
&lt;p>接下来，MOSN 不仅会持续兼容适配新版本的 Istio 的功能，而且还将在以下几个方面进行发展：&lt;/p>
&lt;ul>
&lt;li>作为微服务运行时，使得面向 MOSN 编程的服务更轻、更小、更快;&lt;/li>
&lt;li>可编程，如支持 WASM;&lt;/li>
&lt;li>更多场景 mesh 化方案支持，缓存/消息/区块链 mesh 化等;&lt;/li>
&lt;/ul>
&lt;p>MOSN 是一个开源项目，社区中的任何人都可以使用，参与和改进。我们希望您能加入我们！可以通过&lt;a href="https://github.com/mosn/community">这里&lt;/a>介绍的几种方式了解 MOSN 正在做的事情并参与其中。&lt;/p>
&lt;h2 id="了解更多">了解更多&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://mosn.io">MOSN 官方博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mosn.io/en/docs/community/">MOSN 开源社区&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://katacoda.com/mosn">MOSN 教程&lt;/a>&lt;/li>
&lt;/ul></description><pubDate>Wed, 29 Jul 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/mosn-proxy/</link><author>王发康 (mosn.io)</author><guid isPermaLink="true">/v1.8/zh/blog/2020/mosn-proxy/</guid><category>mosn</category><category>sidecar</category><category>proxy</category></item><item><title>介绍 istiod：简化控制平面</title><description>
&lt;p>当服务需要由不同的团队交付，或者单独部署及扩展的价值高于编排的成本时，微服务是一种很好的模式。我们定期与在现实世界中运行 Istio 的客户和团队进行交流，他们告诉我们，对于 Istio 控制平面而言，情况并非如此。因此，在 Istio 1.5 中，我们更改了 Istio 的打包方式，将控制平面功能合并为一个被称为 &lt;strong>istiod&lt;/strong> 的二进制文件。&lt;/p>
&lt;h2 id="history-of-the-Istio-control-plane">Istio 控制平面的历史&lt;/h2>
&lt;p>Istio 实现了一种已在 Google 和 IBM 使用多年的模式，该模式后来被称为“服务网格”。通过代理服务器将客户端和服务端进程配对，它们可以充当应用程序感知的 &lt;em>数据平面&lt;/em> ，而不仅仅是在主机间传输数据包或通过网络传输脉冲信号。&lt;/p>
&lt;p>这种模式有利于全世界的工程师通过 &lt;em>微服务&lt;/em> 达成共识：通过轻量级协议连接细粒度、松散耦合的服务。通用的跨平台和跨语言标准（例如 HTTP 和 gRPC ）取代专有传输方式，且各种语言都有相关的库，使得不同的团队能够以最适合的语言编写整个体系架构的不同部分。此外，每个服务可以根据需要独立扩展。对这样的网络实施安全性、可观察性和流量控制的愿景推动了 Istio 的普及。&lt;/p>
&lt;p>Istio 的 &lt;em>控制平面&lt;/em> 本身就是一种现代的云原生应用程序。因此，它从一开始就作为一组微服务而构建。诸如服务发现（Pilot），配置（Galley），证书生成（Citadel）和可扩展性（Mixer）等各个 Istio 组件都被编写并部署为单独的微服务。这些组件需要安全地进行通信并易于观察，这为 Istio 提供了“吃自己的狗粮”的机会（或“喝自己的香槟”，更法语化的比喻！）。&lt;/p>
&lt;h2 id="the-cost-of-complexity">复杂性的代价&lt;/h2>
&lt;p>优秀的团队会回顾他们的选择，并借助事后回顾重新审视当时的选择。通常，当团队接受微服务及其固有的复杂性时，他们会在其他方面寻求改进以证明其取舍的正确性。让我们看一下此视角下的 Istio 控制平面。&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>微服务使您能够使用不同的语言编写。&lt;/strong> 数据平面（ Envoy 代理）是用 C++ 编写的，并且此边界受益于 xDS API 的清晰隔离设计。此外，所有 Istio 控制平面组件都是用 Go 编写的。我们为适当的工作选择了适当的语言：高性能的 C++ 用于代理，而在考虑易于访问和快速开发的其他所有场景都会使用 Go。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>微服务使您能够允许不同的团队分别管理服务。&lt;/strong> 在绝大多数 Istio 安装过程中，所有组件都是由单个团队或个人安装和操作的。Istio 的组件划分与构建它的开发团队的划分是一致的，如果 Istio 的组件是由其开发团队作为托管服务交付，那么这样看起来似乎是很合理的，但事实并非如此！虽然这使得组件开发团队的工作变得更简单，但这对数量更多的普通用户的易用性产生了巨大影响。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>微服务使您能够解耦版本，并在不同时间发布不同的组件。&lt;/strong> 控制平面的所有组件从始至终均在同一版本中发布。我们从未测试或支持运行（例如）Citadel 和 Pilot 的不同版本。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>微服务使您能够独立扩展组件。&lt;/strong> 在 Istio 1.5 中，控制平面的开销主要决于一个功能：Envoy xDS API（对数据平面进行编程）。每个其他的功能都有边际成本，这意味着在可单独伸缩的微服务中拥有这些功能的价值很小。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>微服务使您能够维护安全边界。&lt;/strong> 将应用程序分为不同的微服务的另一个很好的理由是，它们是否具有不同的安全角色。诸如 sidecar 注入器，Envoy 引导程序，Citadel 和 Pilot 之类的多个 Istio 微服务拥有几乎等同的更改代理配置的权限。因此，利用其中的任何服务都将造成几乎同等的损害。部署 Istio 时，默认情况下，所有组件都安装在同一 Kubernetes 命名空间中，从而提供了有限的安全隔离。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="the-benefit-of-consolidation-introducing-istiod">合并的好处：引入 istiod&lt;/h2>
&lt;p>在确定微服务的许多常见好处并不适用于 Istio 控制平面之后，我们决定将它们统一为一个二进制文件：&lt;strong>istiod&lt;/strong>（ &amp;rsquo;d&amp;rsquo; 代表 &lt;a href="https://en.wikipedia.org/wiki/Daemon_%28computing%29">daemon&lt;/a>)。&lt;/p>
&lt;p>让我们看一下新打包方式的好处：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>安装变得更加容易。&lt;/strong> 所需的 Kubernetes deployment 和相关配置更少，因此 Istio 的配置选项和参数集大大减少了。在最简单的情况下，&lt;strong>&lt;em>您只需启动单个 Pod，就可以启用一个包含了所有功能的 Istio 控制平面。&lt;/em>&lt;/strong>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>配置变得更加容易。&lt;/strong> Istio 目前拥有的许多配置选项都是编排控制平面组件的方法，因此不再需要。您也不再需要更改群集范围内的 &lt;code>PodSecurityPolicy&lt;/code> 来部署Istio。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>使用虚拟机变得更加容易。&lt;/strong> 要将工作负载添加到网格中，现在只需要安装一个代理和已生成的证书即可。该代理仅连接单个后台服务。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>维护变得更加容易。&lt;/strong> 安装、升级和删除 Istio 不再需要复杂的版本依赖关系和启动顺序。例如：要升级控制平面，您只需要在现有控制平面边上启动一个新的 istiod 版本，对其进行金丝雀部署，然后将所有流量移至该平面即可。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>伸缩变得更加容易。&lt;/strong> 现在只有一个需要伸缩的组件。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>调试变得更加容易。&lt;/strong> 更少的组件意味着更少的跨组件环境调试。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>启动时间减少。&lt;/strong> 在以预定义的顺序启动时，组件不再需要彼此等待。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>资源使用率下降，响应能力上升。&lt;/strong> 组件之间的通信将得到保证，并且不受 gRPC 报文大小限制。缓存可以被安全的共享，从而减少了资源占用。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>istiod 将先前由 Pilot，Galley，Citadel 和 sidecar 注入器执行的功能统一为一个二进制文件。&lt;/p>
&lt;p>单独的组件 istio-agent 通过将配置和密钥安全地传递给 Envoy 代理，来帮助每个 sidecar 连接到网格。严格来说，尽管该代理仍然是控制平面的一部分，但它是按 per-pod（每 pod ） 运行的。通过将以前作为 DaemonSet 运行的 per-node（每节点） 功能移动到 per-pod（每 pod ）代理中，我们进一步简化了操作。&lt;/p>
&lt;h2 id="extra-for-experts">专家说明&lt;/h2>
&lt;p>在某些情况下，您可能仍然想要独立运行 Istio 组件或替换某些组件。&lt;/p>
&lt;p>一些用户可能想在网格外部使用证书颁发机构（CA），我们有&lt;a href="/v1.8/zh/docs/tasks/security/plugin-ca-cert/">如何执行此操作的文档&lt;/a>。如果您使用其他工具进行证书设置，则可以使用它代替内置 CA。&lt;/p>
&lt;h2 id="moving-forward">进阶&lt;/h2>
&lt;p>本质上，istiod 只是打包和优化方面的改变。它与单独的组件基于相同的代码和 API 契约构建，并且仍由我们全面的测试套件覆盖。这使我们有信心将其设置为 Istio 1.5 中的默认设置。该服务现在称为 &lt;code>istiod&lt;/code> - 在升级过程完成时，您会看到一个用于现有代理的 &lt;code>istio-pilot&lt;/code>。&lt;/p>
&lt;p>虽然迁移到 istiod 似乎是一个巨大的变化，并且对于 &lt;strong>管理&lt;/strong> 和 &lt;strong>维护&lt;/strong> 网格的人员来说是一个巨大的改进，但它不会让 &lt;strong>使用&lt;/strong> Istio 的日常生活变得有何不同。istiod 不会更改用于配置网格的任何 API，因此您现有的进程不会有什么变化。&lt;/p>
&lt;p>这是否意味着微服务对于所有工作负载和架构设计都是错误的？当然不是。它们只是工具箱里的工具，当它们适合您组织的真实情况时，可以发挥最佳的作用。恰恰相反，此变更（引入 istiod ）表明了 Istio 项目愿意根据用户的反馈进行更改，并为了所有用户持续专注于简化操作。微服务的大小必须合适，而我们相信我们已经为 Istio 找到了合适的大小。&lt;/p></description><pubDate>Thu, 19 Mar 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/istiod/</link><author>Craig Box (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2020/istiod/</guid><category>istiod</category><category>control plane</category><category>operator</category></item><item><title>在 Istio 中进行 WebAssembly 声明式部署</title><description>
&lt;p>正如 &lt;a href="/v1.8/zh/blog/2020/tradewinds-2020/">Istio 2020——为了商用&lt;/a>以及最近的 &lt;a href="/v1.8/zh/news/releases/1.5.x/announcing-1.5/">Istio 1.5 发布公告&lt;/a>中指出的那样，WebAssembly (Wasm) 现在是用于扩展 Istio 服务代理（ Envoy 代理）功能的（alpha）选项。使用 Wasm，用户可以建立对新协议、自定义指标、日志和其他过滤器的支持。我们的社区（&lt;a href="https://solo.io">Solo.io&lt;/a>) 与 Google 紧密合作，专注于提升为 Istio 构建、交流和部署 Wasm 扩展的用户体验。我们发布了 &lt;a href="https://webassemblyhub.io">WebAssembly Hub&lt;/a> 和&lt;a href="https://docs.solo.io/web-assembly-hub/latest/installation/">相关工具&lt;/a>，以便在使用 Wasm 时可以获得“类似 docker ”的体验。&lt;/p>
&lt;h2 id="background">背景&lt;/h2>
&lt;p>借助 WebAssembly Hub 工具，我们可以使用 &lt;code>wasme&lt;/code> CLI 轻松为 Envoy 创建一个 Wasm 项目，将其推送到存储库，然后将其提取或部署到 Istio。例如，要使用 &lt;code>wasme&lt;/code> 将 Wasm 扩展部署到 Istio，我们可以运行以下命令：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ wasme deploy istio webassemblyhub.io/ceposta/demo-add-header:v0.2 \
--id=myfilter \
--namespace=bookinfo \
--config &amp;#39;tomorrow&amp;#39;
&lt;/code>&lt;/pre>
&lt;p>这会将 &lt;code>demo-add-header&lt;/code> 扩展添加到在 &lt;code>bookinfo&lt;/code> 命名空间中运行的所有工作负载中。我们可以通过使用 &lt;code>--labels&lt;/code> 参数来更精细地控制哪些工作负载获得扩展：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ wasme deploy istio webassemblyhub.io/ceposta/demo-add-header:v0.2 \
--id=myfilter \
--namespace=bookinfo \
--config &amp;#39;tomorrow&amp;#39; \
--labels app=details
&lt;/code>&lt;/pre>
&lt;p>这比手动创建 &lt;code>EnvoyFilter&lt;/code> 资源并尝试将 Wasm 模块发送到每个 pod（您的目标工作负载的一部分）要容易得多。不管怎么说，这是与 Istio 进行交互的非常必要的方法。就像用户通常不直接在生产环境中使用 &lt;code>kubectl&lt;/code> ，而是喜欢声明式的、基于资源的工作流一样，我们也希望对 Istio 代理进行自定义。&lt;/p>
&lt;h2 id="a-declarative-approach">声明式方法&lt;/h2>
&lt;p>WebAssembly Hub 工具还包括&lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/wasme_operator/">用于将 Wasm 扩展部署到 Istio 工作负载的 operator&lt;/a>。&lt;a href="https://kubernetes.io/zh/docs/concepts/extend-kubernetes/operator/">operator&lt;/a>允许用户使用声明式的格式定义其 WebAssembly 扩展，并将其交给 operator 以修正部署状态。例如，我们使用 &lt;code>FilterDeployment&lt;/code> 资源来定义需要扩展的镜像和工作负载：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: wasme.io/v1
kind: FilterDeployment
metadata:
name: bookinfo-custom-filter
namespace: bookinfo
spec:
deployment:
istio:
kind: Deployment
labels:
app: details
filter:
config: &amp;#39;world&amp;#39;
image: webassemblyhub.io/ceposta/demo-add-header:v0.2
&lt;/code>&lt;/pre>
&lt;p>然后，我们可以获取这个 &lt;code>FilterDeployment&lt;/code> 文档，并使用其余的 Istio 资源对其进行版本控制。您可能想知道在 Istio 已经具有 &lt;code>EnvoyFilter&lt;/code> 资源的情况下，为什么还需要这个自定义资源来配置 Istio 的服务代理以使用 Wasm 扩展。&lt;/p>
&lt;p>让我们来看看所有这一切在幕后的工作原理。&lt;/p>
&lt;h2 id="how-it-works">工作原理&lt;/h2>
&lt;p>在后台，operator 正在做一些有助于将 Wasm 扩展部署和配置到 Istio 服务代理（ Envoy 代理）中的事情。&lt;/p>
&lt;ul>
&lt;li>设置 Wasm 扩展的本地缓存&lt;/li>
&lt;li>将所需的 Wasm 扩展提取到本地缓存中&lt;/li>
&lt;li>将 &lt;code>wasm-cache&lt;/code> 挂载到适当的工作负载中&lt;/li>
&lt;li>使用 &lt;code>EnvoyFilter&lt;/code> CRD 配置 Envoy 以使用 Wasm 过滤器&lt;/li>
&lt;/ul>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:42.663891779396465%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/deploy-wasm-declarative/how-it-works.png" title="理解 wasme operator 的工作原理">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/deploy-wasm-declarative/how-it-works.png" alt="wasme operator 工作原理" />
&lt;/a>
&lt;/div>
&lt;figcaption>理解 wasme operator 的工作原理&lt;/figcaption>
&lt;/figure>
&lt;p>目前，Wasm 镜像需要发布到一个 registry 中，以便 operator 能够正确缓存它。缓存 pod 作为 DaemonSet 运行在每个节点上，以便可以将缓存挂载到 Envoy 容器中。它并不是最理想的机制，我们正在对其进行改进。理想情况下，我们无需处理任何挂载，而是可以直接通过 HTTP 将模块流式传输到代理，因此请随时关注更新（应在接下来的几天内完成）。使用 &lt;code>sidecar.istio.io/userVolume&lt;/code> 和 &lt;code>sidecar.istio.io/userVolumeMount&lt;/code> 注释后，挂载将会建立。有关其工作原理的更多信息，请参见&lt;a href="/v1.8/zh/docs/reference/config/annotations/">有关 Istio 资源注释的文档&lt;/a>。&lt;/p>
&lt;p>一旦 Wasm 模块被正确缓存并挂载入工作负载的服务代理中，operator 即可配置 &lt;code>EnvoyFilter&lt;/code> 资源。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
name: details-v1-myfilter
namespace: bookinfo
spec:
configPatches:
- applyTo: HTTP_FILTER
match:
context: SIDECAR_INBOUND
listener:
filterChain:
filter:
name: envoy.http_connection_manager
subFilter:
name: envoy.router
patch:
operation: INSERT_BEFORE
value:
config:
config:
configuration: tomorrow
name: myfilter
rootId: add_header
vmConfig:
code:
local:
filename: /var/local/lib/wasme-cache/44bf95b368e78fafb663020b43cf099b23fc6032814653f2f47e4d20643e7267
runtime: envoy.wasm.runtime.v8
vmId: myfilter
name: envoy.filters.http.wasm
workloadSelector:
labels:
app: details
version: v1
&lt;/code>&lt;/pre>
&lt;p>您可以看到 &lt;code>EnvoyFilter&lt;/code> 资源配置了代理以添加 &lt;code>envoy.filter.http.wasm&lt;/code> 过滤器并从 &lt;code>wasme-cache&lt;/code> 加载 Wasm 模块。&lt;/p>
&lt;p>一旦将 Wasm 扩展加载到 Istio 服务代理，它将使用您引入的任意自定义代码来扩展代理的功能。&lt;/p>
&lt;h2 id="next-steps">下一步&lt;/h2>
&lt;p>在此博客中，我们探讨了将 Wasm 扩展安装到 Istio 工作负载中的选项。在 Istio 上开始使用 WebAssembly 的最简单方法是使用 &lt;code>wasme&lt;/code> 工具&lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/getting_started/">创建一个新的 Wasm 项目&lt;/a>，可使用 C++，AssemblyScript [或即将推出的 Rust！]。例如，要设置 C++ Wasm 模块，可以运行：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ wasme init ./filter --language cpp --platform istio --platform-version 1.5.x
&lt;/code>&lt;/pre>
&lt;p>如果没有额外的参数，则 &lt;code>wasme init&lt;/code> 将进入交互模式，引导您选择正确的值。&lt;/p>
&lt;p>查看 &lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/getting_started/">WebAssembly Hub wasme 工具&lt;/a>，以在 Istio 上开始使用 Wasm。&lt;/p>
&lt;h2 id="learn-more">了解更多&lt;/h2>
&lt;ul>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/blog/2020/wasm-announce/">重新定义代理的扩展性&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>WebAssembly SF talk (video): &lt;a href="https://www.youtube.com/watch?v=OIUPf8m7CGA">网络代理的扩展&lt;/a>, by John Plevyak&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://www.solo.io/blog/an-extended-and-improved-webassembly-hub-to-helps-bring-the-power-of-webassembly-to-envoy-and-istio/">Solo 博客&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://github.com/proxy-wasm/spec">Proxy-Wasm ABI 规范&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://github.com/proxy-wasm/proxy-wasm-cpp-sdk/blob/master/docs/wasm_filter.md">Proxy-Wasm C++ SDK&lt;/a> 以及 &lt;a href="https://github.com/proxy-wasm/proxy-wasm-cpp-sdk/blob/master/docs/wasm_filter.md">开发者文档&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk">Proxy-Wasm Rust SDK&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://github.com/solo-io/proxy-runtime">Proxy-Wasm AssemblyScript SDK&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/">教程&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://www.youtube.com/channel/UCuketWAG3WqYjjxtQ9Q8ApQ">Solo.io 的 Youtube 频道&lt;/a>里的视频&lt;/p>&lt;/li>
&lt;/ul></description><pubDate>Mon, 16 Mar 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/deploy-wasm-declarative/</link><author>Christian Posta (Solo.io)</author><guid isPermaLink="true">/v1.8/zh/blog/2020/deploy-wasm-declarative/</guid><category>wasm</category><category>extensibility</category><category>alpha</category><category>operator</category></item><item><title>重新定义代理的扩展性：Envoy 和 Istio 引入 WebAssembly</title><description>
&lt;p>自 2016 年使用 &lt;a href="https://www.envoyproxy.io/">Envoy&lt;/a> 以后，Istio 项目一直想提供一个平台，在此平台上可以构建丰富的扩展，以满足用户多样化的需求。有很多要向服务网格的数据平面增加功能的理由 &amp;mdash; 比如：支持更新的协议，与专有安全控件集成，或是通过自定义度量来增强可观察性。&lt;/p>
&lt;p>在过去的一年半中，我们在 Google 的团队一直在努力用 &lt;a href="https://webassembly.org/">WebAssembly&lt;/a> 来为 Envoy 代理添加动态扩展。今天我们很高兴与大家分享这项工作，并推出&lt;a href="https://github.com/proxy-wasm/spec">针对代理的 WebAssembly (Wasm)&lt;/a> (Proxy-Wasm)：包括一个会标准化的 ABI，SDK，以及它的第一个重点实现：新的，低延迟的 &lt;a href="/v1.8/zh/docs/reference/config/telemetry">Istio 遥测系统&lt;/a>。&lt;/p>
&lt;p>我们还与社区紧密合作，以确保为用户提供良好的开发者体验，帮助他们快速上手。Google 团队一直与 &lt;a href="https://solo.io">Solo.io&lt;/a> 团队紧密合作，Solo 他们已经建立了 &lt;a href="https://webassemblyhub.io/">WebAssembly Hub&lt;/a> 服务，用于构建，共享，发现和部署 Wasm 扩展。有了 WebAssembly Hub，Wasm 扩展就会像容器一样易于管理，安装和运行。&lt;/p>
&lt;p>这个项目现在发布了 Alpha 版本，仍然还有很多&lt;a href="#next-steps">工作要做&lt;/a>，但是我们很高兴将其交提供给开发者，以便他们可以开始尝试由此带来的巨大可能性。&lt;/p>
&lt;h2 id="background">背景&lt;/h2>
&lt;p>可扩展需求一直都是 Istio 和 Envoy 项目的基本原则，但是两个项目采用了不同的实现方式。Istio 项目的做法是启用一个通用的进程外扩展模型，叫做 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/">Mixer&lt;/a>，以此带来轻量级的开发者体验，而 Envoy 则专注于代理内&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/extending/extending">扩展&lt;/a>。&lt;/p>
&lt;p>每种方法都各有利弊。Istio 模型导致明显的资源效率低下，从而影响了尾部延迟和资源利用率。该模型在根本上来说是有局限性的 - 例如，它永远不会支持实现&lt;a href="https://blog.envoyproxy.io/how-to-write-envoy-filters-like-a-ninja-part-1-d166e5abec09">自定义协议处理&lt;/a>。&lt;/p>
&lt;p>Envoy 模型强化了单体构建过程，并要求使用 C++ 编写扩展，从而限制了开发者的生态。给集群发布新的扩展需要下发新的二进制文件并滚动重启，这可能很难协调，并有可能会导致停机。这也促使了开发者向 Envoy 上游提交他们的扩展，而这些扩展仅由一小部分生产环境使用，更多仅仅是为了利用其发布机制。&lt;/p>
&lt;p>随着时间的流逝，Istio 的一些对性能最敏感的功能已合进了上游的 Envoy - 例如&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/rbac_filter">流量检查策略&lt;/a>和例如&lt;a href="/v1.8/zh/docs/reference/config/telemetry/metrics/">遥测上报&lt;/a>。尽管如此，我们一直想把扩展汇聚在一个技术栈上，从而减少两者之间犹豫的权衡：这使 Envoy 版本与其扩展生态系统脱钩，使开发者能够使用他们选择的语言进行工作，并使 Istio 可靠地推出新功能而不必有停机风险。&lt;/p>
&lt;h2 id="what-is-WebAssembly">什么是 WebAssembly&lt;/h2>
&lt;p>&lt;a href="https://webassembly.org/">WebAssembly&lt;/a>（Wasm）是一种由&lt;a href="https://github.com/appcypher/awesome-wasm-langs">多种语言&lt;/a>编写的，可移植的字节码格式，它能以以接近本机的速度执行。其最初的&lt;a href="https://webassembly.org/docs/high-level-goals/">设计目标&lt;/a>与上述挑战很相符，并且在其背后得到了相当大的行业支持。Wasm 是在所有主流浏览器中可以本地运行的第四种标准语言（继 HTML，CSS 和 JavaScript 之后），于 2019 年 12 月成为 &lt;a href="https://www.w3.org/TR/wasm-core-1/">W3C 正式建议&lt;/a>。这使我们有信心对其进行战略下注。&lt;/p>
&lt;p>尽管 WebAssembly 最初是作为客户端技术而诞生，但它在服务器上用也有很多优势。运行时是内存安全的，并且以沙盒方式运行以确保安全。它有一个很大的工具生态系统，用于以文本或二进制格式编译和调试 Wasm。&lt;a href="https://www.w3.org/">W3C&lt;/a> 和 &lt;a href="https://bytecodealliance.org/">BytecodeAlliance&lt;/a> 已成为其它服务器端工作的活跃中心。比如，Wasm 社区正在 W3C 中标准化 &lt;a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">&amp;ldquo;WebAssembly 系统接口 Interface&amp;rdquo; (WASI)&lt;/a>，并通过一个示例实现，它为 Wasm “程序” 提供了一个类似 OS 的抽象。&lt;/p>
&lt;h2 id="bringing-WebAssembly-to-Envoy">把 WebAssembly 引入 Envoy&lt;/h2>
&lt;p>&lt;a href="https://github.com/envoyproxy/envoy/issues/4272">在过去的 18 个月中&lt;/a>，我们一直与 Envoy 社区合作把 Wasm 的扩展引入 Envoy，并将其贡献到上游。我们很高兴地宣布，此特性在 &lt;a href="/v1.8/zh/news/releases/1.5.x/announcing-1.5/">Istio 1.5&lt;/a> 自带的 Envoy 中以 Alpha 版本可用了，其源代码在 &lt;a href="https://github.com/envoyproxy/envoy-wasm/">&lt;code>envoy-wasm&lt;/code>&lt;/a> 开发分支中，并且正在努力将其合并到 Envoy 主干上。该实现使用了 Google 高性能 &lt;a href="https://v8.dev/">V8 引擎&lt;/a>中内置的 WebAssembly 运行时。&lt;/p>
&lt;p>除了构建底层的运行时，我们还构建了：&lt;/p>
&lt;ul>
&lt;li>把 Wasm 嵌入代理的通用应用程序二进制接口（ABI），这意味着编译后的扩展将可以在不同版本的 Envoy 中工作，甚至其它代理也可以，当然当然，其它代理得实现 ABI。&lt;/li>
&lt;li>用 &lt;a href="https://github.com/proxy-wasm/proxy-wasm-cpp-sdk">C++&lt;/a>,
&lt;a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk">Rust&lt;/a> 和 &lt;a href="https://github.com/solo-io/proxy-runtime">AssemblyScript&lt;/a> 可以方便进行扩展开发的 SDK，后续还有很多语言支持&lt;/li>
&lt;li>全面的&lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/">示例和说明&lt;/a>介绍如何在 Istio 和独立的 Envoy 中部署&lt;/li>
&lt;li>允许使用其它 Wasm 运行时的抽象，包括把本地把扩展直接编译进 Envoy 中 “null” 运行时，这对于测试和调试非常有用&lt;/li>
&lt;/ul>
&lt;p>使用 Wasm 扩展 Envoy 带来了几个主要好处：&lt;/p>
&lt;ul>
&lt;li>敏捷性：可以用 Istio 控制平面在运行时下发和重载扩展。这就可以快速的进行扩展开发→ 测试→ 发布周期，而无需重启 Envoy。&lt;/li>
&lt;li>发布库：一旦完成合并到主树中之后，Istio 和其它程序将能够使用 Envoy 的发布库，而不是自己构建。这也方便 Envoy 社区迁移某些内置扩展到这个模型，从而减少他们的工作。&lt;/li>
&lt;li>可靠性和隔离性：扩展部署在具有资源限制的沙箱中，这意味着它们现在可以崩溃或泄漏内存，但不会让整个 Envoy 挂掉。CPU 和内存使用率也可以受到限制。&lt;/li>
&lt;li>安全性：沙盒具有一个明确定义的 API，用于和 Envoy 通信，因此扩展只能访问和修改链接或者请求中有限数量的属性。此外，由于 Envoy 协调整个交互，因此它可以隐藏或清除扩展中的敏感信息（例如，HTTP 头中的 “Authorization”和“Cookie”，或者客户端的 IP 地址）。&lt;/li>
&lt;li>灵活性：&lt;a href="https://github.com/appcypher/awesome-wasm-langs">可以将超过 30 种编程语言编译为 WebAssembly&lt;/a>，可以让各种技术背景的开发人员都可以用他们选择的语言来编写 Envoy 扩展，比如：C++，Go，Rust，Java，TypeScript 等。&lt;/li>
&lt;/ul>
&lt;p>“看到 Envoy 上支持了 WASM，我感到非常兴奋；这是 Envoy 可扩展的未来。Envoy 的 WASM 支持与社区驱动的 hub 相结合，将在服务网格和 API 网关用例中开启出令人难以置信的网络创新。我迫不及待地想看到社区构建是如何向前发展的。” – Envoy 创造者 Matt Klein。&lt;/p>
&lt;p>有关实现的技术细节，请关注即将在 &lt;a href="https://blog.envoyproxy.io/">Envoy 博客&lt;/a>上发的文章。&lt;/p>
&lt;p>主机环境和扩展之间的 &lt;a href="https://github.com/proxy-wasm">Proxy-Wasm&lt;/a> 接口有意设计为代理无感知的。我们已将其内置到了 Envoy 中，但它是为其它代理供应商设计的。我们希望看为 Istio 和 Envoy 编写的扩展也可以在其它基础设施中运行。很快就会有更多相关的设计和实现了。&lt;/p>
&lt;h2 id="building-on-WebAssembly-in-Istio">Istio 中的 WebAssembly 构建&lt;/h2>
&lt;p>为了显著提高性能，Istio 在 1.5 的发布中，把它的几个扩展内置到了 Envoy 中。在执行此工作时，我们把这些同样的扩展可以作为 Proxy-Wasm 模块进行编译和运行，测试确保其行为没有异常。考虑到我们认为 Wasm 支持还是 Alpha 版本，我们还没有完全准备好将这个设置设为默认设置；然而，在我们的通用实现和主机环境还是给了我们不少信心，至少 ABI 和 SDK 已经开发完成了。&lt;/p>
&lt;p>我们还是要小心地确保 Istio 控制平面及其 &lt;a href="/v1.8/zh/docs/reference/config/networking/envoy-filter/">Envoy 配置 API&lt;/a> 已经可以支持 Wasm。我们有一些示例来展示几种常见的定制，例如定制头解码或程序中路由，这是用户的常见要求。当将这个支持发展到 Beta 版本时，将会看到 Istio 中使用 Wasm 最佳实践的文档。&lt;/p>
&lt;p>最后，我们正在与许多编写了 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/">Mixer 适配器&lt;/a>的供应商合作，帮助他们迁移到 Wasm — 如果这是前行的最佳方式。Mixer 将在未来的版本中转为社区项目，它将仍可用于老系统。&lt;/p>
&lt;h2 id="developer-experience">开发者体验&lt;/h2>
&lt;p>没有出色的开发者体验，再强大的工具也毫无用处。Solo.io &lt;a href="https://www.solo.io/blog/an-extended-and-improved-webassembly-hub-to-helps-bring-the-power-of-webassembly-to-envoy-and-istio/">最近宣布&lt;/a>发布 &lt;a href="https://webassemblyhub.io/">WebAssembly Hub&lt;/a>，这是一套为 Envoy 和 Istio 做的，用于构建，部署，共享和发现 Envoy Proxy Wasm 扩展的工具和仓库。&lt;/p>
&lt;p>WebAssembly Hub 把为开发和部署 Wasm 扩展所需的许多步骤都完全自动化了。使用 WebAssembly Hub 工具，用户可以轻松地把任何受支持语言开发的代码编译为 Wasm 扩展。可以将这些扩展上传到 Hub 仓库，并且用单个命令就将其在 Istio 中部署和删除。&lt;/p>
&lt;p>在后台，Hub 处理了很多细节问题，例如：引入正确的工具链、ABI 版本验证、权限控制等等。该工作流程还通过自动化扩展部署，消除了跨 Istio 服务代理的配置更改带来的麻烦。此工具帮助用户和操作员避免由于配置错误或版本不匹配而导致的意外行为。&lt;/p>
&lt;p>WebAssembly Hub 工具提供了功能强大的 CLI 和优雅且易于使用的图形用户界面。WebAssembly Hub 的一个重要目标是简化围绕构建 Wasm 模块的体验，并为开发者提供共享和发现有用扩展的协作场所。&lt;/p>
&lt;p>请查看&lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/">入门指南&lt;/a>，以创建您的第一个 Proxy-Wasm 扩展。&lt;/p>
&lt;h2 id="next-steps">下一步&lt;/h2>
&lt;p>除了努力发布 Beta 版，我们还致力于确保围绕 Proxy-Wasm 有一个持久的社区。ABI 需要最终确定，而将其转变为标准的工作将会在适当的标准机构内获得更广泛的反馈后完成。完成向 Envoy 主干提供上游支持的工作仍在进行中。我们还在为工具和 WebAssembly Hub 寻找合适的社区。&lt;/p>
&lt;h2 id="learn-more">了解更多&lt;/h2>
&lt;ul>
&lt;li>WebAssembly SF talk (视频) : &lt;a href="https://www.youtube.com/watch?v=OIUPf8m7CGA">网络代理扩展&lt;/a>, by John Plevyak&lt;/li>
&lt;li>&lt;a href="https://www.solo.io/blog/an-extended-and-improved-webassembly-hub-to-helps-bring-the-power-of-webassembly-to-envoy-and-istio/">Solo 博客&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/proxy-wasm/spec">Proxy-Wasm ABI 说明&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/proxy-wasm/proxy-wasm-cpp-sdk/blob/master/docs/wasm_filter.md">Proxy-Wasm C++ SDK&lt;/a> 和其&lt;a href="https://github.com/proxy-wasm/proxy-wasm-cpp-sdk/blob/master/docs/wasm_filter.md">开发者文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/proxy-wasm/proxy-wasm-rust-sdk">Proxy-Wasm Rust SDK&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/solo-io/proxy-runtime">Proxy-Wasm AssemblyScript SDK&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.solo.io/web-assembly-hub/latest/tutorial_code/">指南&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/channel/UCuketWAG3WqYjjxtQ9Q8ApQ">Solo.io Youtube 频道&lt;/a>上的视频&lt;/li>
&lt;/ul></description><pubDate>Thu, 05 Mar 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/wasm-announce/</link><author>Craig Box, Mandar Jog, John Plevyak, Louis Ryan, Piotr Sikora (Google), Yuval Kohavi, Scott Weiss (Solo.io)</author><guid isPermaLink="true">/v1.8/zh/blog/2020/wasm-announce/</guid><category>wasm</category><category>extensibility</category><category>alpha</category><category>performance</category><category>operator</category></item><item><title>Istio 2020——为了商用</title><description>
&lt;p>Istio 解决了人们在运行微服务时遇到的实际问题。甚至&lt;a href="https://kubernetespodcast.com/episode/016-descartes-labs/">早期的预发行版本&lt;/a>就已经可以帮助用户诊断其体系架构中的延迟，提高服务的可靠性以及透明地保护防火墙后的流量。&lt;/p>
&lt;p>去年，Istio 项目成长巨大。经过 9 个月的酝酿，在 2019 年第一季度发行 1.1 之前，我们设定了一个季度发布节奏的目标。我们知道，持续且可预测地交付非常重要。我们计划连续三个季度发布三个版本，并且我们为实现了这一目标感到自豪。&lt;/p>
&lt;p>过去一年，我们改进了构建和测试基础架构，从而提高了质量并简化了发布周期。我们将用户体验提高了一倍，添加了许多命令使网格的操作和调试变得更加简单。我们还看到为 Istio 做出贡献的开发人员和公司数量急剧增长，最终，我们成为了 &lt;a href="https://octoverse.github.com/#fastest-growing-oss-projects-by-contributors">GitHub 增长最快的十大项目中排名第 4 名&lt;/a>！&lt;/p>
&lt;p>2020 年，Istio 有宏伟的目标，并且我们正在努力中。与此同时，我们坚信良好的基础设施应该“无聊”。在生产中使用 Istio 应该是无缝的体验；性能不应该成为问题，升级应该是非事件性的，复杂的任务应自动化。随着我们对更强大的可扩展性的投入，我们认为 Istio 在专注于现在成就的同时，可以加快服务网格领域的创新步伐。以下是我们在 2020 年主要工作的详情。&lt;/p>
&lt;h2 id="sleeker-smoother-and-faster">更快、更简单&lt;/h2>
&lt;p>从第一天起，Istio 就通过 Mixer 组件提供了可扩展性支持。Mixer 是一个平台，允许使用自定义&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/#adapters">适配器&lt;/a>充当数据平面与策略及遥测后端之间的中介。Mixer 必定会增加请求的开销，因为它必须扩展到进程之外。因此，我们正在向一种可以直接在代理中进行扩展的模型转变。&lt;/p>
&lt;p>Istio 的&lt;a href="/v1.8/zh/docs/concepts/security/#authentication-policies">认证&lt;/a>和&lt;a href="/v1.8/zh/docs/concepts/security/#authorization">授权&lt;/a>策略已经涵盖了 Mixer 用于策略执行的大多数用例，这些策略使您可以直接在代理中控制 workload 到 workload 以及终端用户到 workload 的授权。常见的监控用例也已经转移到代理中，我们&lt;a href="/v1.8/zh/docs/ops/configuration/telemetry/in-proxy-service-telemetry/">引入了代理内支持&lt;/a>，以便将遥测发送到 Prometheus 和 Stackdriver。&lt;/p>
&lt;p>我们的基准测试表明，新的遥测模型可显著减少延迟，并可提供行业领先的性能，同时降低 50％ 的延迟和 CPU 消耗。&lt;/p>
&lt;h2 id="a-new-model-for-Istio-extensibility">新的 Istio 可扩展性模型&lt;/h2>
&lt;p>新的 Mixer 模型使用 Envoy 中的扩展来提供更多功能。Istio 社区正在领导 Envoy 的 &lt;a href="https://webassembly.org/">WebAssembly&lt;/a>（Wasm）运行时的实现，Wasm 让我们可以使用&lt;a href="https://github.com/appcypher/awesome-wasm-langs">超过 20 种的语言&lt;/a>来开发模块化、沙盒化的扩展。可以在代理继续提供流量的同时动态加载、重载扩展。Wasm 扩展程序还可以通过 Mixer 无法做到的方式来扩展平台。它们可以充当自定义协议处理程序，并在通过 Envoy 时转换有效负载，简而言之，它们可以执行与 Envoy 中内置的模块相同的操作。&lt;/p>
&lt;p>我们正在与 Envoy 社区一起研究发现和分发这些扩展的方法。我们希望使 WebAssembly 扩展像容器一样易于安装和运行。我们的许多合作伙伴已经编写了 Mixer 适配器，并与我们一起将其移植到 Wasm。如何编写自己的扩展并进行自定义集成？我们正在开发相关的指南和代码实验室。&lt;/p>
&lt;p>更换扩展模型后，我们还可以删除数十个 CRD。与 Istio 集成的每个软件都不再需要唯一 CRD。&lt;/p>
&lt;p>通过 &lt;code>preview&lt;/code> 配置文件安装 Istio 1.5 不会再安装 Mixer。安全起见，如果您是从以前的版本升级，或通过 &lt;code>default&lt;/code> 配置文件安装，我们仍会保留 Mixer。当使用 Prometheus 或 Stackdriver 进行度量时，建议您尝试新模式并查看性能提高了多少。&lt;/p>
&lt;p>如果有需要，您可以保持安装并启用 Mixer。最终，Mixer 将成为 Istio 单独的发行组件，成为 &lt;a href="https://github.com/istio-ecosystem/">istio-ecosystem&lt;/a> 的一部分。&lt;/p>
&lt;h2 id="fewer-moving-parts">减少移动部分&lt;/h2>
&lt;p>我们还将简化其余控制平面的 deployment。为此，我们将几个控制平面组件合并为一个组件：Istiod。该二进制文件包括 Pilot、Citadel、Galley 和 Sidecar 注入器的功能。这种方法从许多方面改善了 Istio 的安装和管理，降低了安装和配置的复杂性、维护工作量以及问题诊断时间，同时提高了响应速度。
关于 Istiod 的更多内容请查看 &lt;a href="https://blog.christianposta.com/microservices/istio-as-an-example-of-when-not-to-do-microservices/">Christian Posta 的这篇博客&lt;/a>。&lt;/p>
&lt;p>我们将 Istiod 作为 1.5 中所有配置文件的默认配置。&lt;/p>
&lt;p>为了减少每个节点的占用空间，我们放弃了用于分发证书的节点代理，并将其功能迁移至已经在每个 Pod 中运行的 istio-agent 中。从图片来看，我们正在从这里：&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:75%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/tradewinds-2020/architecture-pre-istiod.svg" title="Istio 目前的架构">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/tradewinds-2020/architecture-pre-istiod.svg" alt="基于 Pilot、Mixer、Citadel、Sidecar 注入器的 Istio 架构" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio 目前的架构&lt;/figcaption>
&lt;/figure>
&lt;p>迁移到这里：&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:75%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/tradewinds-2020/architecture-post-istiod.svg" title="Istio 2020 年的架构">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/tradewinds-2020/architecture-post-istiod.svg" alt="基于 Istiod 的 Istio 架构" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio 2020 年的架构&lt;/figcaption>
&lt;/figure>
&lt;p>2020 年，我们将继续专注于普及，实现默认 &lt;code>零配置&lt;/code> 的目标，该默认设置不需要您更改应用程序的任何配置即可使用 Istio 的大多数功能。&lt;/p>
&lt;h2 id="improved-lifecycle-management">改进生命周期管理&lt;/h2>
&lt;p>为了改进 Istio 的生命周期管理，我们使用了基于 &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">operator&lt;/a> 的安装方式。这里介绍 &lt;strong>&lt;a href="/v1.8/zh/docs/setup/install/istioctl/">Istio Operator CRD 的两种安装模式&lt;/a>&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>人为触发：使用 istioctl 将设置应用至集群。&lt;/li>
&lt;li>机器触发：使用一个控制器，实时观察 CRD 的改动并使其生效。&lt;/li>
&lt;/ul>
&lt;p>在 2020 年，升级 Istio 也将变得更加容易。我们将添加对 Istio 控制平面新版本的&amp;rdquo;金丝雀&amp;rdquo;支持，这使您可以同时运行现有版本的和新版本，并将数据平面逐渐切换至新版本。&lt;/p>
&lt;h2 id="secure-by-default">默认安全&lt;/h2>
&lt;p>Istio 已经为强大的服务安全性提供了基础：可靠的 workload 身份、强大的访问策略、全面的审核日志记录。我们正在为这些功能提供稳定的 API；许多 Alpha API 都将在 1.5 版中过渡为 Beta 版，我们希望到 2020 年底它们都将成为 v1 版本。要了解有关 API 状态的更多信息，请参见我们的&lt;a href="/v1.8/zh/about/feature-stages/#istio-features">功能页面&lt;/a>。&lt;/p>
&lt;p>默认情况下，网络流量也变得更加安全。继许多用户可以在评估时启用它之后，&lt;a href="/v1.8/zh/docs/tasks/security/authentication/auto-mtls/">自动双向 TLS&lt;/a> 已成为 Istio 1.5 中的推荐做法。&lt;/p>
&lt;p>此外，我们将让 Istio 所需的权限更少，并简化其依赖性，从而使 Istio 成为更强大的系统。在以前，您必须使用 Kubernetes Secrets 将证书安装到 Envoy，这些证书作为文件挂载至每个代理中。而现在，通过&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/security/secret">密钥发现服务（SDS）&lt;/a> ，我们可以安全地分发这些证书，而不必担心它们会被计算机上的其他 workload 拦截。该模式将成为 1.5 中的默认模式。&lt;/p>
&lt;p>摆脱节点代理，不仅简化了部署，而且消除了对整个集群范围内 &lt;code>PodSecurityPolicy&lt;/code> 的要求，从而进一步改善了集群的安全性。&lt;/p>
&lt;h2 id="other-features">其它功能&lt;/h2>
&lt;p>这是 Istio 在 2020 年一些值得期待的、令人兴奋的事情：&lt;/p>
&lt;ul>
&lt;li>与更多托管的 Kubernetes 环境集成，目前已有 15 个供应商提供了 Istio 服务网格，这些公司包括：Google、IBM、Red Hat、VMware、Alibaba 以及 Huawei。&lt;/li>
&lt;li>更多的关注 &lt;code>istioctl&lt;/code> 及其帮助诊断问题的能力。&lt;/li>
&lt;li>将基于 VM 的 workload 更好地集成到网格中。&lt;/li>
&lt;li>继续努力使多群集和多网络网格更易于配置、维护和运行。&lt;/li>
&lt;li>与更多的服务发现系统集成，包括 Functions-as-a-Service。&lt;/li>
&lt;li>实现新的 &lt;a href="https://kubernetes-sigs.github.io/service-apis/">Kubernetes service API&lt;/a>（目前正在开发中）。&lt;/li>
&lt;li>&lt;a href="https://github.com/istio/enhancements/">增强存储库&lt;/a>，以便开发追踪功能。&lt;/li>
&lt;li>让没有 Kubernetes 的 Istio 可以更轻松地运行！&lt;/li>
&lt;/ul>
&lt;p>从大海到&lt;a href="https://www.youtube.com/watch?v=YjZ4AZ7hRM0">天空&lt;/a>，Istio 期待您的加入！&lt;/p></description><pubDate>Tue, 03 Mar 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/tradewinds-2020/</link><author>Istio Team</author><guid isPermaLink="true">/v1.8/zh/blog/2020/tradewinds-2020/</guid><category>roadmap</category><category>security</category><category>performance</category><category>operator</category></item><item><title>移除跨 pod Unix domain socket</title><description>&lt;p>在 Istio 1.5 之前，执行秘密发现服务（SDS）期间，SDS 客户端和 SDS 服务器通过跨 pod Unix domain socket（UDS）进行通信，该法需要 Kubernetes pod 安全策略提供保护。&lt;/p>
&lt;p>在 Istio 1.5 中，Pilot Agent、Envoy 和 Citadel Agent 将运行在同一个容器中（体系结构如下图所示）。为了防止攻击者窃听 Envoy（SDS 客户端）和 Citadel Agent（SDS 服务器）之间的跨 pod UDS，Istio 1.5 将 Pilot Agent 和 Citadel Agent 合并为一个 Istio Agent，并将 Envoy 和 Citadel Agent 之间的 UDS 变为 Istio Agent 专用的（私有的）。Istio Agent 容器被部署为应用服务容器的 sidecar。&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:80.39622513132818%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/istio-agent/istio_agent.svg" title="Istio Agent 的体系结构">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/istio-agent/istio_agent.svg" alt="Istio Agent 的体系结构" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio Agent 的体系结构&lt;/figcaption>
&lt;/figure></description><pubDate>Thu, 20 Feb 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/istio-agent/</link><author>Lei Tang (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2020/istio-agent/</guid><category>security</category><category>secret discovery service</category><category>unix domain socket</category></item><item><title>使用 Admiral 管理 Istio 多集群的配置和服务发现</title><description>
&lt;p>在 Intuit 公司，我们看到了博客&lt;a href="/v1.8/zh/blog/2019/isolated-clusters/">用于隔离和边界保护的多网格部署&lt;/a>，其中提到的某些问题与我们有关系。我们意识到，即使我们想要配置单网格多集群，而不是博客中描述的多个网格联邦，我们的环境中也会遇到相同的非统一命名问题。这篇博客介绍了我们如何使用 &lt;a href="https://github.com/istio-ecosystem/admiral">Admiral&lt;/a> 解决这些问题，该项目是 GitHub 组织 &lt;code>istio-ecosystem&lt;/code> 下的一个开源项目。&lt;/p>
&lt;h2 id="background">背景&lt;/h2>
&lt;p>使用 Istio，我们意识到多集群的配置很复杂，并且随着时间的推移很难维护。结果就是，出于可伸缩性和其他操作可行性的考虑，我们选择了&lt;a href="/v1.8/zh/docs/setup/install/multicluster/gateways/#deploy-the-Istio-control-plane-in-each-cluster">具有控制平面副本集的多集群 Istio 服务网格&lt;/a>中描述的模型。遵循此模型，在大范围使用 Istio 服务网格之前，我们必须解决这些关键需求：&lt;/p>
&lt;ul>
&lt;li>如&lt;a href="/v1.8/zh/blog/2019/isolated-clusters/#features-of-multi-mesh-deployments">多网格部署的功能&lt;/a>中所描述的，创建与命名空间分离的服务 DNS。&lt;/li>
&lt;li>跨集群的服务发现。&lt;/li>
&lt;li>支持双活以及 HA/DR 部署。我们还必须通过在分散的集群中的全局唯一命名空间中部署服务来支持这些关键的弹性模式。&lt;/li>
&lt;/ul>
&lt;p>我们拥有超过 160 个的 Kubernetes 集群以及跨集群的全局唯一命名空间。基于这样的配置，我们可以根据命名空间名称，将相同的服务 workload 部署到不同区域中。
结果是，我们根据&lt;a href="/v1.8/zh/blog/2019/multicluster-version-routing">多集群网格中的分版本路由&lt;/a>中的路由策略，示例中的 &lt;code>foo.namespace.global&lt;/code> 无法跨集群工作。我们需要通过全局唯一的、可发现的 service DNS，该 DNS 可以解析多个集群中的服务实例，每个实例都可以使用其唯一 Kubernetes FQDN 进行寻址/运行。
例如，如果 &lt;code>foo&lt;/code> 以不同的名称，同时运行在两个 Kubernetes 集群中，则 &lt;code>foo.global&lt;/code> 应该同时解析为 &lt;code>foo.uswest2.svc.cluster.local&lt;/code> 和 &lt;code>foo.useast2.svc.cluster.local&lt;/code>。并且，我们的服务需要其他具有不同解析度和全局路由属性的 DNS 名称。例如，&lt;code>foo.global&lt;/code> 应首先在本地解析，然后使用拓扑路由，将其路由到远程实例，而&lt;code>foo-west.global&lt;/code> 和 &lt;code>foo-east.global&lt;/code>（用于测试的名称）始终应解析到相应地区。&lt;/p>
&lt;h2 id="contextual-configuration">上下文配置&lt;/h2>
&lt;p>经过进一步的调查，很明显，配置需要根据上下文来确定：每个集群都需要根据其场景定制配置。&lt;/p>
&lt;p>例如，我们有一个被订单和报告消费的支付服务。支付服务在 &lt;code>us-east&lt;/code>（集群 3）和 &lt;code>us-west&lt;/code>（集群 2）之间进行了 HA/DR 部署。支付服务部署在两个区域不同名的命名空间中。订单服务作为支付方式，部署在 &lt;code>us-west&lt;/code> 另一个集群中（集群 1）。报告服务与 &lt;code>us-west&lt;/code> 中的支付服务部署在同一集群中（集群 2）。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:60.81558869142712%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/multi-cluster-mesh-automation/Istio_mesh_example.svg" title="Istio 中的 workload 跨集群通信">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/multi-cluster-mesh-automation/Istio_mesh_example.svg" alt="Istio 多集群调用 workload 的示例" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio 中的 workload 跨集群通信&lt;/figcaption>
&lt;/figure>
&lt;p>当集群 1 和集群 2 中的其它服务想要使用支付服务时，下面的 Istio &lt;code>ServiceEntry&lt;/code> yaml 说明了其需要使用的上下文配置：&lt;/p>
&lt;p>集群 1 Service Entry&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: payments.global-se
spec:
addresses:
- 240.0.0.10
endpoints:
- address: ef394f...us-east-2.elb.amazonaws.com
locality: us-east-2
ports:
http: 15443
- address: ad38bc...us-west-2.elb.amazonaws.com
locality: us-west-2
ports:
http: 15443
hosts:
- payments.global
location: MESH_INTERNAL
ports:
- name: http
number: 80
protocol: http
resolution: DNS
&lt;/code>&lt;/pre>
&lt;p>集群 2 Service Entry&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: payments.global-se
spec:
addresses:
- 240.0.0.10
endpoints:
- address: ef39xf...us-east-2.elb.amazonaws.com
locality: us-east-2
ports:
http: 15443
- address: payments.default.svc.cluster.local
locality: us-west-2
ports:
http: 80
hosts:
- payments.global
location: MESH_INTERNAL
ports:
- name: http
number: 80
protocol: http
resolution: DNS
&lt;/code>&lt;/pre>
&lt;p>从集群 2 中报告服务的角度来看，支付 &lt;code>ServiceEntry&lt;/code>（Istio CRD）应将 &lt;code>us-west&lt;/code> 指向本地 Kubernetes FQDN，将 &lt;code>us-east&lt;/code> 指向集群 3 的 &lt;code>istio-ingressgateway&lt;/code>（负载均衡器）。从集群 1 中订单服务的角度来看，支付 &lt;code>ServiceEntry&lt;/code> 应将 &lt;code>us-west&lt;/code> 指向集群 2 的 &lt;code>istio-ingressgateway&lt;/code> 以及将 &lt;code>us-east&lt;/code> 指向集群 3 的 &lt;code>istio-ingressgateway&lt;/code>。&lt;/p>
&lt;p>但是，还有更复杂的情况：如果 &lt;code>us-west&lt;/code> 的支付服务想进行计划维护，现在要将流量转移到 &lt;code>us-east&lt;/code> 的支付服务，此时该怎么办？这要求支付服务更改其所有客户集群中的 Istio 配置。如果没有自动化，这几乎不可能。&lt;/p>
&lt;h2 id="admiral-to-the-rescue-admiral-is-that-automation">Admiral 的方案：Admiral 自动化&lt;/h2>
&lt;p>Admiral 是一个 Istio 控制平面的控制器。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:69.43866943866944%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2020/multi-cluster-mesh-automation/Istio_mesh_example_with_admiral.svg" title="Istio 和 Admiral 上的跨集群 workload 通信">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2020/multi-cluster-mesh-automation/Istio_mesh_example_with_admiral.svg" alt="使用 Admiral 在 Istio 多集群中调用 workload 的示例" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio 和 Admiral 上的跨集群 workload 通信&lt;/figcaption>
&lt;/figure>
&lt;p>Admiral 基于服务唯一标识符，为跨多个集群的 Istio 网格提供自动化配置，使其像单个网格一样工作，该标识符将多个集群上运行的 workload 和服务进行关联。它还为跨集群的 Istio 配置提供了自动同步功能。这同时减轻了开发人员和网格运维人员的负担，并有助于集群的扩展。&lt;/p>
&lt;h2 id="admiral-crd">Admiral CRD&lt;/h2>
&lt;h3 id="global-traffic-routing">全局流量路由&lt;/h3>
&lt;p>基于 Admiral 的全局流量策略 CRD，支付服务可以更新区域流量权重，而 Admiral 可以在使用支付服务的所有集群中更新 Istio 配置。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: admiral.io/v1alpha1
kind: GlobalTrafficPolicy
metadata:
name: payments-gtp
spec:
selector:
identity: payments
policy:
- dns: default.payments.global
lbType: 1
target:
- region: us-west-2/*
weight: 10
- region: us-east-2/*
weight: 90
&lt;/code>&lt;/pre>
&lt;p>在上面的示例中，支付服务 90% 的流量被路由到 &lt;code>us-east&lt;/code> 地区。该全局流量配置会自动转换为 Istio 配置，并在上下文中映射到 Kubernetes 集群中，从而为网格中的支付服务客户端启用多集群全局路由。&lt;/p>
&lt;p>全局流量路由依赖于 Istio 每个可用服务的本地负载均衡，这需要使用 Istio 1.5 或更高版本。&lt;/p>
&lt;h3 id="dependency">Dependency&lt;/h3>
&lt;p>Admiral &lt;code>Dependency&lt;/code> CRD 允许我们基于服务标识符指定服务的依赖关系。这优化了 Admiral 配置的传递，仅向运行服务的依赖客户端的必需集群传递生成的配置（而无需将其传递到所有集群）。Admiral 还会在客户端 workload 的命名空间中配置 &lt;code>并/或&lt;/code> 更新 Sidecar Istio CRD，以将 Istio 配置限制为仅依赖于它。我们使用记录在其他地方的 service-to-service 授权信息来生成此 &lt;code>Dependency&lt;/code> 记录，以供 Admiral 使用。&lt;/p>
&lt;p>订单服务依赖关系的示例：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: admiral.io/v1alpha1
kind: Dependency
metadata:
name: dependency
namespace: admiral
spec:
source: orders
identityLabel: identity
destinations:
- payments
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Dependency&lt;/code> 是可选的，没有服务的依赖关系，只是会导致该服务的 Istio 配置被推送到全部的集群。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>Admiral 提供了新的全局流量路由和唯一服务命名功能，致力于解决由&lt;a href="/v1.8/zh/docs/setup/install/multicluster/gateways/#deploy-the-Istio-control-plane-in-each-cluster">具有控制平面副本集的多集群部署&lt;/a>带来的挑战。它消除了集群之间手动配置同步的需求，并为每个集群生成上下文配置。这样或许就可以操作由许多 Kubernetes 集群组成的服务网格了。&lt;/p>
&lt;p>我们认为 Istio/Service Mesh 社区将从这种方法中受益，因此我们开源了 &lt;a href="https://github.com/istio-ecosystem/admiral">Admiral&lt;/a>，我们很高兴收到您的反馈和支持！&lt;/p></description><pubDate>Sun, 05 Jan 2020 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2020/multi-cluster-mesh-automation/</link><author>Anil Attuluri (Intuit), Jason Webb (Intuit)</author><guid isPermaLink="true">/v1.8/zh/blog/2020/multi-cluster-mesh-automation/</guid><category>traffic-management</category><category>automation</category><category>configuration</category><category>multicluster</category><category>multi-mesh</category><category>gateway</category><category>federated</category><category>globalidentifer</category></item><item><title>安全管理 Webhook</title><description>&lt;p>&lt;code>Istio&lt;/code> 有两个 &lt;code>webhook&lt;/code>，分别是 &lt;code>Galley&lt;/code> 和 &lt;code>sidecar injector&lt;/code>。
&lt;code>Galley&lt;/code> 负责验证 &lt;code>Kubernetes&lt;/code> 资源，&lt;code>sidecar injector&lt;/code> 负责将 &lt;code>sidecar&lt;/code> 中注入 &lt;code>Istio&lt;/code>&lt;/p>
&lt;p>默认情况下，&lt;code>Galley&lt;/code> 和 &lt;code>sidecar injector&lt;/code> 管理它们自己 &lt;code>Webhook&lt;/code> 的配置。如果出现漏洞（例如，缓冲区溢出）它们便会受到威胁，可能会带来一些安全隐患。所以，配置 &lt;code>Webhook&lt;/code> 是一项权限很高的操作，因为 &lt;code>Webhook&lt;/code> 会监控和更改所有 &lt;code>Kubernetes secrets&lt;/code>。&lt;/p>
&lt;p>在以下示例中，攻击者破坏了 &lt;code>Galley&lt;/code> 并修改了 &lt;code>Galley&lt;/code> 的 &lt;code>webhook&lt;/code> 配置，以便于窃听所有 &lt;code>Kubernetes&lt;/code> 机密（&lt;code>clientConfig&lt;/code> 攻击者对其进行了修改，将 &lt;code>secrets&lt;/code> 资源改变为攻击者自己所拥有的服务）。&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:44.37367303609342%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/webhook/example_attack.png" title="攻击示例">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/webhook/example_attack.png" alt="攻击示例" />
&lt;/a>
&lt;/div>
&lt;figcaption>攻击示例&lt;/figcaption>
&lt;/figure>
&lt;p>为了防止这种攻击，&lt;code>Istio&lt;/code> 1.4 引入了一项新功能，可以使用 &lt;code>istioctl&lt;/code> 更安全地管理 &lt;code>Webhook&lt;/code>：&lt;/p>
&lt;ol>
&lt;li>&lt;p>&lt;code>istioctl&lt;/code> 替代 &lt;code>Galley&lt;/code> 和 &lt;code>sidecar injector&lt;/code> 去管理 &lt;code>Webhook&lt;/code> 配置。
&lt;code>Galley&lt;/code> 和 &lt;code>sidecar injector&lt;/code> 已经被解除特殊权限，因此即便受到侵入，它们也无法更改 &lt;code>Webhook&lt;/code> 的配置。&lt;/p>&lt;/li>
&lt;li>&lt;p>在配置 &lt;code>Webhook&lt;/code> 前, &lt;code>istioctl&lt;/code> 将验证 &lt;code>Webhook&lt;/code> 服务器是否已启动和该 &lt;code>Webhook&lt;/code> 服务器使用的证书链是否有效。这样可以减少在服务器就绪之前或服务器证书失效时可能发生的错误。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>要尝试此新功能，请参阅 &lt;a href="https://archive.istio.io/1.4/zh/docs/tasks/security/webhook">Istio Webhook 管理内容&lt;/a>。&lt;/p></description><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/webhook/</link><author>Lei Tang (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/webhook/</guid><category>security</category><category>kubernetes</category><category>webhook</category></item><item><title>istioctl analyze 介绍</title><description>
&lt;p>Istio 1.4 引入了一个实验性的新工具，可以帮助分析和调试正在运行 Istio 的集群。&lt;/p>
&lt;p>&lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-experimental-analyze">&lt;code>istioctl analyze&lt;/code>&lt;/a> 是一个诊断工具，来发现 Istio 配置的潜在问题，也会给出一些改进配置的意见。
它可以针对一个正在运行的集群或者是一堆本地配置文件。
还可以是这两种方式的组合，让您在对集群应用更改之前发现问题。&lt;/p>
&lt;p>开始之前，先看看这里的&lt;a href="/v1.8/zh/docs/ops/diagnostic-tools/istioctl-analyze/">文档&lt;/a>。&lt;/p>
&lt;h2 id="designed-to-be-approachable-for-novice-users">专为新手用户设计&lt;/h2>
&lt;p>我们遵循的其中一个关键设计目标就是要非常容易使用，就是不需要传复杂参数而让命令又很有用。&lt;/p>
&lt;p>实际中，下面是这个工具要应对的一些场景：&lt;/p>
&lt;ul>
&lt;li>&lt;em>“集群有问题，但是不知该从何入手”&lt;/em>&lt;/li>
&lt;li>&lt;em>“运行起来没问题，但是不知道是否还有优化空间”&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>从这个意义上讲，它与某些更高级的诊断工具有很大的不同，后者适合以下场景（以 &lt;code>istioctl proxy-config&lt;/code> 为例）：&lt;/p>
&lt;ul>
&lt;li>&lt;em>“列出指定 pod 的 Envoy 配置，来看看有没有问题”&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>这对高级调试非常有用，但是这需要非常多的经验，你才能知道需要运行这条命令，以及在哪个 pod 上运行。&lt;/p>
&lt;p>因此，用一句话来说明 &lt;code>analyze&lt;/code> 就是：尽管运行！它非常安全，不用考虑，可能会有帮助，最坏的情况就是浪费你一分钟！&lt;/p>
&lt;h2 id="improving-this-tool-over-time">这个工具在不断改进中&lt;/h2>
&lt;p>在 Istio 1.4 中，&lt;code>analyze&lt;/code> 有一组可以检测很多常见文档的好分析器。但这只是开始，我们计划在后期每个版本中不断增加和优化分析器。&lt;/p>
&lt;p>事实上，我们欢迎 Istio 用户提建议。特别是遇到您认为可以用配置分析器检测的情况时，而 &lt;code>analyze&lt;/code> 没有正确标出来，请告诉我们。最好的方式就是&lt;a href="https://github.com/istio/istio/issues">在 GitHub 上建 issue&lt;/a>。&lt;/p></description><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/introducing-istioctl-analyze/</link><author>David Ebbo (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/introducing-istioctl-analyze/</guid><category>debugging</category><category>istioctl</category><category>configuration</category></item><item><title>Istio v1beta1 授权策略概述</title><description>
&lt;p>Istio 1.4 引入了 &lt;a href="/v1.8/zh/docs/reference/config/security/authorization-policy/">&lt;code>v1beta1&lt;/code> 授权策略&lt;/a>，这是对
以前 &lt;code>v1alpha1&lt;/code> 的基于角色的访问控制（RBAC）策略的重要更新。包括以下改进：&lt;/p>
&lt;ul>
&lt;li>符合 Istio 配置模型。&lt;/li>
&lt;li>通过简化 API 改善用户体验。&lt;/li>
&lt;li>支持更多用例（例如，Ingress/Egress 网关支持），而不会增加复杂性。&lt;/li>
&lt;/ul>
&lt;p>该 &lt;code>v1beta1&lt;/code> 策略不向后兼容，需要一次转换。Istio 提供了一个工具来自动执行此过程。
Istio 1.6 以后将不再支持先前的配置资源 &lt;code>ClusterRbacConfig&lt;/code>、&lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code>。&lt;/p>
&lt;p>本文描述了新的 &lt;code>v1beta1&lt;/code> 授权策略模型、设计目标和从 &lt;code>v1alpha1&lt;/code> RBAC 策略的迁移。
有关 &lt;code>v1beta1&lt;/code> 授权策略的详细说明，请参见 &lt;a href="/v1.8/zh/docs/concepts/security/#authorization">authorization concept&lt;/a> 页面。&lt;/p>
&lt;p>我们欢迎您在 &lt;a href="https://discuss.istio.io/c/security">discuss.istio.io&lt;/a> 上反馈有关 &lt;code>v1beta1&lt;/code> 授权策略的相关信息。&lt;/p>
&lt;h2 id="background">背景&lt;/h2>
&lt;p>迄今为止，Istio 提供了 RBAC 策略，以便使用 &lt;code>ClusterRbacConfig&lt;/code>、&lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code> 配置资源
对 &lt;span class="term" data-title="Service" data-body="&amp;lt;p&amp;gt;使用&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-name&amp;#34;&amp;gt;服务名称&amp;lt;/a&amp;gt;标识一组具有关联行为的服务&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;服务网格&amp;lt;/a&amp;gt;，
并使用这些名称应用 Istio 策略（例如负载均衡和路由）。
服务通常由一个或多个&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-endpoint&amp;#34;&amp;gt;服务 Endpoint&amp;lt;/a&amp;gt; 实现，并且或许包含多个
&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-version&amp;#34;&amp;gt;服务版本&amp;lt;/a&amp;gt;。&amp;lt;/p&amp;gt;
">服务&lt;/span> 实施访问控制。使用此 API，用户可以在网格级别、命名空间级别和服务级别强
制实施访问控制。与其他 RBAC 策略一样，Istio RBAC 使用相同的角色和绑定概念来授予身份权限。&lt;/p>
&lt;p>尽管 Istio RBAC 一直稳定可靠的工作着，但我们还是发现了许多改进空间。&lt;/p>
&lt;p>例如，用户错误地假定访问控制实施发生在服务级别，因为 &lt;code>ServiceRole&lt;/code> 使用服务指定在何处应用策略，但是，策略实际上应用于
&lt;span class="term" data-title="Workload" data-body="&amp;lt;p&amp;gt;&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#operator&amp;#34;&amp;gt;operators&amp;lt;/a&amp;gt; 部署的二进制文件，用于提供服务网格应用的一些功能。
工作负载有自己的名称，命名空间，和唯一的 id。
这些属性可以通过下面的&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#attribute&amp;#34;&amp;gt;属性&amp;lt;/a&amp;gt;被策略配置和遥测配置使用：&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;source.workload.name&amp;lt;/code&amp;gt;, &amp;lt;code&amp;gt;source.workload.namespace&amp;lt;/code&amp;gt;, &amp;lt;code&amp;gt;source.workload.uid&amp;lt;/code&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;code&amp;gt;destination.workload.name&amp;lt;/code&amp;gt;, &amp;lt;code&amp;gt;destination.workload.namespace&amp;lt;/code&amp;gt;, &amp;lt;code&amp;gt;destination.workload.uid&amp;lt;/code&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;p&amp;gt;在 Kubernetes 环境中，一个工作负载通常对应一个 Kubernetes deployment，
并且一个&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#workload-instance&amp;#34;&amp;gt;工作负载实例&amp;lt;/a&amp;gt;对应一个独立的被 deployment 管理的 &amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#pod&amp;#34;&amp;gt;pod&amp;lt;/a&amp;gt;。&amp;lt;/p&amp;gt;
">工作负载&lt;/span>，该服务仅用于查找相应的工作负载。当多个服务引用相同的工作负载时，
这种细微差别非常重要。如果两个服务引用相同的工作负载，则服务 A 的 &lt;code>ServiceRole&lt;/code> 也会影响服务 B，这可能会导致混淆和不
正确的配置。&lt;/p>
&lt;p>另一个示例是，由于需要深入了解三个相关资源，用户很难维护和管理 Istio RBAC 配置。&lt;/p>
&lt;h2 id="design-goals">设计目标&lt;/h2>
&lt;p>新的 &lt;code>v1beta1&lt;/code> 授权策略具有几个设计目标：&lt;/p>
&lt;ul>
&lt;li>&lt;p>与 &lt;a href="https://goo.gl/x3STjD">Istio 配置模型&lt;/a>保持一致，以便更清楚地了解策略目标。
配置模型提供统一的配置层次结构、解决方案和目标选择。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过简化 API 改善用户体验。管理一个包含所有访问控制规范的 CRD（自定义资源定义）比管理多个 CRD 更容易。&lt;/p>&lt;/li>
&lt;li>&lt;p>支持更多用例，而不会增加复杂性。例如，允许在 Ingress/Egress 网关上应用策略，以对进出网格的流量实施访问控制。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="authorization-policy">&lt;code>AuthorizationPolicy&lt;/code>&lt;/h2>
&lt;p>通过 &lt;a href="/v1.8/zh/docs/reference/config/security/authorization-policy/">&lt;code>AuthorizationPolicy&lt;/code> 自定义资源&lt;/a>启用对工作
负载的访问控制。本节介绍 &lt;code>v1beta1&lt;/code> 授权策略中的变化。&lt;/p>
&lt;p>&lt;code>AuthorizationPolicy&lt;/code> 包括 &lt;code>selector&lt;/code> 和一个 &lt;code>rule&lt;/code> 列表。&lt;code>selector&lt;/code> 指定应用策略的工作负载，&lt;code>rule&lt;/code> 列表指定工作
负载的详细访问控制规则。&lt;/p>
&lt;p>&lt;code>rule&lt;/code> 是累加的，这意味着如果任何 &lt;code>rule&lt;/code> 允许请求，则请求将被允许。每个 &lt;code>rule&lt;/code> 都包含 &lt;code>from&lt;/code>、&lt;code>to&lt;/code> 和 &lt;code>when&lt;/code> 的定义，
其指定了允许&lt;strong>谁&lt;/strong>在哪些&lt;strong>条件&lt;/strong>下执行哪些&lt;strong>操作&lt;/strong>。&lt;/p>
&lt;p>&lt;code>selector&lt;/code> 将替换 &lt;code>ClusterRbacConfig&lt;/code> 和 &lt;code>ServiceRole&lt;/code> 中的 &lt;code>services&lt;/code> 字段提供的功能。
&lt;code>rule&lt;/code> 将替换 &lt;code>ServiceRoleBinding&lt;/code> 和 &lt;code>ServiceRole&lt;/code> 中的其他字段。&lt;/p>
&lt;h3 id="example">示例&lt;/h3>
&lt;p>以下授权策略适用于 &lt;code>foo&lt;/code> 命名空间中含有 &lt;code>app: httpbin&lt;/code> 和 &lt;code>version: v1&lt;/code> 标签的工作负载：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: httpbin
namespace: foo
spec:
selector:
matchLabels:
app: httpbin
version: v1
rules:
- from:
- source:
principals: [&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;]
to:
- operation:
methods: [&amp;#34;GET&amp;#34;]
when:
- key: request.headers[version]
values: [&amp;#34;v1&amp;#34;, &amp;#34;v2&amp;#34;]
&lt;/code>&lt;/pre>
&lt;p>当来自 &lt;code>cluster.local/ns/default/sa/sleep&lt;/code> 的请求头中包含值为 &lt;code>v1&lt;/code> 或 &lt;code>v2&lt;/code> 的 &lt;code>version&lt;/code> 字段时，
该策略将允许其通过 &lt;code>GET&lt;/code> 请求访问工作负载。默认情况下，任何与策略不匹配的请求都将被拒绝。&lt;/p>
&lt;p>假设 &lt;code>httpbin&lt;/code> 服务定义为：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Service
metadata:
name: httpbin
namespace: foo
spec:
selector:
app: httpbin
version: v1
ports:
# omitted
&lt;/code>&lt;/pre>
&lt;p>如果要在 &lt;code>v1alpha1&lt;/code> 中实现相同的目的，您需要配置三个资源：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ClusterRbacConfig
metadata:
name: default
spec:
mode: &amp;#39;ON_WITH_INCLUSION&amp;#39;
inclusion:
services: [&amp;#34;httpbin.foo.svc.cluster.local&amp;#34;]
---
apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRole
metadata:
name: httpbin
namespace: foo
spec:
rules:
- services: [&amp;#34;httpbin.foo.svc.cluster.local&amp;#34;]
methods: [&amp;#34;GET&amp;#34;]
constraints:
- key: request.headers[version]
values: [&amp;#34;v1&amp;#34;, &amp;#34;v2&amp;#34;]
---
apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRoleBinding
metadata:
name: httpbin
namespace: foo
spec:
subjects:
- user: &amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;
roleRef:
kind: ServiceRole
name: &amp;#34;httpbin&amp;#34;
&lt;/code>&lt;/pre>
&lt;h3 id="workload-selector">工作负载选择器&lt;/h3>
&lt;p>&lt;code>v1beta1&lt;/code> 授权策略中的一个主要更改是，它现在使用工作负载选择器指定应该在何处应用策略。
这与 &lt;code>Gateway&lt;/code>、&lt;code>Sidecar&lt;/code> 和 &lt;code>EnvoyFilter&lt;/code> 配置中使用的工作负载选择器相同。&lt;/p>
&lt;p>工作负载选择器显式的表明，策略是在工作负载（而不是服务）上应用和强制执行的。
如果策略适用于由多个不同服务使用的工作负载，则同一策略将影响所有不同服务的流量。&lt;/p>
&lt;p>只需将 &lt;code>selector&lt;/code> 留空，即可将策略应用于命名空间中的所有工作负载。以下策略适用于命名空间 &lt;code>bar&lt;/code> 中的所有工作负载：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: policy
namespace: bar
spec:
rules:
# omitted
&lt;/code>&lt;/pre>
&lt;h3 id="root-namespace">根命名空间&lt;/h3>
&lt;p>根命名空间中的策略应用于网格中每个命名空间中的所有工作负载。
根命名空间可在 &lt;a href="/v1.8/zh/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig">&lt;code>MeshConfig&lt;/code>&lt;/a> 中配置，
其默认值为 &lt;code>istio-system&lt;/code>。&lt;/p>
&lt;p>例如，您在 &lt;code>istio-system&lt;/code> 命名空间中安装了 Istio，并在 &lt;code>default&lt;/code> 和 &lt;code>bookinfo&lt;/code> 命名空间中部署了工作负载。
把根命名空间从默认值更改为 &lt;code>istio-config&lt;/code> 后，以下策略将应用于每个命名空间中的工作负载，
包括 &lt;code>default&lt;/code>、&lt;code>bookinfo&lt;/code> 和 &lt;code>istio-system&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: policy
namespace: istio-config
spec:
rules:
# omitted
&lt;/code>&lt;/pre>
&lt;h3 id="ingress-egress-gateway-support">Ingress/Egress 网关支持&lt;/h3>
&lt;p>&lt;code>v1beta1&lt;/code> 授权策略也可以应用于 ingress/egress 网关，以对进入或离开网格的流量实施访问控制，
您只需更改 &lt;code>selector&lt;/code> 即可选择入口或出口工作负载。&lt;/p>
&lt;p>以下策略适用于具有 &lt;code>app: istio-ingressgateway&lt;/code> 标签的工作负载：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: ingress
namespace: istio-system
spec:
selector:
matchLabels:
app: istio-ingressgateway
rules:
# omitted
&lt;/code>&lt;/pre>
&lt;p>请注意，授权策略仅适用于与策略相同的命名空间中的工作负载，除非在根命名空间中应用该策略：&lt;/p>
&lt;ul>
&lt;li>&lt;p>如果不更改根命名空间的默认值（即 &lt;code>istio-system&lt;/code>），上述策略将应用于&lt;strong>每个&lt;/strong>命名空间中
含有 &lt;code>app: istio-ingressgateway&lt;/code> 标签的工作负载。&lt;/p>&lt;/li>
&lt;li>&lt;p>如果将根命名空间更改为其他值，则上述策略将&lt;strong>仅适用&lt;/strong>于 &lt;code>istio-system&lt;/code> 命名空间中
含有 &lt;code>app: istio-ingressgateway&lt;/code> 标签的工作负载。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="comparison">比较&lt;/h3>
&lt;p>下表突出显示了旧的 &lt;code>v1alpha1&lt;/code> RBAC 策略和新的 &lt;code>v1beta1&lt;/code> 授权策略之间的主要区别。&lt;/p>
&lt;h4 id="feature">特性&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>特性&lt;/th>
&lt;th>&lt;code>v1alpha1&lt;/code> RBAC 策略&lt;/th>
&lt;th>&lt;code>v1beta1&lt;/code> 授权策略&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>API 稳定性&lt;/td>
&lt;td>&lt;code>alpha&lt;/code>：&lt;strong>不&lt;/strong> 向后兼容&lt;/td>
&lt;td>&lt;code>beta&lt;/code>：&lt;strong>确保&lt;/strong>向后兼容&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CRD 数量&lt;/td>
&lt;td>三个：&lt;code>ClusterRbacConfig&lt;/code>、&lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code>&lt;/td>
&lt;td>一个：&lt;code>AuthorizationPolicy&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>策略目标&lt;/td>
&lt;td>&lt;strong>service&lt;/strong>&lt;/td>
&lt;td>&lt;strong>workload&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>默认拒绝行为&lt;/td>
&lt;td>通过&lt;strong>显式&lt;/strong>的配置 &lt;code>ClusterRbacConfig&lt;/code> 启用&lt;/td>
&lt;td>&lt;strong>隐式&lt;/strong>的通过 &lt;code>AuthorizationPolicy&lt;/code> 启用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ingress/Egress 网关支持&lt;/td>
&lt;td>不支持&lt;/td>
&lt;td>支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>策略中的 &lt;code>&amp;quot;*&amp;quot;&lt;/code> 值&lt;/td>
&lt;td>匹配所有内容（空和非空）&lt;/td>
&lt;td>仅匹配非空内容&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>下表显示了 &lt;code>v1alpha1&lt;/code> 和 &lt;code>v1beta1&lt;/code> API 之间的关系。&lt;/p>
&lt;h4 id="clusterrbacconfig">&lt;code>ClusterRbacConfig&lt;/code>&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;code>ClusterRbacConfig.Mode&lt;/code>&lt;/th>
&lt;th>&lt;code>AuthorizationPolicy&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>OFF&lt;/code>&lt;/td>
&lt;td>未应用策略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ON&lt;/code>&lt;/td>
&lt;td>在根命名空间中应用的全部拒绝策略&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ON_WITH_INCLUSION&lt;/code>&lt;/td>
&lt;td>策略应用于 &lt;code>ClusterRbacConfig&lt;/code> 中包含的命名空间或工作负载&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>ON_WITH_EXCLUSION&lt;/code>&lt;/td>
&lt;td>策略应用于 &lt;code>ClusterRbacConfig&lt;/code> 中包含的命名空间或工作负载&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="servicerole">&lt;code>ServiceRole&lt;/code>&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;code>ServiceRole&lt;/code>&lt;/th>
&lt;th>&lt;code>AuthorizationPolicy&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>services&lt;/code>&lt;/td>
&lt;td>&lt;code>selector&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>paths&lt;/code>&lt;/td>
&lt;td>&lt;code>to&lt;/code> 字段下的 &lt;code>paths&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>methods&lt;/code>&lt;/td>
&lt;td>&lt;code>to&lt;/code> 字段下的 &lt;code>methods&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>destination.ip&lt;/code>&lt;/td>
&lt;td>不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>destination.port&lt;/code>&lt;/td>
&lt;td>&lt;code>to&lt;/code> 字段下的 &lt;code>ports&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>destination.labels&lt;/code>&lt;/td>
&lt;td>&lt;code>selector&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>destination.namespace&lt;/code>&lt;/td>
&lt;td>替换为策略的命名空间，即元数据中的 &lt;code>namespace&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>destination.user&lt;/code>&lt;/td>
&lt;td>不支持&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>experimental.envoy.filters&lt;/code>&lt;/td>
&lt;td>&lt;code>when&lt;/code> 字段下的 &lt;code>experimental.envoy.filters&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>在约束中的 &lt;code>request.headers&lt;/code>&lt;/td>
&lt;td>&lt;code>when&lt;/code> 字段下的 &lt;code>request.headers&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="servicerolebinding">&lt;code>ServiceRoleBinding&lt;/code>&lt;/h4>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;code>ServiceRoleBinding&lt;/code>&lt;/th>
&lt;th>&lt;code>AuthorizationPolicy&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>user&lt;/code>&lt;/td>
&lt;td>&lt;code>from&lt;/code> 字段下的 &lt;code>principals&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>group&lt;/code>&lt;/td>
&lt;td>&lt;code>to&lt;/code> 字段下的 &lt;code>paths&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>source.ip&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>from&lt;/code> 字段下的 &lt;code>ipBlocks&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>source.namespace&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>from&lt;/code> 字段下的 &lt;code>namespaces&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>source.principal&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>from&lt;/code> 字段下的 &lt;code>principals&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>request.headers&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>when&lt;/code> 字段下的 &lt;code>request.headers&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>request.auth.principal&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>from&lt;/code> 字段下的 &lt;code>requestPrincipals&lt;/code> 或 &lt;code>when&lt;/code> 字段下的 &lt;code>request.auth.principal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>request.auth.audiences&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>when&lt;/code> 字段下的 &lt;code>request.auth.audiences&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>request.auth.presenter&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>when&lt;/code> 字段下的 &lt;code>request.auth.presenter&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>request.auth.claims&lt;/code> 属性&lt;/td>
&lt;td>&lt;code>when&lt;/code> 字段下的 &lt;code>request.auth.claims&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>除了所有差异之外，与 &lt;code>v1alpha1&lt;/code> 类似，&lt;code>v1beta1&lt;/code> 策略也由 Envoy 引擎强制执行，并支持同样的身份验证（双向 TLS 或 JWT）、条件和其他基元（如 IP、端口等）。&lt;/p>
&lt;h2 id="future-of-the-v1alpha1-policy">未来的 &lt;code>v1alpha1&lt;/code> 策略&lt;/h2>
&lt;p>&lt;code>v1alpha1&lt;/code> RBAC 策略（&lt;code>ClusterRbacConfig&lt;/code>、&lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code>）将被 &lt;code>v1beta1&lt;/code> 授权策略替代并弃用。&lt;/p>
&lt;p>Istio 1.4 继续支持 &lt;code>v1alpha1&lt;/code> RBAC 策略，以便使您有足够的时间完成迁移。&lt;/p>
&lt;h2 id="migration-from-the-v1alpha1-policy">从 &lt;code>v1alpha1&lt;/code> 策略迁移&lt;/h2>
&lt;p>对于给定的工作负载，Istio 仅支持两个版本之一：&lt;/p>
&lt;ul>
&lt;li>如果仅为工作负载配置 &lt;code>v1beta1&lt;/code> 策略，则 &lt;code>v1beta1&lt;/code> 策略生效。&lt;/li>
&lt;li>如果仅为工作负载配置 &lt;code>v1alpha1&lt;/code> 策略，则 &lt;code>v1alpha1&lt;/code> 策略生效。&lt;/li>
&lt;li>如果同时为工作负载配置 &lt;code>v1beta1&lt;/code> 和 &lt;code>v1alpha1&lt;/code> 策略，则仅 &lt;code>v1beta1&lt;/code> 策略生效，&lt;code>v1alpha1&lt;/code> 策略将被忽略。&lt;/li>
&lt;/ul>
&lt;h3 id="general-guideline">一般准则&lt;/h3>
&lt;div>
&lt;aside class="callout warning">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-warning"/>&lt;/svg>
&lt;/div>
&lt;div class="content">迁移时，对给定工作负载使用 &lt;code>v1beta1&lt;/code> 策略时，请确保新的 &lt;code>v1beta1&lt;/code> 策略涵盖应用于工作负载的所有现有 &lt;code>v1alpha1&lt;/code> 策略，
因为在应用 &lt;code>v1beta1&lt;/code> 后，将忽略应用于工作负载的 &lt;code>v1alpha1&lt;/code> 策略。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>迁移到 &lt;code>v1beta1&lt;/code> 策略的典型流程是首先检查 &lt;code>ClusterRbacConfig&lt;/code>，以确定哪些命名空间或服务启用了 RBAC。&lt;/p>
&lt;p>对于启用了 RBAC 的每个服务：&lt;/p>
&lt;ol>
&lt;li>从服务定义中获取工作负载选择器。&lt;/li>
&lt;li>使用工作负载选择器创建一个 &lt;code>v1beta1&lt;/code> 策略。&lt;/li>
&lt;li>根据应用与服务的每个 &lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code> 更新 &lt;code>v1beta1&lt;/code> 策略。&lt;/li>
&lt;li>应用该 &lt;code>v1beta1&lt;/code> 策略并监视流量，以确保该策略按预期工作。&lt;/li>
&lt;li>对启用了 RBAC 的下一个服务重复该过程。&lt;/li>
&lt;/ol>
&lt;p>对于启用了 RBAC 的每个命名空间：&lt;/p>
&lt;ol>
&lt;li>把拒绝所有流量的 &lt;code>v1beta1&lt;/code> 策略应用到给定的命名空间。&lt;/li>
&lt;/ol>
&lt;h3 id="migration-example">迁移示例&lt;/h3>
&lt;p>假设在 &lt;code>foo&lt;/code> 命名空间中您有以下 &lt;code>v1alpha1&lt;/code> 策略用于 &lt;code>httpbin&lt;/code> 服务：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ClusterRbacConfig
metadata:
name: default
spec:
mode: &amp;#39;ON_WITH_INCLUSION&amp;#39;
inclusion:
namespaces: [&amp;#34;foo&amp;#34;]
---
apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRole
metadata:
name: httpbin
namespace: foo
spec:
rules:
- services: [&amp;#34;httpbin.foo.svc.cluster.local&amp;#34;]
methods: [&amp;#34;GET&amp;#34;]
---
apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRoleBinding
metadata:
name: httpbin
namespace: foo
spec:
subjects:
- user: &amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;
roleRef:
kind: ServiceRole
name: &amp;#34;httpbin&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>以下述方式将上面的策略迁移到 &lt;code>v1beta1&lt;/code>：&lt;/p>
&lt;ol>
&lt;li>&lt;p>假设 &lt;code>httpbin&lt;/code> 服务具有以下工作负载选择器：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >selector:
app: httpbin
version: v1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>通过工作负载创建 &lt;code>v1beta1&lt;/code> 策略：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: httpbin
namespace: foo
spec:
selector:
matchLabels:
app: httpbin
version: v1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>根据服务所应用的 &lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code> 更新 &lt;code>v1beta1&lt;/code> 策略：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: httpbin
namespace: foo
spec:
selector:
matchLabels:
app: httpbin
version: v1
rules:
- from:
- source:
principals: [&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;]
to:
- operation:
methods: [&amp;#34;GET&amp;#34;]
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>应用 &lt;code>v1beta1&lt;/code> 策略并监视流量，以确保该策略按预期工作。&lt;/p>&lt;/li>
&lt;li>&lt;p>应用下面的 &lt;code>v1beta1&lt;/code> 策略，该策略拒绝所有到达 &lt;code>foo&lt;/code> 命名空间的流量，因为命名空间 &lt;code>foo&lt;/code> 启用了 RBAC：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
name: deny-all
namespace: foo
spec:
{}
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>确保 &lt;code>v1beta1&lt;/code> 策略按预期工作，然后可以从集群中删除 &lt;code>v1alpha1&lt;/code> 策略。&lt;/p>
&lt;h3 id="automation-of-the-migration">自动化迁移&lt;/h3>
&lt;p>为了帮助简化迁移，可通 &lt;code>istioctl experimental authz convert&lt;/code> 转换命令自动将 &lt;code>v1alpha1&lt;/code> 策略
转换为 &lt;code>v1beta1&lt;/code> 策略。&lt;/p>
&lt;p>迁移时您可以考虑该命令，但它在 Istio 1.4 中是实验性的，并且截至此博客文章发布，其还不能够完整支持 v1alpha1 的全部语义。&lt;/p>
&lt;p>支持完整 v1alpha1 语义的命令预计在 Istio 1.4 之后的修补程序版本中发布。&lt;/p></description><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/v1beta1-authorization-policy/</link><author>Yangmin Zhu (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/v1beta1-authorization-policy/</guid><category>security</category><category>RBAC</category><category>access control</category><category>authorization</category></item><item><title>Istio Operator 简介</title><description>
&lt;p>Kubernetes &lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/operator/">operator&lt;/a> 提供了一种将人类运维知识编码到软件中的模式，是一种简化软件基础结构组件管理的流行方法。Istio 是自动 operator 的理想选择，因为它的管理具有挑战性。&lt;/p>
&lt;p>到目前为止，&lt;a href="https://github.com/helm/helm">Helm&lt;/a> 一直是安装和升级 Istio 的主要工具。Istio 1.4 引入了一种新的&lt;a href="/v1.8/zh/docs/setup/install/istioctl/">使用istioctl安装&lt;/a>方法。这种新的安装方法建立在 Helm 的优势之上，并添加了以下内容:&lt;/p>
&lt;ul>
&lt;li>用户只需要安装一个工具：&lt;code>istioctl&lt;/code>&lt;/li>
&lt;li>验证所有 API 字段&lt;/li>
&lt;li>不在 API 中的小型定制不需要更改 chart 或 API&lt;/li>
&lt;li>版本特定的升级 hook 可以很容易和稳健地实现&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="/v1.8/zh/docs/setup/install/helm/">Helm 安装&lt;/a>方法正在弃用中。从 Istio 1.4 升级到一个默认没有安装 Helm 的版本也会被一个新的 &lt;a href="/v1.8/zh/docs/setup/upgrade/istioctl-upgrade/">istioctl 升级特性&lt;/a>所取代。&lt;/p>
&lt;p>新的 &lt;code>istioctl&lt;/code> 安装命令使用一个&lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">自定义资源&lt;/a>来配置安装。自定义资源是新的 Istio operator 实现的一部分，该实现旨在简化安装、升级和复杂的 Istio 配置更改等常见管理任务。安装和升级的验证和检查与工具紧密集成，以防止常见错误并简化故障排除。&lt;/p>
&lt;h2 id="the-Operator-API">Operator API&lt;/h2>
&lt;p>每个 operator 实现都需要一个&lt;a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/#customresourcedefinitions">自定义资源定义（CRD）&lt;/a> 来定义它的自定义资源，即它的 API。Istio 的 operator API 由 &lt;a href="/v1.8/zh/docs/reference/config/istio.operator.v1alpha12.pb/">&lt;code>IstioControlPlane&lt;/code> CRD&lt;/a> 定义，它是由一个 &lt;a href="https://github.com/istio/operator/blob/release-1.4/pkg/apis/istio/v1alpha2/istiocontrolplane_types.proto">&lt;code>IstioControlPlane&lt;/code> 原型&lt;/a>生成的。API 支持所有 Istio 当前的&lt;a href="/v1.8/zh/docs/setup/additional-setup/config-profiles/">配置文件&lt;/a> ，通过使用一个字段来选择 profile。例如，下面的 &lt;code>IstioControlPlane&lt;/code> 资源使用 &lt;code>demo&lt;/code> profile 配置 Istio：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: install.istio.io/v1alpha2
kind: IstioControlPlane
metadata:
namespace: istio-operator
name: example-istiocontrolplane
spec:
profile: demo
&lt;/code>&lt;/pre>
&lt;p>然后可以使用其他设置来自定义配置。例如，禁用遥测：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: install.istio.io/v1alpha2
kind: IstioControlPlane
metadata:
namespace: istio-operator
name: example-istiocontrolplane
spec:
profile: demo
telemetry:
enabled: false
&lt;/code>&lt;/pre>
&lt;h2 id="install-with-Istio">通过istioctl安装&lt;/h2>
&lt;p>使用 Istio operator API 的推荐方法是通过一组新的 &lt;code>istioctl&lt;/code> 命令。例如，要在集群中安装 Istio：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl manifest apply -f &amp;lt;your-istiocontrolplane-customresource&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>通过编辑配置文件并再次执行 &lt;code>istioctl manifest apply&lt;/code> 来更改安装配置。&lt;/p>
&lt;p>升级到新版本的 Istio：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl x upgrade -f &amp;lt;your-istiocontrolplane-config-changes&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>除了在 &lt;code>IstioControlPlane&lt;/code> 资源中指定完整的配置外，&lt;code>istioctl&lt;/code> 命令还可以使用 &lt;code>--set&lt;/code> 标志传递单独的设置:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl manifest apply --set telemetry.enabled=false
&lt;/code>&lt;/pre>
&lt;p>还有许多其他 &lt;code>istioctl&lt;/code> 命令，例如，它们可以帮助您列出、显示和比较配置 profile 和 manifest。&lt;/p>
&lt;p>更多信息请参考 Istio &lt;a href="/v1.8/zh/docs/setup/install/istioctl">安装说明&lt;/a>。&lt;/p>
&lt;h2 id="Istio-controller-alpha">Istio Controller (alpha)&lt;/h2>
&lt;p>Operator 实现使用 Kubernetes controller 来持续监控它们的自定义资源并应用相应的配置更改。Istio controller 监控一个 &lt;code>IstioControlPlane&lt;/code> 资源，并通过更新相应集群中的 Istio 安装配置来响应更改。&lt;/p>
&lt;p>在 1.4 版中，Istio controller 处于开发的 alpha 阶段，没有完全集成到 &lt;code>istioctl&lt;/code> 中。但是，可以使用 &lt;code>kubectl&lt;/code> 命令来做&lt;a href="/v1.8/zh/docs/setup/install/standalone-operator/">实验&lt;/a>。例如，要将 controller 和默认版本的 Istio 安装到集群中，请运行以下命令:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f https://&amp;lt;repo URL&amp;gt;/operator.yaml
$ kubectl apply -f https://&amp;lt;repo URL&amp;gt;/default-cr.yaml
&lt;/code>&lt;/pre>
&lt;p>然后你可以对 Istio 的安装配置进行修改:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl edit istiocontrolplane example-istiocontrolplane -n istio-system
&lt;/code>&lt;/pre>
&lt;p>一旦资源更新，controller 将检测到这些变化，并相应地更新 Istio 安装。&lt;/p>
&lt;p>Operator controller 和 &lt;code>istioctl&lt;/code> 命令共享相同的实现。重要的区别在于其执行上下文。对于 &lt;code>istioctl&lt;/code>，操作在管理用户的命令执行和安全上下文中运行。对于 controller，集群中的一个 pod 在其安全上下文中运行代码。在这两种情况下，都根据一个 schema 来验证配置，并执行相同的正确性检查。&lt;/p>
&lt;h2 id="migration-from-helm">从 Helm 迁移&lt;/h2>
&lt;p>为了方便从使用 Helm 过渡，&lt;code>istioctl&lt;/code> 和 controller 支持对 Helm 安装 API 的透传访问。&lt;/p>
&lt;p>您可以使用 &lt;code>istioctl --set&lt;/code> 来传递 Helm 配置选项，方法是将字符串 &lt;code>values.&lt;/code> 放在配置选项前面。例如，对于这个 Helm 命令：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ helm template ... --set global.mtls.enabled=true
&lt;/code>&lt;/pre>
&lt;p>您可以使用 &lt;code>istioctl&lt;/code> 这个命令：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl manifest generate ... --set values.global.mtls.enabled=true
&lt;/code>&lt;/pre>
&lt;p>你也可以在一个 &lt;code>IstioControlPlane&lt;/code> 自定义资源中设置 Helm 配置值。参见&lt;a href="/v1.8/zh/docs/setup/install/istioctl/#customize-Istio-settings-using-the-helm-API">使用 Helm 自定义 Istio 设置&lt;/a>。&lt;/p>
&lt;p>另一个可以帮助从 Helm 迁移的特性是这个 alpha 命令：&lt;a href="/v1.8/zh/docs/reference/commands/istioctl/#istioctl-manifest-migrate">istioctl manifest migrate&lt;/a>。此命令可用于将 Helm &lt;code>values.yaml&lt;/code> 文件自动转换为相应的 &lt;code>IstioControlPlane&lt;/code> 配置。&lt;/p>
&lt;h2 id="implementation">实现&lt;/h2>
&lt;p>已经创建了几个框架，通过为部分或所有组件生成存根来帮助实现 operator。Istio operator 是在 &lt;a href="https://github.com/kubernetes-sigs/kubebuilder">kubebuilder&lt;/a> 和 &lt;a href="https://github.com/operator-framework">operator framework&lt;/a> 的帮助下创建的。Istio 的安装现在使用 proto 来描述 API，这样就可以通过 schema 对执行运行时进行验证。&lt;/p>
&lt;p>有关实现的更多信息可以在 &lt;a href="https://github.com/istio/operator">Istio operator 仓库&lt;/a>中的 README 和 ARCHITECTURE 文档中找到。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>从 Istio 1.4 开始，Helm 安装将被新的 &lt;code>istioctl&lt;/code> 命令所取代，该命令使用新的 operator 自定义资源定义，&lt;code>IstioControlPlane&lt;/code>，作为配置 API。一个 alpha controller 也被提供用于 operator 的早期实验。&lt;/p>
&lt;p>新的 &lt;code>istioctl&lt;/code> 命令和 operator controller 都会验证配置 schema，并执行安装更改或升级的一系列检查。这些检查与工具紧密集成，以防止常见错误并简化故障排除。&lt;/p>
&lt;p>Istio 维护者们期望这种新方法能够改善安装和升级期间的用户体验，更好地稳定安装 API，帮助用户更好地管理和监控他们的 Istio 安装。&lt;/p>
&lt;p>我们欢迎您在 &lt;a href="https://discuss.istio.io/">discuss.istio.io&lt;/a> 上对新的安装方法提出反馈。&lt;/p></description><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/introducing-istio-operator/</link><author>Martin Ostrowski (Google), Frank Budinsky (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/introducing-istio-operator/</guid><category>install</category><category>configuration</category><category>istioctl</category><category>operator</category></item><item><title>Istio client-go 发布公告</title><description>
&lt;p>我们很高兴地宣布 &lt;a href="https://github.com/istio/client-go">Istio client go&lt;/a> 的第一个版本发布了，该存储库使开发人员能够在 &lt;code>Kubernetes&lt;/code> 环境中访问 &lt;code>Istio API&lt;/code> 。在此存储库中的 &lt;code>Kubernetes&lt;/code> 程序和客户端使开发人员可以轻松地为所有 &lt;code>Istio&lt;/code> 客户端自定义的资源 &lt;code>(CRDs)&lt;/code> 创建，读取，更新和删除 &lt;code>(CRUD)&lt;/code>。&lt;/p>
&lt;p>这是许多 Istio 用户强烈要求的功能，从 &lt;a href="https://github.com/aspenmesh/istio-client-go">Aspen Mesh&lt;/a>
和 &lt;a href="https://github.com/knative/pkg">Knative project&lt;/a> 项目对客户端产生的功能请求中可以明显地看出这一点。如果您正在使用上述客户端之一，则可以像如下这样轻松地切换到 &lt;a href="https://github.com/istio/client-go">Istio client go&lt;/a>：&lt;/p>
&lt;pre>&lt;code class='language-go' data-expandlinks='true' data-repo='istio' >import (
...
- versionedclient &amp;#34;github.com/aspenmesh/istio-client-go/pkg/client/clientset/versioned&amp;#34;
+ versionedclient &amp;#34;istio.io/client-go/pkg/clientset/versioned&amp;#34;
)
&lt;/code>&lt;/pre>
&lt;p>由于生成的客户端在功能上是等效的，因此使用新的 &lt;code>istio-client-go&lt;/code> 也不会有什么问题。&lt;/p>
&lt;h2 id="how-to-use-client-go">如何使用客户端&lt;/h2>
&lt;p>&lt;a href="https://github.com/istio/client-go">Istio client go&lt;/a> 存储库遵循与 &lt;a href="https://github.com/istio/api">Istio API&lt;/a> 存储库 相同的分支策略，因为客户端存储库取决于 &lt;code>API&lt;/code> 定义。如果要使用稳定的客户端，则可以在 &lt;a href="https://github.com/istio/client-go">client go&lt;/a> 存储库中使用发行版分支或标记的版本。使用客户端与使用 &lt;a href="https://github.com/kubernetes/client-go">Kubernetes client go&lt;/a> 非常相似，这是一个使用客户端列出命名空间中所有 &lt;a href="/v1.8/zh/docs/reference/config/networking/virtual-service">Istio
virtual services&lt;/a> 的简单示例：&lt;/p>
&lt;pre>&lt;code class='language-go' data-expandlinks='true' data-repo='istio' >package main
import (
&amp;#34;log&amp;#34;
&amp;#34;os&amp;#34;
metav1 &amp;#34;k8s.io/apimachinery/pkg/apis/meta/v1&amp;#34;
&amp;#34;k8s.io/client-go/tools/clientcmd&amp;#34;
versionedclient &amp;#34;istio.io/client-go/pkg/clientset/versioned&amp;#34;
)
func main() {
kubeconfig := os.Getenv(&amp;#34;KUBECONFIG&amp;#34;)
namespace := os.Getenv(&amp;#34;NAMESPACE&amp;#34;)
if len(kubeconfig) == 0 || len(namespace) == 0 {
log.Fatalf(&amp;#34;Environment variables KUBECONFIG and NAMESPACE need to be set&amp;#34;)
}
restConfig, err := clientcmd.BuildConfigFromFlags(&amp;#34;&amp;#34;, kubeconfig)
if err != nil {
log.Fatalf(&amp;#34;Failed to create k8s rest client: %s&amp;#34;, err)
}
ic, err := versionedclient.NewForConfig(restConfig)
if err != nil {
log.Fatalf(&amp;#34;Failed to create istio client: %s&amp;#34;, err)
}
// Print all VirtualServices
vsList, err := ic.NetworkingV1alpha3().VirtualServices(namespace).List(metav1.ListOptions{})
if err != nil {
log.Fatalf(&amp;#34;Failed to get VirtualService in %s namespace: %s&amp;#34;, namespace, err)
}
for i := range vsList.Items {
vs := vsList.Items[i]
log.Printf(&amp;#34;Index: %d VirtualService Hosts: %+v\n&amp;#34;, i, vs.Spec.GetHosts())
}
}
&lt;/code>&lt;/pre>
&lt;p>您可以在&lt;a href="https://github.com/istio/client-go/blob/release-1.8/cmd/example/client.go">这里&lt;/a>找到更详尽的示例。&lt;/p>
&lt;h2 id="useful-tools-created-for-generating-Istio-client-go">为生成 Istio client go 而创建的工具&lt;/h2>
&lt;p>如果您想知道为什么花费大量时间也很难生成此客户端，本小节将对此进行说明。在 &lt;code>Istio&lt;/code> 中，我们使用 &lt;a href="https://developers.google.com/protocol-buffers">protobuf&lt;/a> 规范编写 &lt;code>API&lt;/code>，然后使用 &lt;code>protobuf&lt;/code> 工具链将其转换为 &lt;code>Go&lt;/code> 定义。如果尝试从 &lt;code>protobuf&lt;/code> 的 &lt;code>API&lt;/code> 生成 &lt;code>Kubernetes&lt;/code> 客户端，可能会面临三个主要的挑战：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>创建 Kubernetes 装饰器类型&lt;/strong> - Kubernetes &lt;a href="https://github.com/kubernetes/code-generator/tree/master/cmd/client-gen">客户端生成库&lt;/a>
仅适用于遵循 &lt;code>Kubernetes&lt;/code> 对象规范的 &lt;code>Go&lt;/code> 对象，例如：&lt;a href="https://github.com/istio/client-go/blob/release-1.8/pkg/apis/authentication/v1alpha1/types.gen.go">Authentication Policy Kubernetes Wrappers&lt;/a>。这意味着对于需要程序访问的每个 API，您都需要创建这些装饰器。此外，每个 &lt;code>CRD&lt;/code> 组，版本和种类都需要大量的样板，需要用客户端代码生成。为了自动化该过程，我们创建了一个 &lt;a href="https://github.com/istio/tools/tree/master/cmd/kubetype-gen">Kubernetes type
generator&lt;/a> 工具，可以基于注释去自动创建 &lt;code>Kubernetes&lt;/code>类型。该工具的注释和各种可用选项在 &lt;a href="https://github.com/istio/tools/blob/master/cmd/kubetype-gen/README.md">README&lt;/a> 中进行了说明。请注意，如果您使用 &lt;code>protobuf&lt;/code> 工具生成 &lt;code>Go&lt;/code> 类型，则需要将这些注释添加到 &lt;code>proto&lt;/code> 文件中，以便注释出现在生成的 &lt;code>Go&lt;/code> 文件中，然后供该工具使用。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>生成 deep copy 方法&lt;/strong> - 在 &lt;code>Kubernetes&lt;/code> 客户端机制中，如果您想对从客户端集返回的任何对象进行修改，则需要创建该对象的副本以防止直接修改缓存中的对象。为了不直接修改缓存中的对象，我们一般是在所有嵌套类型上创建一个 &lt;code>deep copy&lt;/code> 方法。我们开发了一个 &lt;a href="https://github.com/istio/tools/tree/master/cmd/protoc-gen-deepcopy">protoc deep copy
generator&lt;/a> 工具 ，该工具是一个 &lt;code>protoc&lt;/code> 插件，可以使用 &lt;a href="https://godoc.org/github.com/golang/protobuf/proto#Clone">Proto
Clone&lt;/a> 库上的注释自动创建 &lt;code>deepcopy&lt;/code> 方法。这是一个生成了 &lt;code>deepcopy&lt;/code> 方法的&lt;a href="https://github.com/istio/api/blob/release-1.8/authentication/v1alpha1/policy_deepcopy.gen.go">示例&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>类型和 JSON 的互相转换&lt;/strong> - 对于从 &lt;code>proto&lt;/code> 定义生成的类型，使用默认的 &lt;code>Go JSON&lt;/code> 编码器或解码器通常会出现问题，因为像 &lt;code>protobuf&lt;/code> 的 &lt;code>oneof&lt;/code> 这类字段需要进行特殊处理。另外，名称中带有下划线的任何 &lt;code>Proto&lt;/code> 字段都可以序列化或反序列化为不同的字段名称，具体取决于编码器/解码器，因为 &lt;code>Go&lt;/code> 结构体的标记方式&lt;a href="https://github.com/istio/istio/issues/17600">不同&lt;/a>。始终建议使用 &lt;code>protobuf&lt;/code> 原语对 &lt;code>JSON&lt;/code> 进行序列化或反序列化，而不是依赖默认的 &lt;code>Go&lt;/code> 库。我们创建了一个 &lt;a href="https://github.com/istio/tools/tree/master/cmd/protoc-gen-jsonshim">protoc JSON shim&lt;/a> 工具，它是一个 &lt;code>protoc&lt;/code> 插件，可以为从 &lt;code>Proto&lt;/code> 定义所有 &lt;code>Go&lt;/code> 类型自动创建的 &lt;code>Marshalers&lt;/code> 或 &lt;code>Unmarshalers&lt;/code>。这是用此工具生成代码的一个&lt;a href="https://github.com/istio/api/blob/release-1.8/authentication/v1alpha1/policy_json.gen.go">示例&lt;/a>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>我们希望新发布的客户端使用户能够为 &lt;code>Istio API&lt;/code> 创建更多的 &lt;code>integrations&lt;/code> 和 &lt;code>controllers&lt;/code>，并且开发人员可以使用上述工具从 &lt;code>Proto API&lt;/code> 生成 &lt;code>Kubernetes&lt;/code> 客户端。&lt;/p></description><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/announcing-istio-client-go/</link><author>Neeraj Poddar (Aspen Mesh)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/announcing-istio-client-go/</guid><category>client-go</category><category>tools</category><category>crd</category></item><item><title>DNS 证书管理</title><description>&lt;p>默认情况下, &lt;code>Istio&lt;/code> 的 &lt;code>DNS&lt;/code> 证书是由 &lt;code>Citadel&lt;/code> 来管理的。&lt;code>Citadel&lt;/code> 是一个功能强大的组件，不仅维护自己的私有签名密钥，而且充当证书颁发机构（CA）。&lt;/p>
&lt;p>在 &lt;code>Istio&lt;/code> 的 1.4 版本中，我们引入了一项新功能，可以安全地配置和管理由 &lt;code>Kubernetes CA&lt;/code> 签名的 &lt;code>DNS&lt;/code> 证书，它具有以下优点。&lt;/p>
&lt;ul>
&lt;li>&lt;p>轻量级 &lt;code>DNS&lt;/code> 证书管理，不依赖于 &lt;code>Citadel&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>与 &lt;code>Citadel&lt;/code> 不同的是，此功能不维护私有签名密钥，从而增强了安全性。&lt;/p>&lt;/li>
&lt;li>&lt;p>简化了向 &lt;code>TLS&lt;/code> 客户端分发根证书。客户不再需要等待 &lt;code>Citadel&lt;/code> 生成和分发其 &lt;code>CA&lt;/code> 证书。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>下图显示了在 &lt;code>Istio&lt;/code> 中配置和管理 &lt;code>DNS&lt;/code> 证书的体系结构。&lt;code>Chiron&lt;/code> 是在 &lt;code>Istio&lt;/code> 中配置和管理 &lt;code>DNS&lt;/code> 证书的组件。&lt;/p>
&lt;figure style="width:50%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:82.13367609254499%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/dns-cert/architecture.png" title="在 Istio 中配置和管理 DNS 证书的架构">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/dns-cert/architecture.png" alt="在 Istio 中配置和管理 DNS 证书的架构" />
&lt;/a>
&lt;/div>
&lt;figcaption>在 Istio 中配置和管理 DNS 证书的架构&lt;/figcaption>
&lt;/figure>
&lt;p>要尝试此新功能，请参阅 &lt;a href="/v1.8/zh/docs/tasks/security/dns-cert">DNS 证书管理内容&lt;/a>。&lt;/p></description><pubDate>Thu, 14 Nov 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/dns-cert/</link><author>Lei Tang (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/dns-cert/</guid><category>security</category><category>kubernetes</category><category>certificates</category><category>DNS</category></item><item><title>把 Istio 作为外部服务的代理</title><description>
&lt;p>在网格内如何配置一个入口网关来把内部服务暴露出去，让外部可以访问，在这两篇文章中有介绍&lt;a href="/v1.8/zh/docs/tasks/traffic-management/ingress/ingress-control/">控制入口流量&lt;/a>和&lt;a href="/v1.8/zh/docs/tasks/traffic-management/ingress/ingress-sni-passthrough/">无 TLS 终止的入口网关&lt;/a>。这些服务可以是 HTTP 或者 HTTPS。如果是 HTTPS，网关会透传流量，而不终止 TLS。&lt;/p>
&lt;p>这篇博客介绍如何使用 Istio 的入口网关机制来访问外部服务，而不是网格内应用。这样，Istio 整个作为一个代理服务，具有可观测性、流量管理和策略执行的附加价值。&lt;/p>
&lt;p>这篇博客也展示了如何配置访问一个外部的 HTTP 和 HTTPS 服务，分别是 &lt;code>httpbin.org&lt;/code> 和 &lt;code>edition.cnn.com&lt;/code>。&lt;/p>
&lt;h2 id="configure-an-ingress-gateway">配置一个入口网关&lt;/h2>
&lt;ol>
&lt;li>&lt;p>定义一个入口网关，在 &lt;code>servers:&lt;/code> 配置中配置 &lt;code>80&lt;/code> 和 &lt;code>443&lt;/code> 端口。
在对端口 &lt;code>443&lt;/code> 的配置终确定 &lt;code>tls:&lt;/code> 的 &lt;code>mode:&lt;/code> 配置为 &lt;code>PASSTHROUGH&lt;/code>，这配置网关直接透传流量而且不终止 TLS。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: proxy
spec:
selector:
istio: ingressgateway # use istio default ingress gateway
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- httpbin.org
- port:
number: 443
name: tls
protocol: TLS
tls:
mode: PASSTHROUGH
hosts:
- edition.cnn.com
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为 &lt;code>httpbin.org&lt;/code> 和 &lt;code>edition.cnn.com&lt;/code> 创建服务入口，让他们可以通过入口网关访问：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: httpbin-ext
spec:
hosts:
- httpbin.org
ports:
- number: 80
name: http
protocol: HTTP
resolution: DNS
location: MESH_EXTERNAL
---
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: cnn
spec:
hosts:
- edition.cnn.com
ports:
- number: 443
name: tls
protocol: TLS
resolution: DNS
location: MESH_EXTERNAL
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建一个服务入口，并且为 &lt;code>localhost&lt;/code> 服务配置目的规则。在下一步中，需要这个服务入口作为网格内部应用流量到外部服务的目的地，从而隔断来自网格内部的流量。在此例中把 Istio 用作外部应用和外部服务间的代理。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: localhost
spec:
hosts:
- localhost.local
location: MESH_EXTERNAL
ports:
- number: 80
name: http
protocol: HTTP
- number: 443
name: tls
protocol: TLS
resolution: STATIC
endpoints:
- address: 127.0.0.1
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: localhost
spec:
host: localhost.local
trafficPolicy:
tls:
mode: DISABLE
sni: localhost.local
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为每个外部服务创建一个虚拟服务并配置路由规则。两个虚拟服务的 &lt;code>gateways:&lt;/code> 和 &lt;code>match:&lt;/code> 配置中有针对 HTTP 和 HTTPS 流量相关的 &lt;code>proxy&lt;/code> 网关配置。&lt;/p>
&lt;p>注意 &lt;code>route:&lt;/code> 配置中的 &lt;code>mesh&lt;/code> 网关配置，这个网关代表网格内的应用程序。&lt;code>mesh&lt;/code> 网关中的 &lt;code>route:&lt;/code> 配置表示如何将流量转向 &lt;code>localhost.local&lt;/code> 服务，从而有效地阻隔了流量。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: httpbin
spec:
hosts:
- httpbin.org
gateways:
- proxy
- mesh
http:
- match:
- gateways:
- proxy
port: 80
uri:
prefix: /status
route:
- destination:
host: httpbin.org
port:
number: 80
- match:
- gateways:
- mesh
port: 80
route:
- destination:
host: localhost.local
port:
number: 80
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: cnn
spec:
hosts:
- edition.cnn.com
gateways:
- proxy
- mesh
tls:
- match:
- gateways:
- proxy
port: 443
sni_hosts:
- edition.cnn.com
route:
- destination:
host: edition.cnn.com
port:
number: 443
- match:
- gateways:
- mesh
port: 443
sni_hosts:
- edition.cnn.com
route:
- destination:
host: localhost.local
port:
number: 443
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/observability/logs/access-log/#enable-envoy-s-access-logging">启用 Envoy 的访问日志&lt;/a>。&lt;/p>&lt;/li>
&lt;li>&lt;p>根据&lt;a href="/v1.8/zh/docs/tasks/traffic-management/ingress/ingress-control/#determining-the-ingress-i-p-and-ports">确定入口网关的 IP 和端口&lt;/a>中的命令，设置 &lt;code>SECURE_INGRESS_PORT&lt;/code> 和 &lt;code>INGRESS_HOST&lt;/code> 两个环境变量。&lt;/p>&lt;/li>
&lt;li>&lt;p>在上一步中分别把 IP 和端口存储到了环境变量 &lt;code>$INGRESS_HOST&lt;/code> 和 &lt;code>$INGRESS_PORT&lt;/code> 中，现在可以用这个 IP 和端口访问 &lt;code>httbin.org&lt;/code> 服务。访问 &lt;code>httpbin.org&lt;/code> 服务的 &lt;code>/status/418&lt;/code> 路径，会返回 &lt;a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/418">418 我是一个茶壶&lt;/a>的 HTTP 状态码。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ curl $INGRESS_HOST:$INGRESS_PORT/status/418 -Hhost:httpbin.org
-=[ teapot ]=-
_...._
.&amp;#39; _ _ `.
| .&amp;#34;` ^ `&amp;#34;. _,
\_;`&amp;#34;---&amp;#34;`|//
| ;/
\_ _/
`&amp;#34;&amp;#34;&amp;#34;`
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>如果 Istio 入口网关部署在 &lt;code>istio-system&lt;/code> 名字空间下，使用下面的命令打印网关日志。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs -l istio=ingressgateway -c istio-proxy -n istio-system | grep &amp;#39;httpbin.org&amp;#39;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>检索日志找到类似如下内容：&lt;/p>
&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >[2019-01-31T14:40:18.645Z] &amp;#34;GET /status/418 HTTP/1.1&amp;#34; 418 - 0 135 187 186 &amp;#34;10.127.220.75&amp;#34; &amp;#34;curl/7.54.0&amp;#34; &amp;#34;28255618-6ca5-9d91-9634-c562694a3625&amp;#34; &amp;#34;httpbin.org&amp;#34; &amp;#34;34.232.181.106:80&amp;#34; outbound|80||httpbin.org - 172.30.230.33:80 10.127.220.75:52077 -
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>通过入口网关访问 &lt;code>edition.cnn.com&lt;/code> 服务：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ curl -s --resolve edition.cnn.com:$SECURE_INGRESS_PORT:$INGRESS_HOST https://edition.cnn.com:$SECURE_INGRESS_PORT | grep -o &amp;#34;&amp;lt;title&amp;gt;.*&amp;lt;/title&amp;gt;&amp;#34;
&amp;lt;title&amp;gt;CNN International - Breaking News, US News, World News and Video&amp;lt;/title&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>如果 Istio 入口网关部署在 &lt;code>istio-system&lt;/code> 名字空间下，使用下面的命令打印网关日志。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs -l istio=ingressgateway -c istio-proxy -n istio-system | grep &amp;#39;edition.cnn.com&amp;#39;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>检索日志找到类似如下内容：&lt;/p>
&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >[2019-01-31T13:40:11.076Z] &amp;#34;- - -&amp;#34; 0 - 589 17798 1644 - &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;172.217.31.132:443&amp;#34; outbound|443||edition.cnn.com 172.30.230.33:54508 172.30.230.33:443 10.127.220.75:49467 edition.cnn.com
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="cleanup">清除&lt;/h2>
&lt;p>删除网关、虚拟服务和服务入口：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete gateway proxy
$ kubectl delete virtualservice cnn httpbin
$ kubectl delete serviceentry cnn httpbin-ext localhost
$ kubectl delete destinationrule localhost
&lt;/code>&lt;/pre></description><pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/proxy/</link><author>Vadim Eisenberg (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/proxy/</guid><category>traffic-management</category><category>ingress</category><category>https</category><category>http</category></item><item><title>用于隔离和边界保护的多网格部署</title><description>
&lt;p>各种合规性标准要求保护敏感数据环境。下表列出了一些重要的标准及其保护的敏感数据的类型：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>标准&lt;/th>
&lt;th>敏感数据类型&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://www.pcisecuritystandards.org/pci_security">PCI DSS&lt;/a>&lt;/td>
&lt;td>支付卡数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://www.fedramp.gov">FedRAMP&lt;/a>&lt;/td>
&lt;td>联邦信息，数据和元数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="http://www.gpo.gov/fdsys/search/pagedetails.action?granuleId=CRPT-104hrpt736&amp;amp;packageId=CRPT-104hrpt736">HIPAA&lt;/a>&lt;/td>
&lt;td>个人健康数据&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://gdpr-info.eu">GDPR&lt;/a>&lt;/td>
&lt;td>个人资料&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;a href="https://www.pcisecuritystandards.org/pci_security">PCI DSS&lt;/a>，例如，建议将持卡人数据环境放置在和系统其它部分不同的网络上。它还需要使用 &lt;a href="https://en.wikipedia.org/wiki/DMZ_(computing)">DMZ&lt;/a>，并在公网和 DMZ 之间以及 DMZ 和内部网络之间设置防火墙。&lt;/p>
&lt;p>将敏感数据环境与其他信息系统隔离可以减少合规性检查的范围并提高敏感数据的安全性。缩小范围可降低合规性检查失败的风险，并降低合规性成本，因为根据合规性要求，要检查和保护的组件较少。&lt;/p>
&lt;p>通过将处理数据的应用程序各部分分离到单独的服务网格中（最好也是在单独的网络上），然后将具有不同合规性要求的网格连接到 &lt;span class="term" data-title="Multi-Mesh" data-body="&amp;lt;p&amp;gt;Multi-mesh 是由两个或多个&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;服务网格&amp;lt;/a&amp;gt;组成的部署模型。
每个网格都有独立的命名管理和身份管理，但是您可以通过&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#mesh-federation&amp;#34;&amp;gt;网格联邦&amp;lt;/a&amp;gt;来暴露
网格之间的服务, 最终构成一个多网格部署。&amp;lt;/p&amp;gt;
">多网格&lt;/span> 部署中，可以实现敏感数据的隔离。连接网间应用程序的过程称为 &lt;span class="term" data-title="Mesh Federation" data-body="&amp;lt;p&amp;gt;网格联邦是在网格之间公开服务的一种行为，并且能跨越网格边界进行通信。每一个网格或许会公开其一部分的服务，使一个或多个其他网格使用此公开的服务。
您可以使用网格联邦来启用网格之间的通信，可参阅&amp;lt;a href=&amp;#34;/zh/docs/ops/deployment/deployment-models/#multiple-meshes&amp;#34;&amp;gt;多个网格部署&amp;lt;/a&amp;gt;。&amp;lt;/p&amp;gt;
">网格联邦&lt;/span>。&lt;/p>
&lt;p>请注意，使用网格联邦来创建多网格部署与创建 &lt;span class="term" data-title="Multicluster" data-body="&amp;lt;p&amp;gt;Multicluster 是一种部署模型，由具有多个&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#cluster&amp;#34;&amp;gt;集群&amp;lt;/a&amp;gt;的&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;网格&amp;lt;/a&amp;gt;组成。&amp;lt;/p&amp;gt;
">多集群&lt;/span> 部署非常不同，后者定义了一个由跨多个群集的服务组成的单个服务网格。与多网格不同，多群集部署不适用于需要隔离和边界保护的应用程序。&lt;/p>
&lt;p>在此博客文章中，我描述了隔离和边界保护的要求，并概述了多网格部署的原理。最后，我介绍了 Istio 当前在网格联邦支持和自动化工作的状态。&lt;/p>
&lt;h2 id="isolation-and-boundary-protection">隔离和边界保护&lt;/h2>
&lt;p>隔离和边界保护机制在 &lt;a href="http://dx.doi.org/10.6028/NIST.SP.800-53r4">NIST 特殊出版物 800-53，修订 4，联邦信息系统和组织的安全和隐私控制&lt;/a>，_附录 F，安全控制目录，SC-7 边界保护中进行了说明_。&lt;/p>
&lt;p>特别是 &lt;em>边界保护，隔离信息系统组件&lt;/em> 控制增强：&lt;/p>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">组织可以隔离执行不同任务和/或业务功能的信息系统组件。这种隔离限制了系统组件之间未经授权的信息流，并且还提供了为所选组件部署更高级别的保护的机会。使用边界保护机制将系统组件分开提供了增强对单个组件的保护并更有效地控制这些组件之间的信息流的能力。这种类型的增强保护可限制网络攻击和错误带来的潜在危害。提供的分离程度取决于所选的机制。边界保护机制包括，路由器、网关和防火墙等，将系统组件分离为物理上分离的网络或子网；跨域设备将子网分离；虚拟化技术；以及使用不同的加密密钥对系统组件之间的信息流进行加密。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>各种合规性标准隔离建议，用于处理组织其余部分的敏感数据的环境。&lt;a href="https://www.pcisecuritystandards.org/pci_security/">支付卡行业（PCI）数据安全标准&lt;/a>建议为 &lt;em>持卡人数据&lt;/em> 环境实现网络隔离，并要求将此环境与 &lt;a href="https://en.wikipedia.org/wiki/DMZ_(computing)">DMZ&lt;/a> 隔离。&lt;a href="https://www.fedramp.gov/assets/resources/documents/CSP_A_FedRAMP_Authorization_Boundary_Guidance.pdf">FedRAMP 边界授权指南&lt;/a>描述了联邦信息和数据的 _授权边界_，而 &lt;a href="https://doi.org/10.6028/NIST.SP.800-37r2">NIST 特别出版物 800-37，修订版 2，信息系统和组织的风险管理框架：用于安全性和隐私的系统生命周期方法&lt;/a> &lt;em>附录 G，授权边界注意事项&lt;/em> 建议保护这样的边界：&lt;/p>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">将系统划分为子系统（即分而治之）有助于针对性地应用控制措施，以实现足够的安全性，保护个人隐私和具有成本效益的风险管理流程。将复杂的系统划分为子系统也支持域分离和网络分段的重要安全概念，这在处理高价值资产时可能非常重要。将系统划分为子系统时，组织可以选择制定单独的子系统安全和隐私计划，也可以选择在相同的安全和隐私计划中处理系统和子系统。
信息安全和隐私体系结构在将复杂系统划分为子系统的过程中起着关键作用。这包括在子系统之间的内部边界监视和控制通信，以及选择，分配和实施满足或超过组成子系统的安全性和隐私要求的控件。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>边界保护意味着：&lt;/p>
&lt;ul>
&lt;li>在边界（防火墙，网关等）上设置访问控制机制&lt;/li>
&lt;li>监视边界处的出/入流量&lt;/li>
&lt;li>默认情况下，所有访问控制机制都必须为 &lt;em>deny-all&lt;/em>&lt;/li>
&lt;li>不要通过边界暴露私有 IP 地址&lt;/li>
&lt;li>不要让边界外的组件影响边界内的安全性&lt;/li>
&lt;/ul>
&lt;p>多网格部署有助于将系统划分为具有不同安全性和合规性要求的子系统，有助于边界保护。您将每个子系统放入单独的服务网格中，最好放在单独的网络中。使用网关连接 Istio 网格。网关在每个网格的边界监视和控制跨网格流量。&lt;/p>
&lt;h2 id="features-of-multi-mesh-deployments">多网格部署的特性&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>非统一命名&lt;/strong>。一个网格 &lt;code>accounts&lt;/code> 命名空间中的 &lt;code>withdraw&lt;/code> 服务可能与其他网格 &lt;code>accounts&lt;/code> 命名空间中的 &lt;code>withdraw&lt;/code> 服务具有不同的功能和 API。这种情况可能发生在没有统一命名空间和服务命名策略的组织中，或者当网格属于不同组织时。&lt;/li>
&lt;li>&lt;strong>默认不暴露任何内容&lt;/strong>。默认情况下，网格中没有任何暴露的服务，网格所有者必须明确指定要暴露的服务。&lt;/li>
&lt;li>&lt;strong>边界保护&lt;/strong>。流量的访问控制必须在入口网关上执行，这将阻止未经允许的流量进入网格。该要求实现了&lt;a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">纵深防御原则&lt;/a>，并且是某些合规性标准的一部分，例如&lt;a href="https://www.pcisecuritystandards.org/pci_security/">支付卡行业（PCI）数据安全标准&lt;/a>。&lt;/li>
&lt;li>&lt;strong>可能不存在共同信任&lt;/strong>。由于某些安全要求或由于网格所有者最初未计划网格联邦，可能会出现一个网格中的 Istio sidecar 不信任其他网格中的 Citadel 证书的情况。&lt;/li>
&lt;/ul>
&lt;p>必需通过 &lt;strong>默认不暴露任何内容&lt;/strong> 和 &lt;strong>边界保护&lt;/strong> 来促进合规性并提高安全性。连接不同组织的网格，或者组织不能执行统一命名，或者不能建立网格之间的公共信任，&lt;strong>非统一命名&lt;/strong> 和 &lt;strong>可能不存在共同信任&lt;/strong> 也是必需的。&lt;/p>
&lt;p>您可能要使用的一个可选功能是 &lt;code>服务位置透传&lt;/code>：使用服务的请求使用本地服务名称将请求发送到远程网格中的公开服务。消费服务忽略了以下事实：某些目的地位于远程网格中，而某些目的地是本地服务。访问使用本地服务名称是统一的，例如在 Kubernetes 中是 &lt;code>reviews.default.svc.cluster.local&lt;/code>。&lt;strong>服务位置透传&lt;/strong> 在您希望能够更改使用的服务的位置的情况下很有用，例如，某些服务从私有云迁移到公共云而无需更改应用程序代码的情况。&lt;/p>
&lt;h2 id="the-current-mesh-federation-work">网格联邦目前的工作&lt;/h2>
&lt;p>尽管您现在已经可以使用标准 Istio 配置完成网格联邦，但是它需要编写大量 YAML 文件模板，并且容易出错。我们正在努力使网格联邦过程自动化。同时，您可以查看这些&lt;a href="https://github.com/istio-ecosystem/multi-mesh-examples">多网格部署示例&lt;/a>，以了解生成的联邦可能包括的内容。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>在此博客中，我描述了使用 Istio 多网格部署对敏感数据环境进行隔离和边界保护的要求。概述了 Istio 多网格部署的原理，并报告了 Istio 中有关网格联邦的最新工作。&lt;/p>
&lt;p>我很高兴在 &lt;a href="https://discuss.istio.io">discuss.istio.io&lt;/a> 听到您对 &lt;span class="term" data-title="Multi-Mesh" data-body="&amp;lt;p&amp;gt;Multi-mesh 是由两个或多个&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;服务网格&amp;lt;/a&amp;gt;组成的部署模型。
每个网格都有独立的命名管理和身份管理，但是您可以通过&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#mesh-federation&amp;#34;&amp;gt;网格联邦&amp;lt;/a&amp;gt;来暴露
网格之间的服务, 最终构成一个多网格部署。&amp;lt;/p&amp;gt;
">多网格&lt;/span> 和 &lt;span class="term" data-title="Multicluster" data-body="&amp;lt;p&amp;gt;Multicluster 是一种部署模型，由具有多个&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#cluster&amp;#34;&amp;gt;集群&amp;lt;/a&amp;gt;的&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;网格&amp;lt;/a&amp;gt;组成。&amp;lt;/p&amp;gt;
">多集群&lt;/span> 的意见。&lt;/p></description><pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/isolated-clusters/</link><author>Vadim Eisenberg (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/isolated-clusters/</guid><category>traffic-management</category><category>multicluster</category><category>security</category><category>gateway</category><category>tls</category></item><item><title>监控被阻止的和透传的外部服务流量</title><description>
&lt;p>了解，控制和保护外部服务访问权限是你能够从 Istio 这样的服务网格中获得的主要好处之一。
从安全和操作的角度来看，监控哪些外部服务流量被阻止是非常重要的；因为如果程序试图与不合适的服务进行通信，它们可能会出现错误配置或安全漏洞。
同样，如果你现在有允许任何外部服务访问的策略，那么你可以根据对流量的监控，逐步地添加明确的 Istio 配置来限制访问并提高集群的安全性。
在任何情况下，通过遥测了解这种流量都非常有帮助，因为你可以根据它来创建警报和仪表板，并更好地了解安全状况。
这是 Istio 的生产用户强烈要求的功能，我们很高兴在版本 1.3 中添加了对此功能的支持。&lt;/p>
&lt;p>为了实现此功能，Istio 的&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/metrics">默认监控指标&lt;/a>增加了显式标签，以捕获被阻止和透传的外部服务流量。
这篇博客将介绍如何使用这些增强指标来监视所有外部服务流量。&lt;/p>
&lt;p>Istio 控制平面使用了预定义集群 BlackHoleCluster 和 Passthrough 来配置 sidecar 代理，它们的作用分别是阻止和通过所有流量。
为了了解这些集群，让我们先从外部和内部服务在 Istio 服务网格的意义开始。&lt;/p>
&lt;h2 id="external-and-internal-services">外部和内部服务&lt;/h2>
&lt;p>内部服务被定义为平台中的一部分，并被视为在网格中。对于内部服务，默认情况下，Istio 控制平面为 sidecars 提供所有必需的配置。
例如，在 Kubernetes 集群中，Istio 会为所有 Kubernetes 服务配置 sidecar，以保留所有能够与其他服务通信的服务的默认 Kubernetes 行为。&lt;/p>
&lt;p>外部服务是不属于平台的服务，即不在网格内的服务。
对于外部服务，Istio 提供了两个选项，一个是阻止所有外部服务访问（通过将 &lt;code>global.outboundTrafficPolicy.mode&lt;/code> 设置
为 &lt;code>REGISTRY_ONLY&lt;/code> 启用）, 另一个是允许所有对外部服务的访问（通过将 &lt;code>global.outboundTrafficPolicy.mode&lt;/code> 设置为 &lt;code>ALLOW_ANY&lt;/code> 启用）。
从 Istio 1.3 开始，此设置的默认选项是允许所有外部服务访问。此选项可以通过&lt;a href="/v1.8/zh/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig-OutboundTrafficPolicy-Mode">网格配置&lt;/a>进行配置。&lt;/p>
&lt;p>这就是使用 BlackHole 和 Passthrough 集群的地方。&lt;/p>
&lt;h2 id="what-are-black-hole-and-pass-through-clusters">什么是 BlackHole 和 Passthrough 集群？&lt;/h2>
&lt;ul>
&lt;li>&lt;strong>BlackHoleCluster&lt;/strong> - 当将 &lt;code>global.outboundTrafficPolicy.mode&lt;/code> 设置为 &lt;code>REGISTRY_ONLY&lt;/code> 时，BlackHoleCluster 是
在 Envoy 配置中创建的虚拟集群。在这种模式下，除非为每个服务显式添加了
&lt;a href="/v1.8/zh/docs/reference/config/networking/service-entry">service entries&lt;/a>，否则
所有到外部服务的流量都会被阻止。为了实现此目的，
将使用了 &lt;a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/service_discovery#original-destination">original destination&lt;/a> 且在 &lt;code>0.0.0.0:15001&lt;/code> 的默认虚拟出站监听器设置为以 BlackHoleCluster 为静态集群的 TCP 代理。
BlackHoleCluster 的配置如下所示：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;name&amp;#34;: &amp;#34;BlackHoleCluster&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;STATIC&amp;#34;,
&amp;#34;connectTimeout&amp;#34;: &amp;#34;10s&amp;#34;
}
&lt;/code>&lt;/pre>
&lt;p>如你所见，这个集群是静态的且没有任何的 endpoints，所以所有的流量都会被丢弃。
此外，Istio 会为平台服务的每个端口/协议组合创建唯一的监听器，如果对同一端口上的外部服务发出了请求，则监听器将会取代虚拟监听器。
在这种情况下，Envoy 中每个虚拟路由的路由配置都会被扩展，以添加 BlackHoleCluster，如下所示：&lt;/p>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;name&amp;#34;: &amp;#34;block_all&amp;#34;,
&amp;#34;domains&amp;#34;: [
&amp;#34;*&amp;#34;
],
&amp;#34;routes&amp;#34;: [
{
&amp;#34;match&amp;#34;: {
&amp;#34;prefix&amp;#34;: &amp;#34;/&amp;#34;
},
&amp;#34;directResponse&amp;#34;: {
&amp;#34;status&amp;#34;: 502
}
}
]
}
&lt;/code>&lt;/pre>
&lt;p>该路由被设置为响应码是 502 的&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/route/route_components.proto#envoy-api-field-route-route-direct-response">直接响应&lt;/a>，这意味着如果没有其他路由匹配，则 Envoy 代理将直接返回 502 HTTP 状态代码。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>PassthroughCluster&lt;/strong> - 当将 &lt;code>global.outboundTrafficPolicy.mode&lt;/code> 设置为 &lt;code>ALLOW_ANY&lt;/code> 时，
PassthroughCluster 是在 Envoy 配置中创建的虚拟集群。在此模式下，允许流向外部服务的所有流量。
为了实现此目的，将使用 &lt;code>SO_ORIGINAL_DST&lt;/code> 且监听 &lt;code>0.0.0.0:15001&lt;/code> 的默认虚拟出站监听器设置为 TCP 代理，并将 PassthroughCluster 作为静态集群。
PassthroughCluster 的配置如下所示：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;name&amp;#34;: &amp;#34;PassthroughCluster&amp;#34;,
&amp;#34;type&amp;#34;: &amp;#34;ORIGINAL_DST&amp;#34;,
&amp;#34;connectTimeout&amp;#34;: &amp;#34;10s&amp;#34;,
&amp;#34;lbPolicy&amp;#34;: &amp;#34;ORIGINAL_DST_LB&amp;#34;,
&amp;#34;circuitBreakers&amp;#34;: {
&amp;#34;thresholds&amp;#34;: [
{
&amp;#34;maxConnections&amp;#34;: 102400,
&amp;#34;maxRetries&amp;#34;: 1024
}
]
}
}
&lt;/code>&lt;/pre>
&lt;p>该集群使用&lt;a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/service_discovery#original-destination">原始目标负载均衡策略&lt;/a>，
该策略将 Envoy 配置为将流量发送到原始目标，即透传。&lt;/p>
&lt;p>与 BlackHoleCluster 类似，对于每个基于端口/协议的监听器，虚拟路由配置都会添加 PassthroughCluster 以作为默认路由：&lt;/p>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;name&amp;#34;: &amp;#34;allow_any&amp;#34;,
&amp;#34;domains&amp;#34;: [
&amp;#34;*&amp;#34;
],
&amp;#34;routes&amp;#34;: [
{
&amp;#34;match&amp;#34;: {
&amp;#34;prefix&amp;#34;: &amp;#34;/&amp;#34;
},
&amp;#34;route&amp;#34;: {
&amp;#34;cluster&amp;#34;: &amp;#34;PassthroughCluster&amp;#34;
}
}
]
}
&lt;/code>&lt;/pre>
&lt;p>在 Istio 1.3 之前，没有流量报告，即使流量报告到达这些群集，也没有报告明确的标签设置，从而导致流经网格的流量缺乏可见性。&lt;/p>
&lt;p>下一节将介绍如何利用此增强功能，因为发出的指标和标签取决于是否命中了虚拟出站或显式端口/协议监听器。&lt;/p>
&lt;h2 id="using-the-augmented-metrics">使用增强指标&lt;/h2>
&lt;p>要捕获两种情况（BlackHole 或 Passthrough）中的所有外部服务流量，你将需要监控 &lt;code>istio_requests_total&lt;/code> 和 &lt;code>istio_tcp_connections_closed_total&lt;/code> 指标。
根据 Envoy 监听器的类型，即被调用的 TCP 代理或 HTTP 代理，将增加相应的指标。&lt;/p>
&lt;p>此外，如果使用 TCP 代理监听器以查看被 BlackHole 阻止或被 Passthrough 透传的外部服务的 IP 地址，
则需要将 &lt;code>destination_ip&lt;/code> 标签添加到 &lt;code>istio_tcp_connections_closed_total&lt;/code> 指标。
在这种情况下，不会捕获外部服务的主机名。默认情况下不添加此标签，但是可以通过扩展 Istio 配置以生成属性和 Prometheus 处理程序，轻松地添加此标签。
如果你有许多服务的 IP 地址不稳定，则应注意时序的基数爆炸。&lt;/p>
&lt;h3 id="pass-through-cluster-metrics">PassthroughCluster 指标&lt;/h3>
&lt;p>本节将说明基于被 Envoy 调用的监听器类型的指标和发出的标签。&lt;/p>
&lt;ul>
&lt;li>HTTP 代理监听器: 当外部服务的端口与集群中定义的服务端口之一相同时，就会触发这种情况。
在这种情况下，当命中 PassthroughCluster 时，指标 &lt;code>istio_requests_total&lt;/code> 会增加类似以下内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;metric&amp;#34;: {
&amp;#34;__name__&amp;#34;: &amp;#34;istio_requests_total&amp;#34;,
&amp;#34;connection_security_policy&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_app&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_service&amp;#34;: &amp;#34;httpbin.org&amp;#34;,
&amp;#34;destination_service_name&amp;#34;: &amp;#34;PassthroughCluster&amp;#34;,
&amp;#34;destination_service_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;instance&amp;#34;: &amp;#34;100.96.2.183:42422&amp;#34;,
&amp;#34;job&amp;#34;: &amp;#34;istio-mesh&amp;#34;,
&amp;#34;permissive_response_code&amp;#34;: &amp;#34;none&amp;#34;,
&amp;#34;permissive_response_policyid&amp;#34;: &amp;#34;none&amp;#34;,
&amp;#34;reporter&amp;#34;: &amp;#34;source&amp;#34;,
&amp;#34;request_protocol&amp;#34;: &amp;#34;http&amp;#34;,
&amp;#34;response_code&amp;#34;: &amp;#34;200&amp;#34;,
&amp;#34;response_flags&amp;#34;: &amp;#34;-&amp;#34;,
&amp;#34;source_app&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_workload&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_workload_namespace&amp;#34;: &amp;#34;default&amp;#34;
},
&amp;#34;value&amp;#34;: [
1567033080.282,
&amp;#34;1&amp;#34;
]
}
&lt;/code>&lt;/pre>
&lt;p>请注意，标签 &lt;code>destination_service_name&lt;/code> 设置为 PassthroughCluster，以表明已命中该集群，而 &lt;code>destination_service&lt;/code> 设置为外部服务的主机。&lt;/p>
&lt;ul>
&lt;li>TCP 代理虚拟监听器 - 如果外部服务端口未映射到集群中任何基于 HTTP 的服务端口，则将调用此监听器，
并且会增加指标 &lt;code>istio_tcp_connections_closed_total&lt;/code>:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;status&amp;#34;: &amp;#34;success&amp;#34;,
&amp;#34;data&amp;#34;: {
&amp;#34;resultType&amp;#34;: &amp;#34;vector&amp;#34;,
&amp;#34;result&amp;#34;: [
{
&amp;#34;metric&amp;#34;: {
&amp;#34;__name__&amp;#34;: &amp;#34;istio_tcp_connections_closed_total&amp;#34;,
&amp;#34;connection_security_policy&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_app&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_ip&amp;#34;: &amp;#34;52.22.188.80&amp;#34;,
&amp;#34;destination_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_service&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_service_name&amp;#34;: &amp;#34;PassthroughCluster&amp;#34;,
&amp;#34;destination_service_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;instance&amp;#34;: &amp;#34;100.96.2.183:42422&amp;#34;,
&amp;#34;job&amp;#34;: &amp;#34;istio-mesh&amp;#34;,
&amp;#34;reporter&amp;#34;: &amp;#34;source&amp;#34;,
&amp;#34;response_flags&amp;#34;: &amp;#34;-&amp;#34;,
&amp;#34;source_app&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_workload&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_workload_namespace&amp;#34;: &amp;#34;default&amp;#34;
},
&amp;#34;value&amp;#34;: [
1567033761.879,
&amp;#34;1&amp;#34;
]
}
]
}
}
&lt;/code>&lt;/pre>
&lt;p>在这种情况下，&lt;code>destination_service_name&lt;/code> 设置为 PassthroughCluster，而 &lt;code>destination_ip&lt;/code> 设置为外部服务的 IP 地址。
标签 &lt;code>destination_ip&lt;/code> 可用于执行反向 DNS 查找并获取外部服务的主机名。
在通过该集群时，还将更新其他与 TCP 相关的指标，例如 &lt;code>istio_tcp_connections_opened_total&lt;/code>，
&lt;code>istio_tcp_received_bytes_total&lt;/code> 和 &lt;code>istio_tcp_sent_bytes_total&lt;/code>。&lt;/p>
&lt;h3 id="black-hole-cluster-metrics">BlackHoleCluster 指标&lt;/h3>
&lt;p>与 PassthroughCluster 类似，本节将说明基于被 Envoy 调用的监听器类型的指标和发出的标签。&lt;/p>
&lt;ul>
&lt;li>HTTP 代理监听器: 这种情况发生在外部服务的端口与群集中定义的服务端口之一相同时。
在这种情况下，如果命中了 BlackHoleCluster，标签 &lt;code>istio_requests_total&lt;/code> 会增加类似以下的内容：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;metric&amp;#34;: {
&amp;#34;__name__&amp;#34;: &amp;#34;istio_requests_total&amp;#34;,
&amp;#34;connection_security_policy&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_app&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_service&amp;#34;: &amp;#34;httpbin.org&amp;#34;,
&amp;#34;destination_service_name&amp;#34;: &amp;#34;BlackHoleCluster&amp;#34;,
&amp;#34;destination_service_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;instance&amp;#34;: &amp;#34;100.96.2.183:42422&amp;#34;,
&amp;#34;job&amp;#34;: &amp;#34;istio-mesh&amp;#34;,
&amp;#34;permissive_response_code&amp;#34;: &amp;#34;none&amp;#34;,
&amp;#34;permissive_response_policyid&amp;#34;: &amp;#34;none&amp;#34;,
&amp;#34;reporter&amp;#34;: &amp;#34;source&amp;#34;,
&amp;#34;request_protocol&amp;#34;: &amp;#34;http&amp;#34;,
&amp;#34;response_code&amp;#34;: &amp;#34;502&amp;#34;,
&amp;#34;response_flags&amp;#34;: &amp;#34;-&amp;#34;,
&amp;#34;source_app&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_workload&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_workload_namespace&amp;#34;: &amp;#34;default&amp;#34;
},
&amp;#34;value&amp;#34;: [
1567034251.717,
&amp;#34;1&amp;#34;
]
}
&lt;/code>&lt;/pre>
&lt;p>请注意，标签 &lt;code>destination_service_name&lt;/code> 设置为 BlackHoleCluster，而 &lt;code>destination_service&lt;/code> 设置为外部服务的主机名。
在这种情况下，响应码应始终为 502。&lt;/p>
&lt;ul>
&lt;li>TCP 代理虚拟监听器 - 如果外部服务端口未映射到集群中任何基于 HTTP 的服务端口，则会调用此监听器，
并增加指标 &lt;code>istio_tcp_connections_closed_total&lt;/code>：&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;metric&amp;#34;: {
&amp;#34;__name__&amp;#34;: &amp;#34;istio_tcp_connections_closed_total&amp;#34;,
&amp;#34;connection_security_policy&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_app&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_ip&amp;#34;: &amp;#34;52.22.188.80&amp;#34;,
&amp;#34;destination_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_service&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_service_name&amp;#34;: &amp;#34;BlackHoleCluster&amp;#34;,
&amp;#34;destination_service_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;destination_workload_namespace&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;instance&amp;#34;: &amp;#34;100.96.2.183:42422&amp;#34;,
&amp;#34;job&amp;#34;: &amp;#34;istio-mesh&amp;#34;,
&amp;#34;reporter&amp;#34;: &amp;#34;source&amp;#34;,
&amp;#34;response_flags&amp;#34;: &amp;#34;-&amp;#34;,
&amp;#34;source_app&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_principal&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_version&amp;#34;: &amp;#34;unknown&amp;#34;,
&amp;#34;source_workload&amp;#34;: &amp;#34;sleep&amp;#34;,
&amp;#34;source_workload_namespace&amp;#34;: &amp;#34;default&amp;#34;
},
&amp;#34;value&amp;#34;: [
1567034481.03,
&amp;#34;1&amp;#34;
]
}
&lt;/code>&lt;/pre>
&lt;p>请注意，标签 &lt;code>destination_ip&lt;/code> 表示外部服务的 IP 地址，而 &lt;code>destination_service_name&lt;/code> 设置为 BlackHoleCluster，表示此流量已被网格阻止。
有趣的是，对于 BlackHole 集群，由于未建立任何连接，因此其他与 TCP 相关的指标（例如 &lt;code>istio_tcp_connections_opened_total&lt;/code>）不会增加。&lt;/p>
&lt;p>监控这些指标可以帮助管理员轻松了解其集群中的应用程序接收的所有外部服务。&lt;/p></description><pubDate>Sat, 28 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/monitoring-external-service-traffic/</link><author>Neeraj Poddar (Aspen Mesh)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/monitoring-external-service-traffic/</guid><category>monitoring</category><category>blackhole</category><category>passthrough</category></item><item><title>适用于 Knative 的 Mixer 适配器</title><description>
&lt;p>这篇文章演示了如何使用 &lt;a href="/v1.8/zh/faq/mixer/">Mixer&lt;/a> 把应用逻辑放进 Istio。它描述了一个用简单的代码实现了 Knative scale-from-zero 逻辑的 Mixer 适配器，该适配器和原有实现的性能相差无几。&lt;/p>
&lt;h2 id="Knative-serving">Knative serving&lt;/h2>
&lt;p>&lt;a href="https://knative.dev/docs/serving/">Knative Serving&lt;/a> 基于 &lt;a href="https://kubernetes.io/">Kubernetes&lt;/a> 来支持 serverless 应用的部署和服务（serving）。一个 serverless 平台的核心功能就是 scale-to-zero，该功能可减少非活动工作负载的资源使用量和成本。当空闲应用收到新请求时，需要一种新的机制来 scale-from-zero。&lt;/p>
&lt;p>下图表示当前 Knative scale-from-zero 的架构。&lt;/p>
&lt;figure style="width:60%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:76.29350893697084%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/knative-activator-adapter/knative-activator.png" title="Knative scale-from-zero">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/knative-activator-adapter/knative-activator.png" alt="Knative scale-from-zero" />
&lt;/a>
&lt;/div>
&lt;figcaption>Knative scale-from-zero&lt;/figcaption>
&lt;/figure>
&lt;p>通过配置 Istio 中的 &lt;code>VirtualServices&lt;/code> 和 &lt;code>DestinationRules&lt;/code> 可以将空闲应用的流量重定向到 &lt;strong>Activator&lt;/strong> 组件。当 &lt;strong>Activator&lt;/strong> 接受新请求的是时候，它：&lt;/p>
&lt;ol>
&lt;li>缓存进来的请求&lt;/li>
&lt;li>触发 &lt;strong>Autoscaler&lt;/strong>&lt;/li>
&lt;li>在应用扩容了之后把请求重定向到该应用，包括重试和负载均衡（如果需要的话）&lt;/li>
&lt;/ol>
&lt;p>一旦应用启动并再次运行，Knative 就会把请求路由到正在运行的应用上（之前请求是路由到 &lt;strong>Activator&lt;/strong> 的）。&lt;/p>
&lt;h2 id="mixer-adapter">Mixer 适配器&lt;/h2>
&lt;p>&lt;a href="/v1.8/zh/faq/mixer/">Mixer&lt;/a> 在 Istio 组件和基础设施后端之间提供了一个丰富的中介层。它是独立于 &lt;a href="https://www.envoyproxy.io/">Envoy&lt;/a> 的组件，并且具有简单的可扩展性模型，该扩展模型使 Istio 可以与大部分后端进行交互。Mixer 本质上比 Envoy 更容易扩展。&lt;/p>
&lt;p>Mixer 是一个属性处理引擎，它使用面向操作员（operator-supplied）的配置通过可插拔（pluggable）的适配器将 Istio 代理的请求属性映射到对基础设施后端系统的调用。适配器使 &lt;strong>Mixer&lt;/strong> 暴露单个一致的 API，与使用中的基础设施后端无关。运行时使用的适配器是由操作员配置决定的，适配器可以轻松扩展以适应新的或定制的基础设施后端。&lt;/p>
&lt;p>为了实现 Knative scale-from-zero，我们使用 Mixer &lt;a href="https://github.com/istio/istio/wiki/Mixer-Out-Of-Process-Adapter-Dev-Guide">进程外适配器&lt;/a>来调用 Autoscaler。Mixer 的进程外适配器使开发人员可以使用任何编程语言，并以独立程序的形式构建和维护您的扩展程序，而无需构建 Istio 代理。&lt;/p>
&lt;p>下图表示使用 &lt;strong>Mixer&lt;/strong> 适配器的 Knative 设计。&lt;/p>
&lt;figure style="width:60%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:76.29350893697084%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/knative-activator-adapter/knative-mixer-adapter.png" title="Knative scale-from-zero">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/knative-activator-adapter/knative-mixer-adapter.png" alt="Knative scale-from-zero" />
&lt;/a>
&lt;/div>
&lt;figcaption>Knative scale-from-zero&lt;/figcaption>
&lt;/figure>
&lt;p>在这种设计中，无需像 Knative 原有的设置中那样为空闲应用程序更改到 &lt;strong>Activator&lt;/strong> 的路由。当由 Istio 代理（ingress gateway）收到对空闲应用程序的新请求时，它将通知 Mixer，包括所有相关的元数据信息。然后 Mixer 调用您的适配器，该适配器使用 Knative 原有的协议触发 Knative Autoscaler。&lt;/p>
&lt;div>
&lt;aside class="callout idea">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-idea"/>&lt;/svg>
&lt;/div>
&lt;div class="content">通过使用这种设计，您不需要处理缓存，重试和负载平衡，因为 Istio 代理已经处理了这些。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>Istio 的 Mixer 适配器模式使得我们可以用更简单的方式实现原本复杂并且基于网络的应用逻辑，如 &lt;a href="https://github.com/zachidan/istio-kactivator">Knative 适配器&lt;/a>中所示。&lt;/p>
&lt;p>当适配器从 Mixer 接收到消息时，它会使用 Knative 协议直接向 Autoscaler 发送一个 &lt;code>StatMessage&lt;/code>。Istio 代理将 &lt;strong>Autoscaler&lt;/strong> 所需的元数据信息（&lt;code>namespace&lt;/code> 和 &lt;code>service name&lt;/code>）传输到 Mixer，再从那里传输到适配器。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>我将 Knative 原有的参考架构的冷启动（cold-start）时间与新的 Istio Mixer 适配器参考架构进行了比较。结果显示它们的冷启动时间很接近。使用 Mixer 适配器的实现更加简单。无需处理基于底层网络的机制，因为这些机制是由 Envoy 处理的。&lt;/p>
&lt;p>下一步是把这个 Mixer 适配器放到一个特定的 Envoy（Envoy-specific）过滤器中，该过滤器是在 ingress gateway 内运行。这将进一步改善响应时间（不再调用 &lt;strong>Mixer&lt;/strong> 和适配器），并消除对 Istio Mixer 的依赖。&lt;/p></description><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/knative-activator-adapter/</link><author>Idan Zach （IBM）</author><guid isPermaLink="true">/v1.8/zh/blog/2019/knative-activator-adapter/</guid><category>mixer</category><category>adapter</category><category>knative</category><category>scale-from-zero</category></item><item><title>APP 身份和访问适配器</title><description>
&lt;p>如果在 Kubernetes 以容器化的方式运行应用，就可以使用 App 身份和访问适配器获得抽象级别的安全性，而无需更改代码或重新部署。&lt;/p>
&lt;p>无论您的运行环境是单云提供商，还是多个云提供商的组合或者遵循混合云的方式，集中式身份管理都可以帮助您维护现有基础设施并避免被云供应商绑定。&lt;/p>
&lt;p>有了 &lt;a href="https://github.com/ibm-cloud-security/app-identity-and-access-adapter">App 身份和访问适配器&lt;/a>，就可以使用以下 OAuth2/OIDC 提供商：IBM Cloud App ID、Auth0、Okta、Ping Identity、AWS Cognito、Azure AD B2 等。身份和授权策略可以以高效的方式应用在所有环境（包括前端和后端应用程序），而无需修改代码或重新部署。&lt;/p>
&lt;h2 id="understanding-Istio-and-the-adapter">了解 Istio 和其适配器&lt;/h2>
&lt;p>&lt;a href="/v1.8/zh/docs/concepts/what-is-istio/">Istio&lt;/a> 是一个开源的服务网格，它对分布式应用来说是一个透明层，它可以和 Kubernetes 无缝集成。为了降低布署复杂性 Istio 提供了对整个服务网格的行为洞察和操作控制。详见 &lt;a href="/v1.8/zh/docs/ops/deployment/architecture/">Istio 架构&lt;/a>。&lt;/p>
&lt;p>Istio 使用 [Envoy sidecar 代理] 来调整服务网格中所有 Pod 的入站和出站流量。Istio 从 Envoy sidecar 中提取遥测数据，并将其发送到负责收集遥测数据和执行策略的 Istio 组件 Mixer。&lt;/p>
&lt;p>APP 身份和访问适配器通过分析针对服务网格上各种访问控制策略的遥测数据（属性）扩展 Mixer 的功能。访问控制策略可以关联到具体的 Kubernetes 服务，并且可以微调到特定的服务端点。关于策略和遥测信息的详情请看 Istio 的文档。&lt;/p>
&lt;p>当 &lt;a href="https://github.com/ibm-cloud-security/app-identity-and-access-adapter">App 身份和访问适配器&lt;/a>结合到 Istio 中后，为多云架构提供可扩展的、集成身份和访问解决方案，而且不需要修改任何应用程序代码。&lt;/p>
&lt;h2 id="installation">安装&lt;/h2>
&lt;p>可以直接使用 &lt;code>github.com&lt;/code> 仓库中的 Helm 来安装 APP 身份和访问适配器。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ helm repo add appidentityandaccessadapter https://raw.githubusercontent.com/ibm-cloud-security/app-identity-and-access-adapter/master/helm/appidentityandaccessadapter
$ helm install --name appidentityandaccessadapter appidentityandaccessadapter/appidentityandaccessadapter
&lt;/code>&lt;/pre>
&lt;p>另外，可以从 &lt;code>github.com&lt;/code> 仓库 clone 下来，在本地用 Helm chart 进行安装。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ git clone git@github.com:ibm-cloud-security/app-identity-and-access-adapter.git
$ helm install ./helm/appidentityandaccessadapter --name appidentityandaccessadapter.
&lt;/code>&lt;/pre>
&lt;h2 id="protecting-web-applications">保护 web 应用程序&lt;/h2>
&lt;p>Web 应用程序通常是由 OpenID Connect (OIDC) 工作流保护，也被叫做 &lt;code>authorization_code&lt;/code>。当检测到未经认证或未经授权的用户时，它们会自动重定向到所选择的身份服务并展示认证页面。身份验证完成后，浏览器将重定向回适配器拦截的隐式 &lt;code>/oidc/callback&lt;/code> 端点。此时，适配器从身份服务获取访问和身份令牌，然后将用户重定向回 Web 应用程序中最初请求的 URL。&lt;/p>
&lt;p>身份状态和令牌是由适配器维护管理的。适配器处理的每个请求会包含访问和身份令牌的认证头，其格式是：&lt;code>Authorization: Bearer &amp;lt;access_token&amp;gt; &amp;lt;id_token&amp;gt;&lt;/code>。&lt;/p>
&lt;p>开发者可以根据读取令牌（token）信息调整应用程序的用户体验，比如显示用户名，根据用户角色适配用户界面等。&lt;/p>
&lt;p>为了终止经过身份验证的会话并且清除令牌（即用户注销），只需将浏览器重定向到受保护服务下的 &lt;code>/oidc/logout&lt;/code> 端点即可。例如，从 &lt;code>https://example.com/myapp&lt;/code> 中将应用程序重定向到 &lt;code>https://example.com/myapp/oidc/logout&lt;/code>。&lt;/p>
&lt;p>无论何时访问令牌过期了，系统都会通过刷新令牌自动获取一个新的访问和身份令牌，而无需重新进行身份验证。如果已配置的身份认证提供商返回一个刷新令牌，适配器会将其持久保存，用于老令牌过期时，重新获取新的访问和身份令牌。&lt;/p>
&lt;h3 id="applying-web-application-protection">应用 web 应用程序保护&lt;/h3>
&lt;p>保护 web 应用程序需要创建 2 种类型的资源 - &lt;code>OidcConfig&lt;/code> 资源用于定义各种 OIDC 服务提供商，&lt;code>Policy&lt;/code> 资源用于定义 web 应用保护策略。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;security.cloud.ibm.com/v1&amp;#34;
kind: OidcConfig
metadata:
name: my-oidc-provider-config
namespace: sample-namespace
spec:
discoveryUrl: &amp;lt;discovery-url-from-oidc-provider&amp;gt;
clientId: &amp;lt;client-id-from-oidc-provider&amp;gt;
clientSecretRef:
name: &amp;lt;kubernetes-secret-name&amp;gt;
key: &amp;lt;kubernetes-secret-key&amp;gt;
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;security.cloud.ibm.com/v1&amp;#34;
kind: Policy
metadata:
name: my-sample-web-policy
namespace: sample-namespace
spec:
targets:
- serviceName: &amp;lt;kubernetes-service-name-to-protect&amp;gt;
paths:
- prefix: /webapp
method: ALL
policies:
- policyType: oidc
config: my-oidc-provider-config
rules: // optional
- claim: iss
match: ALL
source: access_token
values:
- &amp;lt;expected-issuer-id&amp;gt;
- claim: scope
match: ALL
source: access_token
values:
- openid
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://github.com/ibm-cloud-security/app-identity-and-access-adapter">阅读更多关于如何保护 web 应用程序&lt;/a>。&lt;/p>
&lt;h2 id="protecting-backend-application-and-APIs">保护后端应用程序和 API&lt;/h2>
&lt;p>后端应用程序和 API 的保护是使用 Bearer Token 工作流，对特定的策略验证传入的令牌。Bearer Token 授权流程需要在请求中包含 &lt;code>Authorization&lt;/code> 头，这个头以 JWT 格式包含了有效的访问令牌。需要的头结构是：&lt;code>Authorization: Bearer {access_token}&lt;/code>。如果令牌验证成功请求会被发往被请求的服务。如果令牌验证失败会给客户端返回 HTTP 401 以及访问这个 API 所需要的权限列表。&lt;/p>
&lt;h3 id="applying-backend-application-and-APIs-protection">应用后端程序和 API 保护&lt;/h3>
&lt;p>保护后端程序和 API 需要创建 2 种类型的资源 - &lt;code>JwtConfig&lt;/code> 用于定义各种 JWT 服务提供者，&lt;code>Policy&lt;/code> 用于定义后端应用保护策略。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;security.cloud.ibm.com/v1&amp;#34;
kind: JwtConfig
metadata:
name: my-jwt-config
namespace: sample-namespace
spec:
jwksUrl: &amp;lt;the-jwks-url&amp;gt;
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;security.cloud.ibm.com/v1&amp;#34;
kind: Policy
metadata:
name: my-sample-backend-policy
namespace: sample-namespace
spec:
targets:
- serviceName: &amp;lt;kubernetes-service-name-to-protect&amp;gt;
paths:
- prefix: /api/files
method: ALL
policies:
- policyType: jwt
config: my-oidc-provider-config
rules: // optional
- claim: iss
match: ALL
source: access_token
values:
- &amp;lt;expected-issuer-id&amp;gt;
- claim: scope
match: ALL
source: access_token
values:
- files.read
- files.write
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="https://github.com/ibm-cloud-security/app-identity-and-access-adapter">阅读更多如何保护后端应用程序&lt;/a>。&lt;/p>
&lt;h2 id="known-limitations">已知的局限性&lt;/h2>
&lt;p>在写这篇博客的时候，有 2 个关于 APP 身份和访问适配器的已知局限性问题：&lt;/p>
&lt;ul>
&lt;li>&lt;p>如果在 Web 应用程序上启用 APP 身份和访问适配器，只能创建 1 个适配器的副本。由于 Envoy 代理处理 HTTP 头的方式，Mixer 有可能给 Envoy 返回多个 &lt;code>Set-Cookie&lt;/code> 头。因此，不能设置 Web 应用程序想要设置的所有 cookie。这个问题最近在 Envoy 和 Mixer 的开发上被讨论，计划在后期适配器的版本中解决。&lt;strong>注意这个问题只影响 Web 应用程序，并不会以任何方式影响后端 APP 和 API&lt;/strong>。&lt;/p>&lt;/li>
&lt;li>&lt;p>作为一般最佳实践，集群内通信应该永远考虑使用双向 TLS 通信。现在 Mixer 与 APP 身份和访问适配器之间的通信通道并没有使用双端 TLS 通信。未来计划根据 &lt;a href="https://github.com/istio/istio/wiki/Mixer-Out-of-Process-Adapter-Walkthrough#step-7-encrypt-connection-between-mixer-and-grpc-adapter">Mixer 适配器开发指引&lt;/a>实现解决这个问题。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>当多云部署实施时，随着环境的发展和多样性，安全也会变得复杂起来。当云提供商提供协议和工具来确保其产品的安全性，开发团队仍然要负责应用程序级别的安全，比如基于 OAuth2 的 API 访问控制，通过流量加密防御中间人攻击以及为服务访问控制提供双向 TLS。但是在多云环境中，这会变得复杂，因为可能要为分别为每个服务定义它的安全策略。有了适当的安全协议，这些外部和内部的威胁就可以减轻了。&lt;/p>
&lt;p>开发团队花时间让服务能够移植到不同的云提供商，在同等情况下，安全应该更灵活而不依赖基础设施。&lt;/p>
&lt;p>Istio 和 APP 身份和访问适配器可以加固 Kubernetes app 的安全性，并且无关编程语言和框架，不需要修改任何一行代码并重新部署。使用这种方式保证了 app 的最大可移植性，并且可以在多个环境中方便的去执行相同的安全策略。&lt;/p>
&lt;p>可以在&lt;a href="https://www.ibm.com/cloud/blog/using-istio-to-secure-your-multicloud-kubernetes-applications-with-zero-code-change">发布博客&lt;/a>上阅读更多关于 APP 身份和访问适配器的信息。&lt;/p></description><pubDate>Wed, 18 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/app-identity-and-access-adapter/</link><author>Anton Aleksandrov (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/app-identity-and-access-adapter/</guid><category>security</category><category>oidc</category><category>jwt</category><category>policies</category></item><item><title>Istio 1.3 Secret 服务发现的更改</title><description>&lt;p>在 Istio 1.3 中，我们正在利用 Kubernetes 的改进功能来更安全地为工作负载实例颁发证书。&lt;/p>
&lt;p>当 Citadel 代理向 Citadel 发送证书签名请求以获取工作负载实例的证书时，它包含了 Kubernetes API 服务器颁发的代表工作负载实例的服务帐户的 JWT。如果 Citadel 可以对 JWT 进行身份验证，则提取为工作负载实例颁发证书所需的服务帐户名。&lt;/p>
&lt;p>在 Kubernetes 1.12 之前，Kubernetes API 服务器的 JWT 存在以下问题：&lt;/p>
&lt;ol>
&lt;li>令牌没有重要字段来限制其使用范围，例如 &lt;code>aud&lt;/code> 或 &lt;code>exp&lt;/code>。有关更多信息，请参见&lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/auth/bound-service-account-tokens.md">绑定服务令牌&lt;/a>。&lt;/li>
&lt;li>令牌安装在所有 pod 上，无法退出。请参见&lt;a href="https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/svcacct-token-volume-source.md">服务帐户令牌数量&lt;/a>了解其机制。&lt;/li>
&lt;/ol>
&lt;p>Kubernetes 1.12 引入了 &lt;code>可信任&lt;/code> JWT 来解决这些问题。但是，直到 &lt;a href="https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.13.md">Kubernetes 1.13&lt;/a> 才支持 &lt;code>aud&lt;/code> 字段与 API 服务器受众具有不同的值。为了更好地保护网格，Istio 1.3 仅支持 &lt;code>可信任&lt;/code> JWT，并且在启用 SDS 时要求 &lt;code>aud&lt;/code> 字段的值为 &lt;code>istio-ca&lt;/code>。在启用 SDS 的情况下将 Istio 部署升级到 1.3 之前，请验证您是否使用了 Kubernetes 1.13 或更高版本。&lt;/p>
&lt;p>根据您选择的平台进行以下考虑：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>GKE：&lt;/strong> 至少将群集版本升级到 1.13。&lt;/li>
&lt;li>&lt;strong>本地 Kubernetes&lt;/strong> 和 &lt;strong>私有 GKE：&lt;/strong> 将&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#service-account-token-volume-projection">额外配置&lt;/a>添加到您的 Kubernetes。您也可以参考 &lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/">api-server 页面&lt;/a>以获取最新的标志名称。&lt;/li>
&lt;li>对于其他平台，请与您的提供商联系。如果您的提供商不支持可信任 JWT，则您将需要使用文件挂载的方式来传播 Istio 1.3 中的工作负载密钥和证书。&lt;/li>
&lt;/ul></description><pubDate>Tue, 10 Sep 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/trustworthy-jwt-sds/</link><author>Phillip Quy Le (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/trustworthy-jwt-sds/</guid><category>security</category><category>PKI</category><category>certificate</category><category>nodeagent</category><category>sds</category></item><item><title>Istio API 的演变</title><description>
&lt;p>使团队能开发出最适合他们特定组织或者工作负载的抽象层，是 Istio 的一个主要目标，过去是，将来也是。Istio 为服务与服务之间网络通信提供了健壮有力的模块。从 &lt;a href="/v1.8/zh/news/releases/0.x/announcing-0.1">Istio 0.1&lt;/a> 开始，Istio 小组一直在从生产用户那里了解他们如何将自己的架构、工作负载和约束映射到 Istio 的功能，并且一直在持续优化 Istio API 来让它们更好地为用户服务。&lt;/p>
&lt;h2 id="evolving-Istio-APIs">Istio API 的演变&lt;/h2>
&lt;p>Istio API 进化的下一步重心是在 Istio 用户的角色上。一个安全管理员应该能够与在逻辑上分组并且简化 Istio 网格中安全操作的 API 进行交互；服务操作人员和流量管理操作也是如此。&lt;/p>
&lt;p>更进一步，使我们有机会为每个角色的初级、中级、高级用例提供改进的体验。有许多常见的用例，可以通过显而易见的默认的设置和一个需要极少配置甚至不需要配置的更好定义的初始体验来解决。对于中级用例，Istio 小组希望利用环境中的上下文提示来为你提供一个更简便的配置体验。最后，对于更高级的使用场景，我们的目标是&lt;a href="https://www.quora.com/What-is-the-origin-of-the-phrase-make-the-easy-things-easy-and-the-hard-things-possible">让简单的事简单困难的事成为可能&lt;/a>。&lt;/p>
&lt;p>为了提供这些以角色为中心的抽象，无论如何，在这些抽象之下的 API 必须要能够描述 Istio 的所有功能。从历史上看，Istio 的 API 设计遵循的路径与其他基础性平台的 API 相似。Istio 遵循下列设计原则：&lt;/p>
&lt;ol>
&lt;li>Istio API 应该寻求：
&lt;ul>
&lt;li>正确地表示他们映射到的基础资源&lt;/li>
&lt;li>不应该隐藏任何基础资源的有用功能&lt;/li>
&lt;/ul>&lt;/li>
&lt;li>Istio API 也应该是&lt;a href="https://en.wikipedia.org/wiki/Composability">可组合的&lt;/a>，因此终端用户能以适合其自身需求的方式组合基础 API。&lt;/li>
&lt;li>Istio API 也应该是灵活的：在一个组织内部，应该有可能对基础资源有不同的表现形式，并且对每个团队都有意义。&lt;/li>
&lt;/ol>
&lt;p>在接下来的几个版本中，我们将分享我们的进展，我们将加强 Istio API 与 Istio 用户角色之间的一致性。&lt;/p>
&lt;h2 id="composability-and-abstractions">可组合性和抽象&lt;/h2>
&lt;p>Istio 和 Kubernetes 经常一起使用，但 Istio 更像是 Kubernetes 的附加组件 – Kubernetes 更接近于一个平台。Istio 旨在提供基础架构，并在强大的服务网格中展现您所需的功能。例如，有一些使用 Kubernetes 作为基础的 platform-as-a-service 产品，并基于 Kubernetes 的可组合性向应用开发人员提供 API 的子集。&lt;/p>
&lt;p>Kubernetes 可组合性的一个具体示例是部署应用时有一系列的对象需要配置。根据我们的统计，至少有 10 个对象需要被配置：&lt;code>Namespace&lt;/code>、&lt;code>Service&lt;/code>、&lt;code>Ingress&lt;/code>、&lt;code>Deployment&lt;/code>、&lt;code>HorizontalPodAutoscaler&lt;/code>、&lt;code>Secret&lt;/code>、&lt;code>ConfigMap&lt;/code>、&lt;code>RBAC&lt;/code>、&lt;code>PodDisruptionBudget&lt;/code> 和 &lt;code>NetworkPolicy&lt;/code>。&lt;/p>
&lt;p>听起来很复杂，但不是每个人都要和这些概念打交道。不同的团队有不同的职责，比如集群、网络、或者安全管理团队，并且许多配置提供合理的默认值。云原生平台和部署工具的一个巨大的优势是可以利用少量的信息来为你配置这些对象以隐藏这种复杂性。&lt;/p>
&lt;p>可以在 &lt;a href="https://cloud.google.com/load-balancing/docs/https/">Google Cloud HTTP(S) Load Balancer&lt;/a> (GCLB) 找到网络空间可组合性的另一个例子。要正确使用 GCLB 的一个实例，需要创建和配置 6 个不同的基础对象。这样的设计是我们操作分布式系统 20 年经验的一个结果，并且&lt;a href="https://www.youtube.com/watch?v=J5HJ1y6PeyE">为什么每一个对象和其他对象相互独立是有原因的&lt;/a>。但你通过 Google Cloud 控制台创建一个实例的步骤是被简化过的。我们提供越多的通用的面向终端用户/以角色为中心的配置，以后你们配置的通用设置越少。最终，基础 API 的目标是在不牺牲功能的情况下提供最大的灵活性。&lt;/p>
&lt;p>&lt;a href="http://knative.dev">Knative&lt;/a> 是一个创建、运行并且操作无服务器工作负载的平台，它提供了一个以角色为中心的现实世界绝佳的示例，更高层次的 API。&lt;a href="https://knative.dev/docs/serving/">Knative Serving&lt;/a>，Knative 的一个组件，基于 Kubernetes 和 Istio 服务于无服务器应用和功能，为应用开发人员管理服务的路由和修订提供了一个稳定的工作流。由于采用这种稳定的方式，Knative Serving 将 Istio 的 &lt;a href="/v1.8/zh/docs/reference/config/networking/virtual-service/">&lt;code>VirtualService&lt;/code>&lt;/a> 和 &lt;a href="/v1.8/zh/docs/reference/config/networking/destination-rule/">&lt;code>DestinationRule&lt;/code>&lt;/a> 资源，抽象成一个简化的支持修订和流量路由的&lt;a href="https://github.com/knative/docs/blob/master/docs/serving/spec/knative-api-specification-1.0.md#route">路由&lt;/a>对象，将与应用开发人员最紧密相关的 Istio 网络 API 的一个子集暴露出来。&lt;/p>
&lt;p>随着 Istio 的成熟，我们还看到生产用户在 Istio 的基础 API 之上开发了针对特定工作负载和组织的抽象层。&lt;/p>
&lt;p>AutoTrader UK 提供了一个基于 Istio 定制平台的我们最喜欢的例子。在&lt;a href="https://kubernetespodcast.com/episode/052-autotrader/">来自 Google 的 Kubernetes Podcast 的一个采访&lt;/a>中，Russel Warman 和 Karl Stoney 描述了他们基于 Kubernetes 的交付平台，和&lt;a href="https://karlstoney.com/2018/07/07/managing-your-costs-on-kubernetes/">用 Prometheus 和 Grafana 搭建的成本 Dashboard&lt;/a>。他们毫不费力地添加了配置项使网络达到他们的开发人员希望配置成的样子，并且现在它管理着的 Istio 的对象让这一切成为可能。在企业和云原生公司中构建了无数其他的平台：一些旨在替换公司特定的自定义脚本的网络，而另一些旨在成为通用的公共工具。随着越来越多的公司开始公开谈论他们的工具，我们将把他们的故事带到此博客。&lt;/p>
&lt;h2 id="what’s-coming-next">接下来会发生什么&lt;/h2>
&lt;p>我们正在为即将发布的版本进行一些改进，其中包括：&lt;/p>
&lt;ul>
&lt;li>通过 Istio operator 安装配置文件用来设置 ingress 和 egress 标准模式&lt;/li>
&lt;li>自动推断容器端口和遥测协议&lt;/li>
&lt;li>默认情况下支持路由所有流量，以逐步限制路由&lt;/li>
&lt;li>添加单个全局标志以启用双向 TLS 并加密所有 Pod 间通信&lt;/li>
&lt;/ul>
&lt;p>噢，如果由于某种原因，你通过安装的 CRD 列表来判断工具箱，在 Istio 1.2 中我们将数字 54 减少到 23。为什么？事实证明，如果您有很多功能，则需要一种方法来配置所有功能。通过对安装程序的改进，您现在可以使用与适配器配合使用的&lt;a href="/v1.8/zh/docs/setup/additional-setup/config-profiles/">配置&lt;/a>安装 Istio。&lt;/p>
&lt;p>在所有的服务网格中，作为扩展，Istio 寻求将复杂的基础性操作自动化，比如网络和安全。这意味着总有些 API 是复杂的，但是 Istio 始终致力于解决操作者的需求，同时继续演变 API 以提供强大的构建块并通过以角色为中心的抽象来优先满足灵活性。&lt;/p>
&lt;p>我们迫不及待地希望你加入我们的&lt;a href="/v1.8/zh/about/community/join/">社区&lt;/a>，看看你会使用 Istio 构建出什么美妙的产品！&lt;/p></description><pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/evolving-istios-apis/</link><author>Louis Ryan (Google), Sandeep Parikh (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/evolving-istios-apis/</guid><category>apis</category><category>composability</category><category>evolution</category></item><item><title>Istio 中安全管控出口流量，第三部分</title><description>
&lt;p>欢迎来看在 Istio 对出口流量进行安全管控系列文章的第 3 部分。
在&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-1/">这个系列文章的第一部分&lt;/a>，我提出了出口流量相关攻击和我们针对出口流量进行安全管控收集的要求点。
在&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/">这个系列文章的第二部分&lt;/a>，我展示了 Istio 的对安全出口流量方案，并且展示了使用 Istio 如何来阻止攻击。&lt;/p>
&lt;p>在这一期中，我对 Istio 出口流量安全管控方案和其它的方案进行了对比，比如使用 Kubernetes 网络策略和已有的出口代理和防火墙。最后我讲述了 Istio 中安全管控出口流量的性能因素。&lt;/p>
&lt;h2 id="alternative-solutions-for-egress-traffic-control">出口流量管控的其它解决方案&lt;/h2>
&lt;p>首先，我们回想一下我们之前收集的&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-1/#requirements-for-egress-traffic-control">出口流量管控要求&lt;/a>：&lt;/p>
&lt;ol>
&lt;li>用 &lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI&lt;/a> 或者用 &lt;a href="/v1.8/zh/docs/reference/glossary/#tls-origination">TLS 源&lt;/a>来支持 &lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS&lt;/a>。&lt;/li>
&lt;li>&lt;strong>监控&lt;/strong> SNI 和每个出口访问的 workload 源。&lt;/li>
&lt;li>定义和执行 &lt;strong>每个集群的策略&lt;/strong>。&lt;/li>
&lt;li>定义和执行 &lt;strong>每个源的策略&lt;/strong>，Kubernetes 可感知。&lt;/li>
&lt;li>&lt;strong>阻止篡改&lt;/strong>。&lt;/li>
&lt;li>对应用程序来说流量管控是 &lt;strong>透明的&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>接下来，将会介绍两种出口流量管控的备选方案：Kubernetes 网络策略和出口代理与防火墙。展示了上述要求中哪些是它们满足的，更重要的是那些要求是它们不能满足的。&lt;/p>
&lt;p>Kubernetes 通过&lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">网络策略&lt;/a>提供了一个流量管控的原生方案，特别是对出口流量管控。使用这些网络策略，集群运维人员可以配置那个 pod 可以访问指定的外部服务。
集群运维人员可以通过 pod 标签、命名空间标签或者 IP 范围来识别 pod。集群运维人员可以使用 IP 范围来明确外部服务，但是不能使用像 &lt;code>cnn.com&lt;/code> 这样的域名来指定外部服务。因为 &lt;strong>Kubernetes 网络策略对 DNS 无感知&lt;/strong>。
网络策略可以满足第一个要求，因为它可以管控任何 TCP 流量。网络策略只能部分满足第三和第四点要求，因为集群运维人员可以针对每个集群或者每个 pod 制定策略，但是运维人员无法用域名来标示外部服务。
只有当攻击者无法从恶意容器进入 Kubernetes 节点并干扰该节点内策略的执行时，网络策略才满足第五个要求。
最近，网络策略满足了第六点要求：运维人员不需要修改代码或者容器环境。总之，我们能说 Kubernetes 网络策略提供了透明的、Kubernetes 可感知的出口流量管控，但不是 DNS 可感知的。&lt;/p>
&lt;p>第二种是比 Kubernetes 早的备选方案。使用 &lt;strong>DNS 可感知的出口代理或者防火墙&lt;/strong> 允许配置应用程序将流量定向到代理并使用某些代理协议，例如：&lt;a href="https://en.wikipedia.org/wiki/SOCKS">SOCKS&lt;/a>。
因为运维人员必须配置应用程序，这个解决方案不是透明的。而且运维人员使用 pod 标签或者 pod 服务账号来配置代理，因为出口代理是不知道它们的。因此 &lt;strong>出口网关不是 Kubernetes 可感知的&lt;/strong> 并且不能满足第四点要求，因为如果 Kubernetes 组件指定源，出口代理不能通过源执行策略。
总结一下，出口代理能满足第一、二、三和五的要求，但是不能满足第四和六的要求，因为它们不能对应用程序透明并且不能被 Kubernetes 感知。&lt;/p>
&lt;h2 id="advantages-of-Istio-egress-traffic-control">Istio 出口流量管控的优势&lt;/h2>
&lt;p>Istio 出口流量管控是 &lt;strong>DNS 可感知的&lt;/strong>：你可以基于 URL 或者泛域名（像 &lt;code>*.ibm.com&lt;/code>）来定义策略。从这个点上说，Istio 的方案比不能 DNS 感知的 Kubernetes 网络策略方案要好。&lt;/p>
&lt;p>Istio 出口流量管控对 TLS 流量是 &lt;strong>透明的&lt;/strong>，因为 Istio 是透明的：不需要改变应用程序或者配置容器。
对于有 TLS 源的 HTTP 流量，你必须配置网格中的应用程序配置使用 HTTP，不能使用 HTTPS。&lt;/p>
&lt;p>Istio 出口流量管控是 &lt;strong>Kubernetes 可感知的&lt;/strong>：出口流量源的身份是基于 Kubernetes 服务账号的。Istio 出口流量管控比现有的 DNS 感知的代理或者防火墙要好，因为它们都是不透明的，也不是 Kubernetes 可感知的。&lt;/p>
&lt;p>Istio 出口流量管控是 &lt;strong>安全的&lt;/strong>：它基于 Istio 的强身份认证，当使用&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#additional-security-considerations">附加安全措施&lt;/a>时，Istio 的流量管控具有防篡改功能。&lt;/p>
&lt;p>另外，Istio 的出口流量管控提供了以下的优势：&lt;/p>
&lt;ul>
&lt;li>对入口、出口和集群内流量用同一种语言定义访问策略。对所有类型的流量只需要学习一种策略和配置语言。&lt;/li>
&lt;li>集成了 Istio 策略的出口流量管控功能和可观测性适配器，开箱即用。&lt;/li>
&lt;li>用于外部监控或者访问管控系统的 Istio 适配器只需要编写一次，就可以把他们应用在所有类型的流量上：入口，出口和集群内。&lt;/li>
&lt;li>对出口流量使用 Istio &lt;a href="/v1.8/zh/docs/concepts/traffic-management/">流量管理特性&lt;/a>：负载均衡，被动和主动的健康检查，熔断，超时，重试，故障注入等等。&lt;/li>
&lt;/ul>
&lt;p>我们将具有上述优点的系统称为 &lt;strong>Istio 可感知&lt;/strong>。&lt;/p>
&lt;p>下表总结了 Istio 和备选方案提供的出口流量管控特性：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Istio 出口流量管控&lt;/th>
&lt;th>Kubernetes 网络策略&lt;/th>
&lt;th>现有出口代理或防火墙&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>DNS 可感知&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#cancel"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kubernetes 可感知&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#cancel"/>&lt;/svg>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>透明&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#cancel"/>&lt;/svg>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Istio 可感知&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#checkmark"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#cancel"/>&lt;/svg>&lt;/td>
&lt;td>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#cancel"/>&lt;/svg>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="performance-considerations">性能因素&lt;/h2>
&lt;p>使用 Istio 管控出口流量有一个代价：增加对外部服务调用的延时和集群 pod 的 CPU 使用率。
流量穿过了两层代理：&lt;/p>
&lt;ul>
&lt;li>应用程序的 sidecar 代理&lt;/li>
&lt;li>出口网关的代理&lt;/li>
&lt;/ul>
&lt;p>如果你使用&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/wildcard-egress-hosts/">泛域名 TLS 出口流量&lt;/a>，你必须在应用程序和外部服务之间增加&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/wildcard-egress-hosts/#wildcard-configuration-for-arbitrary-domains">附加代理&lt;/a>。因为出口网关代理和需要使用通配符配置任意域的代理之间的流量是在 pod 的本地网络，那部分流量不应该对延迟有显著影响。&lt;/p>
&lt;p>请参阅为管控出口流量设置不同 Istio 配置的&lt;a href="/v1.8/zh/blog/2019/egress-performance/">性能评估&lt;/a>。我鼓励你在决定是否能够承担你用例的性能开销之前，仔细评估你自己的应用程序和外部服务的不同配置。你应该权衡所需的安全级别与性能要求，并比较所有备选方案的性能开销。&lt;/p>
&lt;p>让我来分享我对使用 Istio 管控出口流量后带来性能开销的想法：
访问外部服务已经有比较高的延时和增加的开销，由于集群内的 2 个或者 3 个代理很可能相比之下没有那么重要。
毕竟，采用微服务架构的应用程序可以在微服务之间有多次调用的链路。因此，在出口网关上增加 1 个或者 2 个代理不应该有很大的影响。&lt;/p>
&lt;p>此外，我们继续在优化减少 Istio 的性能开销。
可能的优化措施包括：&lt;/p>
&lt;ul>
&lt;li>扩展 Envoy，让它来处理泛域名：这可以消除上面场景中应用程序和外部服务的代理。&lt;/li>
&lt;li>如果流量已加密，那么就只使用双边 TLS 进行身份验证而不加密 TLS 流量。&lt;/li>
&lt;/ul>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>希望读完这个系列的文章，可以说服你认同，对于集群安全来说管控出口流量是非常重要的。
更希望，我可以说服你认同 Istio 对安全的管控出口流量是一个非常有用的工具，并且 Istio 比其它备选方案有很多优势。
Istio 是我所知的唯一解决方案，它可以让你：&lt;/p>
&lt;ul>
&lt;li>以安全和透明的方式管控出口流量&lt;/li>
&lt;li>用域名明确外部服务&lt;/li>
&lt;li>使用 Kubernetes 组件来明确流量源&lt;/li>
&lt;/ul>
&lt;p>以我之见，如果你在寻找你的第一个 Istio 应用场景，安全管控出口流量是一个非常好的选择。在这个场景中，Istio 甚至在你使用它所有其它功能之前就已经为你提供了一些优势：
&lt;a href="/v1.8/zh/docs/tasks/traffic-management/">流量管理&lt;/a>，&lt;a href="/v1.8/zh/docs/tasks/security/">安全性&lt;/a>，&lt;a href="/v1.8/zh/docs/tasks/policy-enforcement/">策略&lt;/a>和&lt;a href="/v1.8/zh/docs/tasks/observability/">可观测性&lt;/a>，上面的功能都可以用在在集群内的微服务之间的流量上。&lt;/p>
&lt;p>所以，如果你还没有机会使用 Istio，那就在你集群上&lt;a href="/v1.8/zh/docs/setup/install/">安装 Istio&lt;/a> 并且检查&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/">出口流量管控任务&lt;/a>再执行其它 &lt;a href="/v1.8/zh/docs/tasks/">Istio 特性&lt;/a>的任务。我们也想收到你的反馈，请在 &lt;a href="https://discuss.istio.io">discuss.istio.io&lt;/a> 加入我们。&lt;/p></description><pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-3/</link><author>Vadim Eisenberg (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-3/</guid><category>traffic-management</category><category>egress</category><category>security</category><category>gateway</category><category>tls</category></item><item><title>Istio 中的安全管控出口流量，第二部分</title><description>
&lt;p>欢迎来看 Istio 对出口流量进行安全管控系列文章的第 2 部分。
在&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-1/">这个系列文章的第一部分&lt;/a>, 我提出了出口流量相关攻击和针对出口流量进行安全管控我们收集的要求点。
在这一期中，我会讲述对出口流量进行安全管控的 Istio 方式，并且展示 Istio 如何帮你阻止攻击。&lt;/p>
&lt;h2 id="secure-control-of-egress-traffic-in-Istio">Istio 中的出口流量安全管控&lt;/h2>
&lt;p>为了在 Istio 中实施出口流量的安全管控，你必须&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#egress-gateway-for-https-traffic">通过出口网关将 TLS 流量发送到外部服务&lt;/a>。
或者可以&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#egress-gateway-for-http-traffic">通过出口网关发送 HTTP 流量&lt;/a>，并且&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination/#perform-TLS-origination-with-an-egress-gateway">让出口网关来发起执行 TLS&lt;/a>。&lt;/p>
&lt;p>两种选择各有利弊，你应该根据你的具体场景进行选择。选择的关键取决于你的应用程序是否能发送不加密的 HTTP 请求和你团队的安全策略是否允许发送不加密的 HTTP 请求。
例如，如果你的应用程序使用了某些客户端库，用这些库来对流量进行加密，但是它无法取消加密，你就不能使用发送不加密 HTTP 流量的选项。万一你团队的安全策略无法让你&lt;strong>在 pod 内&lt;/strong>发送不加密的 HTTP 请求也是一样的（pod 外的流量由 Istio 来加密）。&lt;/p>
&lt;p>如果应用程序发送 HTTP 请求，并且由出口网关发起执行 TLS，你就可以监控 HTTP 信息，像 HTTP 方法、HTTP 头和 URL 路径。也可以根据上面说的 HTTP 信息来&lt;a href="/v1.8/zh/blog/2018/egress-monitoring-access-control">定义策略&lt;/a>。如果是由应用程序发起执行 TLS，你就可以对源 pod 的 TLS 流量的 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress_sni_monitoring_and_policies/">SNI 和服务账号进行监控&lt;/a>，并且基于 SNI 和服务账号定义策略。&lt;/p>
&lt;p>你必须确保你集群到外部的流量不能绕过出口网关。Istio 不能给你确保这一点，所以你必需使用一些&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#additional-security-considerations">附加的安全机制&lt;/a>，比如 &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Kubernetes 网络策略&lt;/a>或者 L3 防火墙。看一个 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#apply-Kubernetes-network-policies">Kubernetes 网络策略配置&lt;/a>的例子。
根据&lt;a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">纵深防御&lt;/a>的概念，为同一个目标使用的安全机制越多越安全。&lt;/p>
&lt;p>你也必需也要确保 Istio 控制平面和出口网关不能被破坏。你的集群里面可能有成百上千的应用程序 pod，而只有十几个 Istio 控制平面 pod 和网关。
你可以也应该聚焦在保护控制平面 pod 和网关，因为这比较容易（需要保护的 pod 数量很少），并且这对集群的安全性是最关键的。
如果攻击者破坏了控制平面和出口网关，他们可以违反任何策略。&lt;/p>
&lt;p>根据环境的不同，你可能有多种工具来保护控制平面 pod。合理的安全策略如下：&lt;/p>
&lt;ul>
&lt;li>把运行控制平面 pod 的节点和应用程序节点隔离开。&lt;/li>
&lt;li>把控制平面的 pod 运行在它们自己独立的命名空间中。&lt;/li>
&lt;li>启用 Kubernetes 的 RBAC 和网络策略来保护控制平面的 pod。&lt;/li>
&lt;li>监控控制平面 pod 要比监控应用程序 pod 更紧密。&lt;/li>
&lt;/ul>
&lt;p>一旦你通过出口网关引导了出口流量，并且应用了附加的安全机制，就可以进行安全的监控和施加对流量的安全策略。&lt;/p>
&lt;p>下图展示了 Istio 的安全架构，用 L3 防火墙进行了加强，L3 防火墙就是&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#additional-security-considerations">附加安全机制&lt;/a>的一部分，它应该在 Istio 的外面。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:54.89557965057057%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/SecurityArchitectureWithL3Firewalls.svg" title="带有出口网关和 L3 防火钱的 Istio 安全架构">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/SecurityArchitectureWithL3Firewalls.svg" alt="带有出口网关和 L3 防火钱的 Istio 安全架构" />
&lt;/a>
&lt;/div>
&lt;figcaption>带有出口网关和 L3 防火钱的 Istio 安全架构&lt;/figcaption>
&lt;/figure>
&lt;p>可以简单的配置 L3 防火墙，使它只允许通过 Istio 入口网关来的流量，并且只允许通过 Istio 出口网关出去的流量。网关的 Istio 代理执行策略，并且和在网格中其它所有代理一样上报检测信息。&lt;/p>
&lt;p>现在我们来测试一下可能的攻击，并且我会给你们展示 Istio 中的出口流量安全管控是怎么阻止攻击的。&lt;/p>
&lt;h2 id="preventing-possible-attacks">阻止可能的攻击&lt;/h2>
&lt;p>参考以下出口流量的安全策略：&lt;/p>
&lt;ul>
&lt;li>允许应用程序 &lt;strong>A&lt;/strong> 访问 &lt;code>*.ibm.com&lt;/code>，这包含了所有外部服务中匹配 &lt;code>*.ibm.com&lt;/code> 的 URL。&lt;/li>
&lt;li>允许应用程序 &lt;strong>B&lt;/strong> 访问 &lt;code>mongo1.composedb.com&lt;/code>。&lt;/li>
&lt;li>监控所有的出口流量。&lt;/li>
&lt;/ul>
&lt;p>假设攻击者有以下目标：&lt;/p>
&lt;ul>
&lt;li>从你的集群中访问 &lt;code>*.ibm.com&lt;/code>。&lt;/li>
&lt;li>从你的集群中访问 &lt;code>*.ibm.com&lt;/code>，并且不被监控到。攻击者不想他的流量被监控到，如果被监控到你将会发觉这个禁止的访问。&lt;/li>
&lt;li>从你的集群中访问 &lt;code>mongo1.composedb.com&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>现在假设攻击者设法在攻破应用程序 &lt;strong>A&lt;/strong> 的其中一个 pod，并且试图使用这个被攻破的 pod 来执行被禁止的访问。攻击者可能试试运气直接访问外部服务。你会对这个直接的尝试做出如下反应：&lt;/p>
&lt;ul>
&lt;li>最开始，是没有办法阻止被攻破的 应用程序 &lt;strong>A&lt;/strong> 去访问 &lt;code>*.ibm.com&lt;/code>，因为被攻破的 pod 很难和原来的 pod 区分开。&lt;/li>
&lt;li>幸运的是，你可以监控所有对外部服务的访问，检测可疑流量，并且阻止攻击者获得对 &lt;code>*.ibm.com&lt;/code> 的无监控访问。例如，你可以用异常检测工具检测出口流量的日志。&lt;/li>
&lt;li>阻止攻击者从集群中访问 &lt;code>mongo1.composedb.com&lt;/code>，Istio 会正确的检测流量的源，如这个例子中应用程序 &lt;strong>A&lt;/strong>，根据上面提到的安全策略验证它是不是被允许访问 &lt;code>mongo1.composedb.com&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>直接攻击失败的话，恶意攻击者可能会使用高级攻击方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>绕过容器的 sidecar 代理&lt;/strong> 就可能直接访问任何外部服务，而且没有了 sidecar 的策略执行和上报。这种攻击可以通过 Kubernetes 网络策略或者 L3 防火墙来阻止，因为它们可以让出网格的流量只通过出口网关。&lt;/li>
&lt;li>&lt;strong>破坏出口网关&lt;/strong> 就可以强制它发送假信息给监控系统或禁止执行安全策略。这种攻击可以通过在出口网关 pod 上应用特殊的安全策略。&lt;/li>
&lt;li>&lt;strong>冒充应用程序 B&lt;/strong>，因为允许应用程序 &lt;strong>B&lt;/strong> 访问 &lt;code>mongo1.composedb.com&lt;/code>。幸运的是，这种攻击可以用 Istio 的&lt;a href="/v1.8/zh/docs/concepts/security/#istio-identity">强身份认证支持&lt;/a>来阻止。&lt;/li>
&lt;/ul>
&lt;p>据我们所见，所有禁止的访问都可以阻止，或者至少可以监控到，在以后可以被阻止。
如果看到当前设计中涉及出口流量或安全漏洞的其它攻击，我们将很高兴&lt;a href="https://discus.istio.io">听到它&lt;/a>。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>希望我能说服你：Istio 在阻止相关出口流量攻击上是一个非常高效的工具。在&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-3/">这个系列文章的下一部分&lt;/a>，我对 Istio 出口流量安全管控方案和其它的方案进行了对比，比如 &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Kubernetes 网络策略&lt;/a>和已有的出口代理/防火墙。&lt;/p></description><pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/</link><author>Vadim Eisenberg (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/</guid><category>traffic-management</category><category>egress</category><category>security</category><category>gateway</category><category>tls</category></item><item><title>最佳实践：Service Mesh 基准性能测试</title><description>
&lt;p>服务网格为应用部署增加了很多功能，包括&lt;a href="/v1.8/zh/docs/concepts/what-is-istio/#traffic-management">流量策略&lt;/a>、&lt;a href="/v1.8/zh/docs/concepts/what-is-istio/#observability">可观察性&lt;/a>和&lt;a href="/v1.8/zh/docs/concepts/what-is-istio/#security">安全通信&lt;/a>。但是，无论是时间（增加的延迟）还是资源（CPU 周期），向环境中添加服务网格都是有代价的。要就服务网格是否适合您的情况做出明智的决定，评估应用与服务网格一起部署时的性能非常重要。&lt;/p>
&lt;p>今年早些时候，我们发布了关于 Istio 1.1 性能改进的&lt;a href="/v1.8/zh/blog/2019/istio1.1_perf/">博客&lt;/a>。在发布 &lt;a href="/v1.8/zh/news/releases/1.2.x/announcing-1.2">Istio 1.2&lt;/a> 之后，我们希望提供指导和工具，以帮助您在可用于生产的 Kubernetes 环境中对 Istio 的数据平面性能进行基准测试。&lt;/p>
&lt;p>总体而言，我们发现 Istio &lt;a href="/v1.8/zh/docs/ops/deployment/architecture/#envoy">sidecar 代理&lt;/a>的延迟取决于并发连接数。以每秒 1000 个请求（RPS）的速度，通过 16 个连接，Istio 延迟在 50% 时增加 &lt;strong>3 毫秒&lt;/strong>，在 99% 时增加 &lt;strong>10 毫秒&lt;/strong>。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/benchmark">Istio Tools 仓库&lt;/a>中，您将找到用于测量 Istio 数据平面性能的脚本和说明，以及有关如何使用另一服务网格实现 &lt;a href="https://linkerd.io">Linkerd&lt;/a> 运行脚本的其他说明。在我们详细介绍性能测试框架的每个步骤的一些最佳实践时，请&lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/benchmark#setup">遵循&lt;/a>。&lt;/p>
&lt;h2 id="1-use-a-production-ready-Istio-installation">1. 使用生产就绪的 Istio 安装&lt;/h2>
&lt;p>为了准确地大规模度量服务网格的性能，使用&lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/istio-install#istio-setup">适当大小的&lt;/a> Kubernetes 集群很重要。我们使用三个工作节点进行测试，每个工作节点至少具有 4 vCPU 和 15 GB 的内存。&lt;/p>
&lt;p>然后，在该群集上使用可用于生产的 Istio &lt;strong>安装配置文件&lt;/strong> 很重要。这使我们能够实现面向性能的设置，例如控制平面 pod 自动伸缩，并确保资源限制适用于繁重的流量负荷。&lt;a href="/v1.8/zh/docs/setup/install/helm/#安装步骤">默认&lt;/a> Istio 安装适用于大多数基准测试用例。为了进行广泛的性能基准测试，并提供数千种注入代理的服务，我们还提供了&lt;a href="https://github.com/istio/tools/blob/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/istio-install/values.yaml">调整后的 Istio 安装&lt;/a>，可为 Istio 控制平面分配额外的内存和 CPU。&lt;/p>
&lt;p>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#exclamation-mark"/>&lt;/svg> Istio 的 &lt;a href="/v1.8/zh/docs/setup/getting-started/">demo 安装&lt;/a>不适合进行性能测试，因为它被设计为部署在小型试用群集中，并且具有完整的跟踪和访问日志，可显示 Istio 的功能。&lt;/p>
&lt;h2 id="2-focus-on-the-data-plane">2. 专注于数据平面&lt;/h2>
&lt;p>我们的基准测试脚本专注于评估 Istio 数据平面：&lt;span class="term" data-title="Envoy" data-body="&amp;lt;p&amp;gt;Envoy 是在 Istio 里使用的高性能代理，用于为所有&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;服务网格&amp;lt;/a&amp;gt;里的&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service&amp;#34;&amp;gt;服务&amp;lt;/a&amp;gt;调度进出的流量。
&amp;lt;a href=&amp;#34;https://envoyproxy.github.io/envoy/&amp;#34;&amp;gt;了解更多关于 Envoy&amp;lt;/a&amp;gt;。&amp;lt;/p&amp;gt;
">Envoy&lt;/span> 代理，可在应用容器之间进行流量调度。为什么要关注数据平面？因为在大规模使用大量应用容器时，数据平面的 &lt;strong>内存&lt;/strong> 和 &lt;strong>CPU&lt;/strong> 使用率很快就会超过 Istio 控制平面。让我们看一个具体的例子：&lt;/p>
&lt;p>假设您运行了 2,000 个注入 Envoy 的 pod，每个 pod 每秒处理 1,000 个请求。每个代理使用 50 MB 的内存，并且要配置所有这些代理，Pilot 使用 1 vCPU 和 1.5 GB 的内存。所有的资源中，Istio 数据平面（所有 Envoy 代理的总和）使用了 100 GB 的内存，而 Pilot 只使用了 1.5 GB。&lt;/p>
&lt;p>考虑到 &lt;strong>延迟&lt;/strong>，关注数据平面性能也很重要。这是因为大多数应用的请求会通过 Istio 数据平面，而不是通过控制平面。但是，有两个例外：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>遥测报告：&lt;/strong> 每个代理将原始遥测数据发送到 &lt;span class="term" data-title="Mixer" data-body="&amp;lt;p&amp;gt;Mixer 是 Istio 里的一个组件，它负责增强&amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#service-mesh&amp;#34;&amp;gt;服务网格&amp;lt;/a&amp;gt;里的访问控制和使用策略。它还负责收集来自 &amp;lt;a href=&amp;#34;/zh/docs/reference/glossary/#envoy&amp;#34;&amp;gt;envoy&amp;lt;/a&amp;gt; 和其他服务的遥测数据。
&amp;lt;a href=&amp;#34;/zh/docs/reference/config/policy-and-telemetry&amp;#34;&amp;gt;了解更多关于 Mixer&amp;lt;/a&amp;gt;。&amp;lt;/p&amp;gt;
">Mixer&lt;/span>，Mixer 将其处理为度量，跟踪和其他遥测。原始遥测数据类似于访问日志，因此要付出一定的代价。访问日志处理会消耗 CPU，并使工作线程无法处理下一个工作单元。在更高的吞吐量场景下，下一个工作单元更有可能在队列中等待被工作者接走。这可能导致 Envoy 的长尾延迟（99%）。&lt;/li>
&lt;li>&lt;strong>自定义策略检查：&lt;/strong> 当使用&lt;a href="/v1.8/zh/docs/concepts/observability/">自定义 Istio 策略适配器&lt;/a>时，策略检查位于请求路径上。这意味着数据路径上的请求 header 和 metadata 将被发送到控制平面（Mixer），从而导致更高的请求延迟。&lt;strong>注意：&lt;/strong> 这些策略检查&lt;a href="/v1.8/zh/docs/reference/config/installation-options/#global-options">默认情况下处于禁用状态&lt;/a>，因为最常见的策略用例（&lt;a href="/v1.8/zh/docs/reference/config/security/istio.rbac.v1alpha1">RBAC&lt;/a>）完全由 Envoy 代理执行。&lt;/li>
&lt;/ol>
&lt;p>当 &lt;a href="https://docs.google.com/document/d/1QKmtem5jU_2F3Lh5SqLp0IuPb80_70J7aJEYu4_gS-s">Mixer V2&lt;/a> 将所有策略和遥测功能直接移到代理中时，这两个例外都会在将来的 Istio 版本中消失。&lt;/p>
&lt;p>接下来，在大规模测试 Istio 的数据平面性能时，不仅要以每秒递增的请求进行测试，而且还要以越来越多的 &lt;strong>并发&lt;/strong> 连接进行测试，这一点很重要。这是因为现实世界中的高吞吐量流量来自多个客户端。我们&lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/benchmark#run-performance-tests">提供了脚本&lt;/a>允许您以递增的 RPS 对任意数量的并发连接执行相同的负载测试。&lt;/p>
&lt;p>最后，我们的测试环境可以测量两个 pod 之间少量的请求。客户端 pod 是 &lt;a href="http://fortio.org/">Fortio&lt;/a>，它将流量发送到服务端 pod。&lt;/p>
&lt;p>为什么只用两个 pod 测试？因为增加吞吐量（RPS）和连接（线程）对 Envoy 的性能的影响比增加服务注册表的总大小（或 Kubernetes 集群中 Pod 和服务的总数）更大。当服务注册表的大小增加时，Envoy 必须跟踪更多的端点，并且每个请求的查找时间确实增加了，但是增加了一个很小的常数。如果您有许多服务，并且此常数成为延迟问题，则 Istio 提供 &lt;a href="/v1.8/zh/docs/reference/config/networking/sidecar/">Sidecar 资源&lt;/a>，它使您可以限制每个 Envoy 知道的服务。&lt;/p>
&lt;h2 id="3-measure-with-and-without-proxies">3. 有/无 度量的代理&lt;/h2>
&lt;p>尽管 Istio 的许多特性，例如&lt;a href="/v1.8/zh/docs/concepts/security/#mutual-TLS-authentication">双向 TLS 身份验证&lt;/a>，都依赖于应用 pod 的 Envoy 代理，但是您可以&lt;a href="/v1.8/zh/docs/setup/additional-setup/sidecar-injection/#disabling-or-updating-the-webhook">选择性地禁用&lt;/a>一些网格服务的 sidecar 代理注入。在扩展 Istio 以进行生产时，您可能需要将 sidecar 代理增量添加到工作负载中。&lt;/p>
&lt;p>为此，测试脚本提供了&lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/benchmark#run-performance-tests">三种不同模式&lt;/a>。当请求同时通过客户端和服务器代理（&lt;code>both&lt;/code>）、仅通过服务器代理（&lt;code>serveronly&lt;/code>）和都不通过代理（&lt;code>baseline&lt;/code>）时，这些模式将分析 Istio 的性能。&lt;/p>
&lt;p>您还可以在性能测试期间禁用 &lt;a href="/v1.8/zh/docs/concepts/observability/">Mixer&lt;/a> 以停止 Istio 的遥测，这将得到与 Mixer V2 工作完成时我们期望的性能相符的结果。Istio 还支持 &lt;a href="https://github.com/istio/istio/wiki/Envoy-native-telemetry">Envoy 本地遥测&lt;/a>，其功能类似于禁用 Istio 的遥测。&lt;/p>
&lt;h2 id="Istio-1-2-performance">Istio 1.2 性能&lt;/h2>
&lt;p>让我们看看如何使用该测试环境来分析 Istio 1.2 数据平面的性能。我们还提供了运行 &lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/benchmark/linkerd">Linkerd 数据平面的相同性能测试&lt;/a>的说明。Linkerd 目前仅支持延迟基准测试。&lt;/p>
&lt;p>为了衡量 Istio sidecar 的代理延迟，我们考虑在 50%、90% 和 99% 时不断增加并发连接数量，从而保持了请求吞吐量（RPS）不变。&lt;/p>
&lt;p>我们发现，通过 16 个并发连接和 1000 RPS，当请求同时通过客户端和服务器代理传输时，Istio 会在基线（P50）上增加 &lt;strong>3ms&lt;/strong>。（从绿色线 &lt;code>both&lt;/code> 中减去粉红色线 &lt;code>base&lt;/code>）在 64 个并发连接上，Istio 在基线上增加了 &lt;strong>12ms&lt;/strong>，但是禁用 Mixer（&lt;code>nomixer_both&lt;/code>）后，Istio 仅增加了 &lt;strong>7ms&lt;/strong>。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:60%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/performance-best-practices/latency_p50.png" title="Istio sidecar 代理, 50% 时的延迟">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/performance-best-practices/latency_p50.png" alt="Istio sidecar 代理, 50% 时的延迟" />
&lt;/a>
&lt;/div>
&lt;figcaption>&lt;/figcaption>
&lt;/figure>
&lt;p>在 90% 时，有 16 个并发连接，Istio 增加 &lt;strong>6ms&lt;/strong>；在 64 个连接的情况下，Istio 增加了 &lt;strong>20ms&lt;/strong>。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:60%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/performance-best-practices/latency_p90.png" title="Istio sidecar 代理, 90% 时的延迟">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/performance-best-practices/latency_p90.png" alt="Istio sidecar 代理, 90% 时的延迟" />
&lt;/a>
&lt;/div>
&lt;figcaption>&lt;/figcaption>
&lt;/figure>
&lt;p>最后，在具有 16 个连接的 99% 时，Istio 在基线之上增加了 &lt;strong>10ms&lt;/strong>。在 64 个连接处，Istio 使用 Mixer 增加 &lt;strong>25ms&lt;/strong>，不使用 Mixer 则增加 &lt;strong>10ms&lt;/strong>。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:60%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/performance-best-practices/latency_p99.png" title="Istio sidecar 代理, 99% 时的延迟">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/performance-best-practices/latency_p99.png" alt="Istio sidecar 代理, 99% 时的延迟" />
&lt;/a>
&lt;/div>
&lt;figcaption>&lt;/figcaption>
&lt;/figure>
&lt;p>对于 CPU 使用率，我们以不断增加的请求吞吐量（RPS）和恒定数量的并发连接进行了测量。我们发现启用了 Mixer 的 Envoy 在 3000 RPS 时的最大 CPU 使用率是 &lt;strong>1.2 vCPU&lt;/strong>。在 1000 RPS 时，一个 Envoy 大约使用了 50% 的 CPU。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:60%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/performance-best-practices/cpu_max.png" title="Istio sidecar 代理，最大 CPU 使用率">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/performance-best-practices/cpu_max.png" alt="Istio sidecar 代理，最大 CPU 使用率" />
&lt;/a>
&lt;/div>
&lt;figcaption>&lt;/figcaption>
&lt;/figure>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>在对 Istio 的性能进行基准测试的过程中，我们吸取了一些重要的经验教训：&lt;/p>
&lt;ul>
&lt;li>使用模仿生产的环境。&lt;/li>
&lt;li>专注于数据平面流量。&lt;/li>
&lt;li>基于基准进行测量。&lt;/li>
&lt;li>增加并发连接以及总吞吐量。&lt;/li>
&lt;/ul>
&lt;p>对于在 16 个连接上具有 1000 RPS 的网格，Istio 1.2 仅在 50% 的基础上增加了 &lt;strong>3 毫秒&lt;/strong> 的基准延迟。&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">Istio 的性能取决于您的具体设置和流量负载情况。由于存在这种差异，请确保您的测试设置能够准确反映您的生产工作负载。要试用基准测试脚本，请转到 &lt;a href="https://github.com/istio/tools/tree/3ac7ab40db8a0d595b71f47b8ba246763ecd6213/perf/benchmark">Istio Tools 库&lt;/a>。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>另外，请查阅 &lt;a href="/v1.8/zh/docs/ops/deployment/performance-and-scalability">Istio 性能和可伸缩性指南&lt;/a>获取最新的性能数据。感谢您的阅读，祝您基准测试愉快！&lt;/p></description><pubDate>Tue, 09 Jul 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/performance-best-practices/</link><author>Megan O'Keefe (Google), John Howard (Google), Mandar Jog (Google)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/performance-best-practices/</guid><category>performance</category><category>scalability</category><category>scale</category><category>benchmarks</category></item><item><title>延长 Istio 自签名根证书的有效期</title><description>&lt;p>Istio 自签名证书的默认有效期为 1 年。如果您正在使用 Istio 自签名证书，您需要在到期前安排定期根转换。根证书到期可能会导致整个群集意外中断。此问题会影响使用 1.0.7 和 1.1.7 版本创建的新群集。&lt;/p>
&lt;p>有关如何判断证书年龄和如何执行轮换的信息，请参见&lt;a href="/v1.8/zh/docs/ops/configuration/security/root-transition/">延长 Istio 自签名证书的有效期&lt;/a>。&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">我们强烈建议您每年轮换根密钥和根证书作为最佳安全实践。我们将尽快发出有关根密钥/证书轮换的说明。&lt;/div>
&lt;/aside>
&lt;/div></description><pubDate>Fri, 07 Jun 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/root-transition/</link><author>Oliver Liu</author><guid isPermaLink="true">/v1.8/zh/blog/2019/root-transition/</guid><category>security</category><category>PKI</category><category>certificate</category><category>Citadel</category></item><item><title>Istio 中的安全管控出口流量，第一部分</title><description>
&lt;p>这是我计划发布的关于 Istio 中出口流量安全管控系列文章中的第一部分。在这一期，会阐述为什么集群需要应用出口流量管控，要防止的出口流量相关的攻击有哪些，以及出口流量管控系统的要求有哪些。
一旦同意集群的出口流量应该被管控，那么就会出现下面的问题：出口流量安全管控系统需要什么？针对这些要求的最佳解决方案是什么？（捣乱分子：以我之见 Istio 是最佳解决方案）
下一期将阐述 &lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/">Istio 中实现出口流量的安全管控&lt;/a>，并和其它方案进行对比。&lt;/p>
&lt;p>对于服务网格来说入口流量才是最重要的安全问题。一定要防止入侵者通过入口 API 渗透集群。既然这么说，流出服务网格的安全同样非常重要。一旦集群被攻破，你必须要有预案，尽可能的减少损害，并且要阻止攻击者使用集群对集群外的服务和已有系统进行进一步攻击。要达到这么目标，需要出口流量的安全管控。&lt;/p>
&lt;p>合规要求是要实施出口流量安全管控的另外一个原因。例如，&lt;a href="https://www.pcisecuritystandards.org/pci_security/">支付卡行业 (PCI) 数据安全标准&lt;/a>进出流量都必须限制在必要的范围之内：&lt;/p>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">&lt;em>1.2.1 将入口和出口流量限制为持卡人数据环境所必需的流量，并明确拒绝所有其他流量。&lt;/em>&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>特别是对出口流量：&lt;/p>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">&lt;em>1.3.4 不允许持卡人数据环境没有授权的出站流量进入互联网。持卡人数据环境流出的所有流量应该做评估，以保证流量符合既定的授权规则。应该检查链接上的流量并限制只允许认证过的通信（例如：通过限制源/目的的地址/端口，包括限制传输内容）。&lt;/em>&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>我们从涉及出口流量的攻击开始。&lt;/p>
&lt;h2 id="the-attacks">流量攻击&lt;/h2>
&lt;p>在还没有被攻击的时候 IT 部门就必须要假设会被攻击，并且它的部分基础设施可能已经损坏或者未来会出现损坏。一旦攻击者能渗透集群中的应用程序，他们就可以继续攻击外部服务了：已有系统，外部 web 服务和数据库。攻击者可能想偷取应用程序的数据并且发送到他们的外部服务上。攻击者的恶意程序会访问攻击者的服务器来下载更新。攻击者可能使用集群中的 pod 执行 DDOS 攻击或者闯入外部系统。即便您&lt;a href="https://en.wikipedia.org/wiki/There_are_known_knowns">不知道&lt;/a>攻击的所有可能类型，你还是想减少任何攻击的可能性，无论是已知还是未知的攻击。&lt;/p>
&lt;p>外部攻击者通过应用程序的缺陷从服务网格外部访问到应用程序的容器进行攻击，但是攻击者同样也可能来自内部，比如：组织内部的恶意 DevOps 人员。&lt;/p>
&lt;p>为了防止以上所说的攻击，必须应用一些出口流量管控策略。我们在下一节介绍出口流量管控。&lt;/p>
&lt;h2 id="the-solution-secure-control-of-egress-traffic">出口流量安全管控解决方案&lt;/h2>
&lt;p>出口流量安全管控的意思是监控出口流量并且针对出口流量应用所有的安全策略。
监控出口流量，可以对它进行分析（可能是离线的），即便你无法实时阻止攻击，也要检测攻击事件。
另外一个减少攻击可能性的方法是遵循&lt;a href="https://en.wikipedia.org/wiki/Need_to_know#In_computer_technology]">需要知道&lt;/a>的原则进行指定限制访问策略。&lt;/p>
&lt;p>现在来看看已经收集到的出口流量管控要求。&lt;/p>
&lt;h2 id="requirements-for-egress-traffic-control">出口流量管控要求&lt;/h2>
&lt;p>我的同事（在 IBM）和我从一些客户那里收集了一些出口流量安全管控的要求，并把它们和 &lt;a href="https://docs.google.com/document/d/1-Cq_Y-yuyNklvdnaZF9Qngl3xe0NnArT7Xt_Wno9beg">Kubernetes 网络特定兴趣小组的出口流量管控要求&lt;/a>做了整合。&lt;/p>
&lt;p>Istio 1.1 满足所有的收集要求：&lt;/p>
&lt;ol>
&lt;li>&lt;p>使用 &lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI&lt;/a> 支持 &lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security">TLS&lt;/a> 或者用 Istio 支持 &lt;a href="/v1.8/zh/docs/reference/glossary/#tls-origination">TLS 源&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>监视器&lt;/strong> SNI 和每个出口访问的源 workload。&lt;/p>&lt;/li>
&lt;li>&lt;p>定义和执行 &lt;strong>每个集群的策略&lt;/strong>，比如：&lt;/p>
&lt;ul>
&lt;li>&lt;p>集群中所有应用程序可能访问 &lt;code>service1.foo.com&lt;/code> （指定的主机）&lt;/p>&lt;/li>
&lt;li>&lt;p>集群中所有的应用程序可能访问 &lt;code>*.bar.com&lt;/code> (泛域名) 下的任何主机&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>必须阻止所有未明确的访问。&lt;/p>&lt;/li>
&lt;li>&lt;p>定义和执行&lt;strong>每个源的策略&lt;/strong>，_Kubernetes 可感知_：&lt;/p>
&lt;ul>
&lt;li>&lt;p>应用 &lt;code>A&lt;/code> 可能访问 &lt;code>*.foo.com&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>应用 &lt;code>B&lt;/code> 可能访问 &lt;code>*.bar.com&lt;/code>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>必须阻止其他访问，尤其是应用 &lt;code>A&lt;/code> 到 &lt;code>service1.bar.com&lt;/code> 的访问。&lt;/p>&lt;/li>
&lt;li>&lt;p>**防篡改*。万一有一个应用的 pod 被破坏了，要防止受损的 pod 逃离监控，防止发送假信息给监控系统，防止破坏出口策略。&lt;/p>&lt;/li>
&lt;li>&lt;p>有这点就更好：流量管控对应用程序要&lt;strong>透明&lt;/strong>。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>对每个要求我来详细介绍以下。第一个要求指出，必须支持对外服务访问只能使用 TLS。在看到所有出集群的流量都必须加密后，这个要求就出现了。这意味着要么是应用程序执行 TLS，要么是 Istio 必须为应用程序执行 TLS。
注意如果应用程序执行了 TLS，Istio 代理是无法看到原始的流量的，只能看到加密后的，所以代理只能看到 TLS 协议。对代理来说它不关心原始协议是 HTTP 还是 MongoDB ，所有的 Istio 代理只能看到 TLS 流量。&lt;/p>
&lt;p>第二个要求指出：必须监控 SNI 和流量源。监控是防止攻击的第一步。即使攻击者可以从集群内访问外部服务，如果监控了访问请求，就会有机会发现可疑流量并且采取纠正措施。&lt;/p>
&lt;p>注意如果是应用程序发起的 TLS，Istio 的 sidecar 代理就只能看到 TCP 流量和包含 SNI 的 TLS 握手。源 pod 的标签可以识别出流量来源，但是 pod 的服务账号或者其它源识标识符也可以用来识别流量。我们把出口流量管控系统的这个特性叫做 _Kubernetes 可感知_：这个系统必须理解 Kubernetes 组件，比如 pod 和服务账号。如果这个系统不是 Kubernetes 可感知的，那它只能监控 IP 地址，并把它作为源的标示。&lt;/p>
&lt;p>第三个要求指出：Istio 运维人员必须能为整个集群所有的出口流量定规策略。策略指出集群中的 pod 可能会访问哪些外部服务。外部服务可以通过服务的&lt;a href="https://en.wikipedia.org/wiki/Fully_qualified_domain_name">全域名&lt;/a> （比如 &lt;code>www.ibm.com&lt;/code>）或者泛域名（比如：&lt;code>*.ibm.com&lt;/code>）进行标示。只有指定的外部服务可以访问，其它所有的出口流量都要被阻止。&lt;/p>
&lt;p>这个要求是为了阻止攻击者访问恶意站点而提出的，比如下载更新/操作他们的恶意软件。同样也想去限制攻击者可以访问和攻击的外部站点的数量。只允许集群内应用程序需要访问的外部站点并且阻止其它所拥有的服务访问，这样减少了&lt;a href="https://en.wikipedia.org/wiki/Attack_surface">攻击面&lt;/a>。当外部服务有了它们自己的安全机制，你想使用&lt;a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">纵深防御&lt;/a>并且使用多个安全层：除了外部系统的安全层外，集群内还有一个安全层。&lt;/p>
&lt;p>这个要求意味着外部服务必须能用域名来标示。我们把出口管控系统的这个特性叫做 DNS 感知。如果系统不是 DNS 可感知的，外部服务必须用 IP 地址标示。
使用 IP 地址不方便而且经常不灵活，因为服务的 IP 地址会变的。有时候服务的所有 IP 地址甚至都不知道，比如：&lt;a href="https://en.wikipedia.org/wiki/Content_delivery_network">CDN&lt;/a>。&lt;/p>
&lt;p>第四个要求指出：出口流量的源都必须添加策略，以高效扩展第三个要求。策略能明确那个源可以访问那个外部服务，并且就像第二个要求一样源必须要标示，例如：通过源 pod 的标签或者通过 pod 的服务账号。
这意味这策略的执行也必须是 Kubernetes 可感知的。如果策略执行不是 Kubernetes 可感知的，策略必须通过 pod 的 IP 来标示流量的源头，使用 pod 的 IP 是不方便的，特别是 pod 启动和销毁，而它们的 IP 是不固定的。&lt;/p>
&lt;p>第五个要求指出：即使集群被攻破并且攻击者管控了一些 pod，他们也必须不能欺骗监控或者违反出口管控系统的策略。我们才能说这样的系统提供了出口流量的安全管控。&lt;/p>
&lt;p>第六个要求指出：提供的流量管控服务要不能改变应用程序容器，特别是不能修改应用程序代码和不能修改容器环境。我们把这样的做法称为透明出口流量管控。&lt;/p>
&lt;p>在下一篇文章中，我将展示 Istio 作为出口流量管控系统的示例，由此说明它可以满足所有这些要求，特别是它的透明性、DNS 感知能力和 Kubernetes 感知能力。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>希望您确信对于集群安全来说出口流量管控是非常重要的。在&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-2/">这个系列文章的第二部分&lt;/a>我讲述了使用 Istio 实现出口流量安全管控的方法。在&lt;a href="/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-3/">这个系列文章的第三部分&lt;/a>我和其它方案进行了对比，比如 &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Kubernetes 网络策略&lt;/a>以及已有的其它出口代理/防火墙方案。&lt;/p></description><pubDate>Wed, 22 May 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-1/</link><author>Vadim Eisenberg (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/egress-traffic-control-in-istio-part-1/</guid><category>traffic-management</category><category>egress</category><category>security</category></item><item><title>为性能而设计的 Istio 1.1</title><description>
&lt;p>构建一个超大规模的基于微服务的云环境一直令人非常兴奋，但却难于管理。随之而来的是 2014 年的 Kubernetes（容器编排引擎），接着是 2017 年的 Istio（容器服务管理），这两个开源项目让开发者无需在管理上耗费太多时间即可扩展基于容器的应用程序。&lt;/p>
&lt;p>现在，Istio 1.1 新的增强功能带来了改进的应用性能和服务管理效率，以便扩大规模。相比于 Istio 1.0，使用我们的示例商业航班预订程序的模拟显示出了如下改进。&lt;/p>
&lt;p>我们看到大量的应用程序性能提升:&lt;/p>
&lt;ul>
&lt;li>应用程序平均延迟降低 30％&lt;/li>
&lt;li>在大型网格中服务启动时间快 40％&lt;/li>
&lt;/ul>
&lt;p>同样还有服务管理效率的显著提升:&lt;/p>
&lt;ul>
&lt;li>在大型网格中，Pilot 的 CPU 使用率降低了 90％&lt;/li>
&lt;li>在大型网格中，Pilot 的内存使用率降低了 50％&lt;/li>
&lt;/ul>
&lt;p>使用 Istio 1.1，企业会对一致性和可控的应用程序扩展能力更加自信 —— 即使在超大规模的云环境中也无所畏惧。&lt;/p>
&lt;p>祝贺那些来自世界各地的为此次版本发布做出贡献的 Istio 专家。我们对这些结果无比高兴。&lt;/p>
&lt;h2 id="istio-1-1-性能增强-istio-1-1-performance-enhancements">Istio 1.1 性能增强{Istio-1-1-performance-enhancements}&lt;/h2>
&lt;p>作为 Istio Performance and Scalability （性能和可伸缩）工作组的成员，我们进行了广泛的性能评估。我们与其他 Istio 贡献者合作，为 Istio 1.1 引入了许多旨在提高性能的新特性。1.1 中一些显著的性能增强包括:&lt;/p>
&lt;ul>
&lt;li>Envoy 生成统计数据的默认集合显著减少&lt;/li>
&lt;li>为 Mixer 工作负载添加了减载特性&lt;/li>
&lt;li>改进了 Envoy 和 Mixer 之间的协议&lt;/li>
&lt;li>隔离命名空间以减少操作开销&lt;/li>
&lt;li>可配置的并发工作线程，可以提高整体吞吐量&lt;/li>
&lt;li>为限制遥测数据的可配置过滤器&lt;/li>
&lt;li>解除同步瓶颈&lt;/li>
&lt;/ul>
&lt;h2 id="持续的代码质量和性能验证-continuous-code-quality-and-performance-verification">持续的代码质量和性能验证{continuous-code-quality-and-performance-verification}&lt;/h2>
&lt;p>回归巡检促进了 Istio 性能和质量的不断提高，在幕后帮助 Istio 开发者识别并修正代码错误。每天的构建都会经过以客户为中心的性能基准 &lt;a href="https://github.com/blueperf/">BluePerf&lt;/a> 的性能检测。测试结果会展示在 &lt;a href="https://ibmcloud-perf.istio.io/regpatrol/">Istio 社区门户网站&lt;/a>。评估了各种应用配置以帮助洞悉 Istio 组件的性能。&lt;/p>
&lt;p>另一个用于评估 Istio 构建性能的工具是 &lt;a href="https://fortio.org/">Fortio&lt;/a>，它提供了一个综合的端到端的压力测试基准。&lt;/p>
&lt;h2 id="概要-summary">概要{summary}&lt;/h2>
&lt;p>Istio 1.1 旨在提高性能和可扩展性。Istio Performance and Scalability （性能和可扩展性）工作组实现了自 1.0 以来显著的性能改进。
Istio 1.1 提供的新特性和功能优化，提高了服务网格对企业工作负载的支撑能力。Istio 1.1 性能和调优指南记录了性能模拟，提供了调整和容量规划指导，并包含了调优客户用例的最佳实践。&lt;/p>
&lt;h2 id="有用的链接-useful-links">有用的链接{useful-links}&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.youtube.com/watch?time_continue=349&amp;amp;v=G4F5aRFEXnU">Istio 服务网格性能 (34:30)&lt;/a>, 作者：Surya Duggirala, Laurent Demailly 和 Fawad Khaliq 于 KubeCon Europe 2018&lt;/li>
&lt;li>&lt;a href="https://discuss.istio.io/c/performance-and-scalability">Istio 性能和可扩展性讨论专题&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="免责声明-disclaimer">免责声明{disclaimer}&lt;/h2>
&lt;p>这里展示的性能数据是在一个可控的隔离环境中产生的。在其他环境中获得的实际结果可能存在较大差异。无法保证在其他地方获得相同或类似的结果。&lt;/p></description><pubDate>Tue, 19 Mar 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/istio1.1_perf/</link><author>Surya V Duggirala (IBM), Mandar Jog (Google), Jose Nativio (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/istio1.1_perf/</guid><category>performance</category><category>scalability</category><category>scale</category><category>benchmarks</category></item><item><title>多集群服务网格中的分版本路由</title><description>
&lt;p>如果花一点时间对 Istio 进行了解，你可能会注意到，大量的功能都可以在单一的 Kubernetes 集群中，用简单的&lt;a href="/v1.8/zh/docs/tasks">任务&lt;/a>和&lt;a href="/v1.8/zh/docs/examples/">示例&lt;/a>所表达的方式来运行。但是真实世界中的云计算和基于微服务的应用往往不是这么简单的，会需要在不止一个地点分布运行，用户难免会产生怀疑，生产环境中是否还能这样运行？&lt;/p>
&lt;p>幸运的是，Istio 提供了多种服务网格的配置方式，应用能够用近乎透明的方式加入一个跨越多个集群运行的服务网格之中，也就是&lt;a href="/v1.8/zh/docs/ops/deployment/deployment-models/#multiple-clusters">多集群服务网格&lt;/a> 。最简单的设置多集群网格的方式，就是使用&lt;a href="/v1.8/zh/docs/ops/deployment/deployment-models/#control-plane-models">多控制平面拓扑&lt;/a> ，这种方式不需要特别的网络依赖。在这种条件下，每个 Kubernetes 集群都有自己的控制平面，但是每个控制平面都是同步的，并接受统一的管理。&lt;/p>
&lt;p>本文中，我们会在多控制平面拓扑形式的多集群网格中尝试一下 Istio 的&lt;a href="/v1.8/zh/docs/concepts/traffic-management/">流量管理&lt;/a>功能。我们会展示如何配置 Istio 路由规则，在多集群服务网格中部署 &lt;a href="https://github.com/istio/istio/tree/release-1.8/samples/bookinfo">Bookinfo 示例&lt;/a>，&lt;code>reviews&lt;/code> 服务的 &lt;code>v1&lt;/code> 版本运行在一个集群上，而 &lt;code>v2&lt;/code> 和 &lt;code>v3&lt;/code> 运行在另一个集群上，并完成远程服务调用。&lt;/p>
&lt;h2 id="setup-clusters">集群部署&lt;/h2>
&lt;p>首先需要部署两个 Kubernetes 集群，并各自运行一个做了轻度定制的 Istio。&lt;/p>
&lt;ul>
&lt;li>&lt;p>依照&lt;a href="/v1.8/zh/docs/setup/install/multicluster/gateways/">使用 Gateway 连接多个集群&lt;/a>中提到的步骤设置一个多集群环境。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;code>kubectl&lt;/code> 命令可以使用 &lt;code>--context&lt;/code> 参数访问两个集群。
使用下面的命令列出所有 &lt;code>context&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl config get-contexts
CURRENT NAME CLUSTER AUTHINFO NAMESPACE
* cluster1 cluster1 user@foo.com default
cluster2 cluster2 user@foo.com default
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>将配置文件中的 &lt;code>context&lt;/code> 名称赋值给两个环境变量：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export CTX_CLUSTER1=&amp;lt;cluster1 context name&amp;gt;
$ export CTX_CLUSTER2=&amp;lt;cluster2 context name&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;h2 id="deploy-in-cluster-1">在 &lt;code>cluster1&lt;/code> 中部署 &lt;code>bookinfo&lt;/code> 的 &lt;code>v1&lt;/code> 版本&lt;/h2>
&lt;p>在 &lt;code>cluster1&lt;/code> 中运行 &lt;code>productpage&lt;/code> 和 &lt;code>details&lt;/code> 服务，以及 &lt;code>reviews&lt;/code> 服务的 &lt;code>v1&lt;/code> 版本。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl label --context=$CTX_CLUSTER1 namespace default istio-injection=enabled
$ kubectl apply --context=$CTX_CLUSTER1 -f - &amp;lt;&amp;lt;EOF
apiVersion: v1
kind: Service
metadata:
name: productpage
labels:
app: productpage
spec:
ports:
- port: 9080
name: http
selector:
app: productpage
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: productpage-v1
spec:
replicas: 1
template:
metadata:
labels:
app: productpage
version: v1
spec:
containers:
- name: productpage
image: istio/examples-bookinfo-productpage-v1:1.10.0
imagePullPolicy: IfNotPresent
ports:
- containerPort: 9080
---
apiVersion: v1
kind: Service
metadata:
name: details
labels:
app: details
spec:
ports:
- port: 9080
name: http
selector:
app: details
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: details-v1
spec:
replicas: 1
template:
metadata:
labels:
app: details
version: v1
spec:
containers:
- name: details
image: istio/examples-bookinfo-details-v1:1.10.0
imagePullPolicy: IfNotPresent
ports:
- containerPort: 9080
---
apiVersion: v1
kind: Service
metadata:
name: reviews
labels:
app: reviews
spec:
ports:
- port: 9080
name: http
selector:
app: reviews
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: reviews-v1
spec:
replicas: 1
template:
metadata:
labels:
app: reviews
version: v1
spec:
containers:
- name: reviews
image: istio/examples-bookinfo-reviews-v1:1.10.0
imagePullPolicy: IfNotPresent
ports:
- containerPort: 9080
EOF
&lt;/code>&lt;/pre>
&lt;h2 id="deploy-in-cluster-2">在 &lt;code>cluster2&lt;/code> 中部署 &lt;code>bookinfo&lt;/code> 的 &lt;code>v2&lt;/code> 和 &lt;code>v3&lt;/code>&lt;/h2>
&lt;p>在 &lt;code>cluster2&lt;/code> 中运行 &lt;code>ratings&lt;/code> 服务以及 &lt;code>reviews&lt;/code> 服务的 &lt;code>v2&lt;/code> 和 &lt;code>v3&lt;/code> 版本：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl label --context=$CTX_CLUSTER2 namespace default istio-injection=enabled
$ kubectl apply --context=$CTX_CLUSTER2 -f - &amp;lt;&amp;lt;EOF
apiVersion: v1
kind: Service
metadata:
name: ratings
labels:
app: ratings
spec:
ports:
- port: 9080
name: http
selector:
app: ratings
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: ratings-v1
spec:
replicas: 1
template:
metadata:
labels:
app: ratings
version: v1
spec:
containers:
- name: ratings
image: istio/examples-bookinfo-ratings-v1:1.10.0
imagePullPolicy: IfNotPresent
ports:
- containerPort: 9080
---
apiVersion: v1
kind: Service
metadata:
name: reviews
labels:
app: reviews
spec:
ports:
- port: 9080
name: http
selector:
app: reviews
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: reviews-v2
spec:
replicas: 1
template:
metadata:
labels:
app: reviews
version: v2
spec:
containers:
- name: reviews
image: istio/examples-bookinfo-reviews-v2:1.10.0
imagePullPolicy: IfNotPresent
ports:
- containerPort: 9080
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: reviews-v3
spec:
replicas: 1
template:
metadata:
labels:
app: reviews
version: v3
spec:
containers:
- name: reviews
image: istio/examples-bookinfo-reviews-v3:1.10.0
imagePullPolicy: IfNotPresent
ports:
- containerPort: 9080
EOF
&lt;/code>&lt;/pre>
&lt;h2 id="access-the-application">访问 &lt;code>bookinfo&lt;/code> 应用&lt;/h2>
&lt;p>和平常一样，我们需要使用一个 Istio gateway 来访问 &lt;code>bookinfo&lt;/code> 应用。&lt;/p>
&lt;ul>
&lt;li>&lt;p>在 &lt;code>cluster1&lt;/code> 中创建 &lt;code>bookinfo&lt;/code> 的网关：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/bookinfo-gateway.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply --context=$CTX_CLUSTER1 -f @samples/bookinfo/networking/bookinfo-gateway.yaml@
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>遵循 &lt;a href="/v1.8/zh/docs/examples/bookinfo/#determine-the-ingress-IP-and-port">Bookinfo 示例应用&lt;/a>中的步骤，确定 Ingress 的 IP 和端口，用浏览器打开 &lt;code>http://$GATEWAY_URL/productpage&lt;/code>。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>这里会看到 &lt;code>productpage&lt;/code>，其中包含了 &lt;code>reviews&lt;/code> 的内容，但是没有出现 &lt;code>ratings&lt;/code>，这是因为只有 &lt;code>reviews&lt;/code> 服务的 &lt;code>v1&lt;/code> 版本运行在 &lt;code>cluster1&lt;/code> 上，我们还没有配置到 &lt;code>cluster2&lt;/code> 的访问。&lt;/p>
&lt;h2 id="在-cluster1-上为远端的-reviews-服务创建-serviceentry-以及-destinationrule">在 &lt;code>cluster1&lt;/code> 上为远端的 &lt;code>reviews&lt;/code> 服务创建 &lt;code>ServiceEntry&lt;/code> 以及 &lt;code>DestinationRule&lt;/code>&lt;/h2>
&lt;p>根据&lt;a href="/v1.8/zh/docs/setup/install/multicluster/gateways/#setup-DNS">配置指南&lt;/a>中的介绍，远程服务可以用一个 &lt;code>.global&lt;/code> 的 DNS 名称进行访问。在我们的案例中，就是 &lt;code>reviews.default.global&lt;/code>，所以我们需要为这个主机创建 &lt;code>ServiceEntry&lt;/code> 和 &lt;code>DestinationRule&lt;/code>。&lt;code>ServiceEntry&lt;/code> 会使用 &lt;code>cluster2&lt;/code> 网关作为端点地址来访问服务。可以使用网关的 DNS 名称或者公共 IP：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export CLUSTER2_GW_ADDR=$(kubectl get --context=$CTX_CLUSTER2 svc --selector=app=istio-ingressgateway \
-n istio-system -o jsonpath=&amp;#34;{.items[0].status.loadBalancer.ingress[0].ip}&amp;#34;)
&lt;/code>&lt;/pre>
&lt;p>用下面的命令来创建 &lt;code>ServiceEntry&lt;/code> 和 &lt;code>DestinationRule&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply --context=$CTX_CLUSTER1 -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: reviews-default
spec:
hosts:
- reviews.default.global
location: MESH_INTERNAL
ports:
- name: http1
number: 9080
protocol: http
resolution: DNS
addresses:
- 240.0.0.3
endpoints:
- address: ${CLUSTER2_GW_ADDR}
labels:
cluster: cluster2
ports:
http1: 15443 # 不要修改端口值
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: reviews-global
spec:
host: reviews.default.global
trafficPolicy:
tls:
mode: ISTIO_MUTUAL
subsets:
- name: v2
labels:
cluster: cluster2
- name: v3
labels:
cluster: cluster2
EOF
&lt;/code>&lt;/pre>
&lt;p>&lt;code>ServiceEntry&lt;/code> 的地址 &lt;code>240.0.0.3&lt;/code> 可以是任意的未分配 IP。在 &lt;code>240.0.0.0/4&lt;/code> 的范围里面进行选择是个不错的主意。阅读&lt;a href="/v1.8/zh/docs/setup/install/multicluster/gateways/#configure-the-example-services">通过网关进行连接的多集群&lt;/a>一文，能够获得更多相关信息。&lt;/p>
&lt;p>注意 &lt;code>DestinationRule&lt;/code> 中的 &lt;code>subset&lt;/code> 的标签，&lt;code>cluster: cluster2&lt;/code> 对应的是 &lt;code>cluster2&lt;/code> 网关。一旦流量到达目标集群，就会由本地目的 &lt;code>DestinationRule&lt;/code> 来鉴别实际的 Pod 标签（&lt;code>version: v1&lt;/code> 或者 &lt;code>version: v2&lt;/code>）&lt;/p>
&lt;h2 id="在所有集群上为本地-reviews-服务创建-destinationrule">在所有集群上为本地 &lt;code>reviews&lt;/code> 服务创建 &lt;code>DestinationRule&lt;/code>&lt;/h2>
&lt;p>技术上来说，我们只需要为每个集群定义本地的 &lt;code>subset&lt;/code> 即可（&lt;code>cluster1&lt;/code> 中的 &lt;code>v1&lt;/code>，&lt;code>cluster2&lt;/code> 中的 &lt;code>v2&lt;/code> 和 &lt;code>v3&lt;/code>），但是定义一个用不到的并未部署的版本也没什么大碍，为了清晰一点，我们会在两个集群上都创建全部三个 &lt;code>subset&lt;/code>。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply --context=$CTX_CLUSTER1 -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: reviews
spec:
host: reviews.default.svc.cluster.local
trafficPolicy:
tls:
mode: ISTIO_MUTUAL
subsets:
- name: v1
labels:
version: v1
- name: v2
labels:
version: v2
- name: v3
labels:
version: v3
EOF
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply --context=$CTX_CLUSTER2 -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: reviews
spec:
host: reviews.default.svc.cluster.local
trafficPolicy:
tls:
mode: ISTIO_MUTUAL
subsets:
- name: v1
labels:
version: v1
- name: v2
labels:
version: v2
- name: v3
labels:
version: v3
EOF
&lt;/code>&lt;/pre>
&lt;h2 id="create-a-destination-rule-on-both-clusters-for-the-local-reviews-service">创建 &lt;code>VirtualService&lt;/code> 来路由 &lt;code>reviews&lt;/code> 服务的流量&lt;/h2>
&lt;p>目前所有调用 &lt;code>reviews&lt;/code> 服务的流量都会进入本地的 &lt;code>reviews&lt;/code> Pod，也就是 &lt;code>v1&lt;/code>，如果查看一下远吗，会发现 &lt;code>productpage&lt;/code> 的实现只是简单的对 &lt;code>http://reviews:9080&lt;/code> （也就是 &lt;code>reviews.default.svc.cluster.local&lt;/code>）发起了请求，也就是本地版本。对应的远程服务名称为 &lt;code>reviews.default.global&lt;/code>，所以需要用路由规则来把请求转发到远端集群。&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">注意如果所有版本的 &lt;code>reviews&lt;/code> 服务都在远端，也就是说本地没有 &lt;code>reviews&lt;/code> 服务，那么 DNS 就会把 &lt;code>reviews&lt;/code> 直接解析到 &lt;code>reviews.default.global&lt;/code>，在本文的环境里，无需定义任何路由规则就可以发起对远端集群的请求。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>创建下列的 &lt;code>VirtualService&lt;/code>，把 &lt;code>jason&lt;/code> 的流量转发给运行在 &lt;code>cluster2&lt;/code> 上的 &lt;code>v2&lt;/code> 和 &lt;code>v3&lt;/code> 版本的 &lt;code>reviews&lt;/code>，两个版本各负责一半流量。其他用户的流量还是会发给 &lt;code>v1&lt;/code> 版本的 &lt;code>reviews&lt;/code>。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply --context=$CTX_CLUSTER1 -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: reviews
spec:
hosts:
- reviews.default.svc.cluster.local
http:
- match:
- headers:
end-user:
exact: jason
route:
- destination:
host: reviews.default.global
subset: v2
weight: 50
- destination:
host: reviews.default.global
subset: v3
weight: 50
- route:
- destination:
host: reviews.default.svc.cluster.local
subset: v1
EOF
&lt;/code>&lt;/pre>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">这种平均分配的规则并不实际，只是一种用于演示远端服务多版本之间流量分配的方便手段。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>回到浏览器，用 &lt;code>jason&lt;/code> 的身份登录。刷新页面几次，会看到星形图标在红黑两色之间切换（&lt;code>v2&lt;/code> 和 &lt;code>v3&lt;/code>）。如果登出，就只会看到没有 &lt;code>ratings&lt;/code> 的 &lt;code>reviews&lt;/code> 服务了。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>本文中，我们看到在多控制平面拓扑的多集群网格中，如何使用 Istio 路由规则进行跨集群的流量分配。
这里我们手工配置了 &lt;code>.global&lt;/code> 的 &lt;code>ServiceEntry&lt;/code> 以及 &lt;code>DestinationRule&lt;/code>，用于进行对远端集群中 &lt;code>reviews&lt;/code> 服务的访问。实际上如果我们想要的话，可以让任何服务都在远端或本地运行，当然需要为远端服务配置 &lt;code>.global&lt;/code> 的相关资源。幸运的是，这个过程可以自动化，并且可能在 Istio 的未来版本中实现。&lt;/p></description><pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/multicluster-version-routing/</link><author>Frank Budinsky (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/multicluster-version-routing/</guid><category>traffic-management</category><category>multicluster</category></item><item><title>博客策略更新！</title><description>&lt;p>欢迎来到 Istio 博客！&lt;/p>
&lt;p>为了让你更方便的在我们的网站上发表博客，我们&lt;a href="/v1.8/zh/about/contribute/add-content/#content-types">更新了内容类型指南&lt;/a>。&lt;/p>
&lt;p>这次更新的目标是对内容进行更方便的分享和搜索。&lt;/p>
&lt;p>我们希望更简单地共享 Istio 方面的最新信息，&lt;a href="/v1.8/zh/blog">Istio 博客&lt;/a>是一个好的出发点。&lt;/p>
&lt;p>如果你认为你的内容符合下面三个分类中的一个，我们非常欢迎将其提交到 Istio 博客之中。&lt;/p>
&lt;ul>
&lt;li>文章中详细介绍了你在使用和配置 Istio 中的经验。如果分享了一种新的观点或体验，那就更好了。&lt;/li>
&lt;li>文章中着重介绍了 Istio 的功能。&lt;/li>
&lt;li>文章中详细讲解了使用 Istio 完成一个任务或者满足特定用例需求的相关内容。&lt;/li>
&lt;/ul>
&lt;p>仅需&lt;a href="/v1.8/zh/about/contribute/github/">提交一个 PR&lt;/a> 就可以发表您的博客，如果需要，可以&lt;a href="/v1.8/zh/about/contribute/review">申请评审&lt;/a>。&lt;/p>
&lt;p>我们期待能够很快就能在博客上看到你的 Istio 体验！&lt;/p></description><pubDate>Tue, 05 Feb 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/sail-the-blog/</link><author>Rigs Caballero, Google</author><guid isPermaLink="true">/v1.8/zh/blog/2019/sail-the-blog/</guid><category>community</category><category>blog</category><category>contribution</category><category>guide</category><category>guideline</category><category>event</category></item><item><title>揭开 Istio Sidecar 注入模型的神秘面纱</title><description>
&lt;p>Istio 服务网格体系结构的简单概述总是从控制平面和数据平面开始。&lt;/p>
&lt;p>从 &lt;a href="/v1.8/zh/docs/ops/deployment/architecture/">Istio 的文档&lt;/a> :&lt;/p>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">&lt;p>Istio 服务网格在逻辑上分为数据平面和控制平面。&lt;/p>
&lt;p>数据平面由一组部署为 sidecar 的智能代理（Envoy）组成。这些代理与 Mixer、通用策略和遥测中心协调并控制微服务之间的所有网络通信。&lt;/p>
&lt;p>控制平面管理并配置从代理到路由的流量。此外，控制平面配置 Mixer 以执行策略和收集遥测数据。&lt;/p>
&lt;/div>
&lt;/aside>
&lt;/div>
&lt;figure style="width:40%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:80%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/data-plane-setup/arch-2.svg" title="Istio Architecture">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/data-plane-setup/arch-2.svg" alt="基于 Istio 的应用程序的总体架构。" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio Architecture&lt;/figcaption>
&lt;/figure>
&lt;p>重要的是要理解向应用程序 pod 中注入边车是自动进行的，尽管也可以手动注入。流量从应用服务流向 sidecar，而开发人员无需关心它。一旦将应用程序连接到 Istio 服务网格，开发者便可以开始使用并获得服务网格中的所有效益。但是，数据平面管道是如何发生的，以及无缝迁移工作的真正要求是什么？在本文中，我们将深入研究 Sidecar 注入模型的细节，以非常清楚地理解 Sidecar 注入的工作原理。&lt;/p>
&lt;h2 id="sidecar-injection">Sidecar 注入&lt;/h2>
&lt;p>简单来说，Sidecar 注入会将额外容器的配置添加到 Pod 模板中。Istio 服务网格目前所需的容器有：&lt;/p>
&lt;p>&lt;code>istio-init&lt;/code>
&lt;a href="https://kubernetes.io/docs/concepts/workloads/pods/init-containers/">init 容器&lt;/a>用于设置 iptables 规则，以便将入站/出站流量通过 sidecar 代理。初始化容器与应用程序容器在以下方面有所不同：&lt;/p>
&lt;ul>
&lt;li>它在启动应用容器之前运行，并一直运行直至完成。&lt;/li>
&lt;li>如果有多个初始化容器，则每个容器都应在启动下一个容器之前成功完成。&lt;/li>
&lt;/ul>
&lt;p>因此，您可以看到，对于不需要成为实际应用容器一部分的设置或初始化作业来说，这种容器是多么的完美。在这种情况下，&lt;code>istio-init&lt;/code> 就是这样做并设置了 &lt;code>iptables&lt;/code> 规则。&lt;/p>
&lt;p>&lt;code>istio-proxy&lt;/code>
这个容器是真正的 sidecar 代理（基于 Envoy）。&lt;/p>
&lt;h3 id="manual-injection">手动注入&lt;/h3>
&lt;p>在手动注入方法中，可以使用 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl">&lt;code>istioctl&lt;/code>&lt;/a> 修改容器模板并添加前面提到的两个容器的配置。不论是手动注入还是自动注入，Istio 都从 &lt;code>istio-sidecar-injector&lt;/code> 和的 &lt;code>istio&lt;/code> 两个 Configmap 对象中获取配置。&lt;/p>
&lt;p>我们先来看看 &lt;code>istio-sidecar-injector&lt;/code> Configmap 的配置，了解一下其中的内容。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-outputis='yaml' data-repo='istio' >$ kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath=&amp;#39;{.data.config}&amp;#39;
以下代码片段来自 output：
policy: enabled
template: |-
initContainers:
- name: istio-init
image: docker.io/istio/proxy_init:1.0.2
args:
- &amp;#34;-p&amp;#34;
- [[ .MeshConfig.ProxyListenPort ]]
- &amp;#34;-u&amp;#34;
- 1337
.....
imagePullPolicy: IfNotPresent
securityContext:
capabilities:
add:
- NET_ADMIN
restartPolicy: Always
containers:
- name: istio-proxy
image: [[ if (isset .ObjectMeta.Annotations &amp;#34;sidecar.istio.io/proxyImage&amp;#34;) -]]
&amp;#34;[[ index .ObjectMeta.Annotations &amp;#34;sidecar.istio.io/proxyImage&amp;#34; ]]&amp;#34;
[[ else -]]
docker.io/istio/proxyv2:1.0.2
[[ end -]]
args:
- proxy
- sidecar
.....
env:
.....
- name: ISTIO_META_INTERCEPTION_MODE
value: [[ or (index .ObjectMeta.Annotations &amp;#34;sidecar.istio.io/interceptionMode&amp;#34;) .ProxyConfig.InterceptionMode.String ]]
imagePullPolicy: IfNotPresent
securityContext:
readOnlyRootFilesystem: true
[[ if eq (or (index .ObjectMeta.Annotations &amp;#34;sidecar.istio.io/interceptionMode&amp;#34;) .ProxyConfig.InterceptionMode.String) &amp;#34;TPROXY&amp;#34; -]]
capabilities:
add:
- NET_ADMIN
restartPolicy: Always
.....
&lt;/code>&lt;/pre>
&lt;p>如您所见，configmap 包含了 &lt;code>istio-init&lt;/code> 初始化容器和 &lt;code>istio-proxy&lt;/code> 代理容器的配置。该配置包括容器镜像的名称以及拦截模式，权限要求等参数。&lt;/p>
&lt;p>从安全的角度来看，重要的是要注意 &lt;code>istio-init&lt;/code> 需要 &lt;code>NET_ADMIN&lt;/code> 权限来修改 pod 命名空间中的 &lt;code>iptables&lt;/code>，如果 &lt;code>istio-proxy&lt;/code> 是 &lt;code>TPROXY&lt;/code> 模式，也需要这一权限。由于该仅限于 pod 的命名空间，因此应该没有问题。但是，我们注意到最近的 open-shift 版本可能会出现一些问题，因此需要一种解决方法。本文结尾处提到了一个这样的选择。&lt;/p>
&lt;p>要修改当前的 Pod 模板以进行 sidecar 注入，您可以：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl kube-inject -f demo-red.yaml | kubectl apply -f -
&lt;/code>&lt;/pre>
&lt;p>或者&lt;/p>
&lt;p>要使用修改后的 Configmap 或本地 Configmap：&lt;/p>
&lt;ul>
&lt;li>&lt;p>从 configmap 创建 &lt;code>inject-config.yaml&lt;/code> 和 &lt;code>mesh-config.yaml&lt;/code>&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath=&amp;#39;{.data.config}&amp;#39; &amp;gt; inject-config.yaml
$ kubectl -n istio-system get configmap istio -o=jsonpath=&amp;#39;{.data.mesh}&amp;#39; &amp;gt; mesh-config.yaml
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>修改现有的 pod 模板，在这个例子中是，&lt;code>demo-red.yaml&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ istioctl kube-inject --injectConfigFile inject-config.yaml --meshConfigFile mesh-config.yaml --filename demo-red.yaml --output demo-red-injected.yaml
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>提交 &lt;code>demo-red-injected.yaml&lt;/code>&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f demo-red-injected.yaml
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>如上所示，我们使用 &lt;code>sidecar-injector&lt;/code> 和网格配置创建了一个新模板，然后使用 &lt;code>kubectl&lt;/code> 应用该新模板。如果我们查看注入后的 YAML 文件，它具有 Istio 特定容器的配置，如上所述。一旦我们应用注入后的 YAML 文件，我们将看到两个容器正在运行。其中一个是实际的应用程序容器，另一个是 &lt;code>istio-proxy&lt;/code> sidecar。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods | grep demo-red
demo-red-pod-8b5df99cc-pgnl7 2/2 Running 0 3d
&lt;/code>&lt;/pre>
&lt;p>这里没有 3 个 Pod，因为 &lt;code>istio-init&lt;/code> 容器是一个 init 类型的容器，它在完成应做的操作后退出，其用于在 pod 中设置 &lt;code>iptable&lt;/code> 规则。为了确认 init 容器已退出，让我们看一下 &lt;code>kubectl describe&lt;/code> 的输出：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-outputis='yaml' data-repo='istio' >$ kubectl describe pod demo-red-pod-8b5df99cc-pgnl7
以下代码片段来自 output：
Name: demo-red-pod-8b5df99cc-pgnl7
Namespace: default
.....
Labels: app=demo-red
pod-template-hash=8b5df99cc
version=version-red
Annotations: sidecar.istio.io/status={&amp;#34;version&amp;#34;:&amp;#34;3c0b8d11844e85232bc77ad85365487638ee3134c91edda28def191c086dc23e&amp;#34;,&amp;#34;initContainers&amp;#34;:[&amp;#34;istio-init&amp;#34;],&amp;#34;containers&amp;#34;:[&amp;#34;istio-proxy&amp;#34;],&amp;#34;volumes&amp;#34;:[&amp;#34;istio-envoy&amp;#34;,&amp;#34;istio-certs...
Status: Running
IP: 10.32.0.6
Controlled By: ReplicaSet/demo-red-pod-8b5df99cc
Init Containers:
istio-init:
Container ID: docker://bef731eae1eb3b6c9d926cacb497bb39a7d9796db49cd14a63014fc1a177d95b
Image: docker.io/istio/proxy_init:1.0.2
Image ID: docker-pullable://docker.io/istio/proxy_init@sha256:e16a0746f46cd45a9f63c27b9e09daff5432e33a2d80c8cc0956d7d63e2f9185
.....
State: Terminated
Reason: Completed
.....
Ready: True
Containers:
demo-red:
Container ID: docker://8cd9957955ff7e534376eb6f28b56462099af6dfb8b9bc37aaf06e516175495e
Image: chugtum/blue-green-image:v3
Image ID: docker-pullable://docker.io/chugtum/blue-green-image@sha256:274756dbc215a6b2bd089c10de24fcece296f4c940067ac1a9b4aea67cf815db
State: Running
Started: Sun, 09 Dec 2018 18:12:31 -0800
Ready: True
istio-proxy:
Container ID: docker://ca5d690be8cd6557419cc19ec4e76163c14aed2336eaad7ebf17dd46ca188b4a
Image: docker.io/istio/proxyv2:1.0.2
Image ID: docker-pullable://docker.io/istio/proxyv2@sha256:54e206530ba6ca9b3820254454e01b7592e9f986d27a5640b6c03704b3b68332
Args:
proxy
sidecar
.....
State: Running
Started: Sun, 09 Dec 2018 18:12:31 -0800
Ready: True
.....
&lt;/code>&lt;/pre>
&lt;p>从输出中可以看出，&lt;code>istio-init&lt;/code> 容器的 &lt;code>State&lt;/code> 为 &lt;code>Terminated&lt;/code>，而 &lt;code>Reason&lt;/code> 是 &lt;code>Completed&lt;/code>。只有两个容器是运行的，主应用程序 &lt;code>demo-red&lt;/code> 容器和 &lt;code>istio-proxy&lt;/code> 容器。&lt;/p>
&lt;h3 id="automatic-injection">自动注入&lt;/h3>
&lt;p>在大多数情况下，您不想在每次部署应用程序时都使用 &lt;a href="/v1.8/zh/docs/reference/commands/istioctl">&lt;code>istioctl&lt;/code>&lt;/a> 命令手动注入边车，而是希望 Istio 自动将 sidecar 注入到您的 pod 中。这是推荐的方法，要使自动注入生效，您只需要用 &lt;code>istio-injection=enabled&lt;/code> 标记想部署应用程序的命名空间。&lt;/p>
&lt;p>贴上标签后，Istio 会自动为您在该命名空间中部署的所有 pod 注入 sidecar。下面的例子里，&lt;code>istio-dev&lt;/code> 命名空间中部署的 pod 被自动注入了 sidecar：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get namespaces --show-labels
NAME STATUS AGE LABELS
default Active 40d &amp;lt;none&amp;gt;
istio-dev Active 19d istio-injection=enabled
istio-system Active 24d &amp;lt;none&amp;gt;
kube-public Active 40d &amp;lt;none&amp;gt;
kube-system Active 40d &amp;lt;none&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>但它是如何工作的呢？要深入了解这一点，我们需要理解 Kubernetes 准入控制器。&lt;/p>
&lt;p>&lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/">来自 Kubernetes 文档：&lt;/a>&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">准入控制器是一段代码，用于在对象持久化之前但请求已经过身份验证和授权之后，拦截对 Kubernetes API 服务器的请求。您可以定义两种类型的 Admission Webhook：Validating 和 Mutating。Validating 类型的 Webhook 可以根据自定义的准入策略决定是否拒绝请求；Mutating 类型的 Webhook 可以根据自定义配置来对请求进行编辑。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>对于 sidecar 自动注入，Istio 依赖于 &lt;code>Mutating Admission Webhook&lt;/code>。让我们来看看 &lt;code>istio-sidecar-injector&lt;/code> 中的配置详情。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-outputis='yaml' data-repo='istio' >$ kubectl get mutatingwebhookconfiguration istio-sidecar-injector -o yaml
以下代码片段来自 output：
apiVersion: admissionregistration.k8s.io/v1beta1
kind: MutatingWebhookConfiguration
metadata:
annotations:
kubectl.kubernetes.io/last-applied-configuration: |
{&amp;#34;apiVersion&amp;#34;:&amp;#34;admissionregistration.k8s.io/v1beta1&amp;#34;,&amp;#34;kind&amp;#34;:&amp;#34;MutatingWebhookConfiguration&amp;#34;,&amp;#34;metadata&amp;#34;:{&amp;#34;annotations&amp;#34;:{},&amp;#34;labels&amp;#34;:{&amp;#34;app&amp;#34;:&amp;#34;istio-sidecar-injector&amp;#34;,&amp;#34;chart&amp;#34;:&amp;#34;sidecarInjectorWebhook-1.0.1&amp;#34;,&amp;#34;heritage&amp;#34;:&amp;#34;Tiller&amp;#34;,&amp;#34;release&amp;#34;:&amp;#34;istio-remote&amp;#34;},&amp;#34;name&amp;#34;:&amp;#34;istio-sidecar-injector&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;&amp;#34;},&amp;#34;webhooks&amp;#34;:[{&amp;#34;clientConfig&amp;#34;:{&amp;#34;caBundle&amp;#34;:&amp;#34;&amp;#34;,&amp;#34;service&amp;#34;:{&amp;#34;name&amp;#34;:&amp;#34;istio-sidecar-injector&amp;#34;,&amp;#34;namespace&amp;#34;:&amp;#34;istio-system&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/inject&amp;#34;}},&amp;#34;failurePolicy&amp;#34;:&amp;#34;Fail&amp;#34;,&amp;#34;name&amp;#34;:&amp;#34;sidecar-injector.istio.io&amp;#34;,&amp;#34;namespaceSelector&amp;#34;:{&amp;#34;matchLabels&amp;#34;:{&amp;#34;istio-injection&amp;#34;:&amp;#34;enabled&amp;#34;}},&amp;#34;rules&amp;#34;:[{&amp;#34;apiGroups&amp;#34;:[&amp;#34;&amp;#34;],&amp;#34;apiVersions&amp;#34;:[&amp;#34;v1&amp;#34;],&amp;#34;operations&amp;#34;:[&amp;#34;CREATE&amp;#34;],&amp;#34;resources&amp;#34;:[&amp;#34;pods&amp;#34;]}]}]}
creationTimestamp: 2018-12-10T08:40:15Z
generation: 2
labels:
app: istio-sidecar-injector
chart: sidecarInjectorWebhook-1.0.1
heritage: Tiller
release: istio-remote
name: istio-sidecar-injector
.....
webhooks:
- clientConfig:
service:
name: istio-sidecar-injector
namespace: istio-system
path: /inject
name: sidecar-injector.istio.io
namespaceSelector:
matchLabels:
istio-injection: enabled
rules:
- apiGroups:
- &amp;#34;&amp;#34;
apiVersions:
- v1
operations:
- CREATE
resources:
- pods
&lt;/code>&lt;/pre>
&lt;p>在这里，您可以看到与标签 &lt;code>istio-injection:enabled&lt;/code> 相匹配的 webhook &lt;code>namespaceSelector&lt;/code> 标签。在这种情况下，您还会看到在创建容器时要完成的操作和资源。当 &lt;code>apiserver&lt;/code> 接收到与其中一个规则匹配的请求时，&lt;code>apiserver&lt;/code> 会根据 &lt;code>clientconfig&lt;/code> 配置中指定的 &lt;code>name: istio-sidecar-injector&lt;/code> 键值对，向 webhook 服务发送准入审查请求。我们应该能够看到该服务正在 &lt;code>istio-system&lt;/code> 命名空间中运行。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get svc --namespace=istio-system | grep sidecar-injector
istio-sidecar-injector ClusterIP 10.102.70.184 &amp;lt;none&amp;gt; 443/TCP 24d
&lt;/code>&lt;/pre>
&lt;p>最终，该配置与手动注入中的配置几乎相同。只是它是在 pod 创建过程中自动完成的，因此您不会看到部署中的更改。您需要使用 &lt;code>kubectl describe&lt;/code> 来查看 sidecar 代理和 init 代理。&lt;/p>
&lt;p>sidecar 自动注入不仅取决于 webhook 的 &lt;code>namespaceSelector&lt;/code> 机制，还取决于默认注入策略和每个 pod 自身注解。&lt;/p>
&lt;p>如果你再次查看 &lt;code>istio-sidecar-injector&lt;/code> ConfigMap，它将定义默认的注入策略。在这个示例中，它是默认启用的。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-outputis='yaml' data-repo='istio' >$ kubectl -n istio-system get configmap istio-sidecar-injector -o=jsonpath=&amp;#39;{.data.config}&amp;#39;
以下代码片段来自 output：
policy: enabled
template: |-
initContainers:
- name: istio-init
image: &amp;#34;gcr.io/istio-release/proxy_init:1.0.2&amp;#34;
args:
- &amp;#34;-p&amp;#34;
- [[ .MeshConfig.ProxyListenPort ]]
&lt;/code>&lt;/pre>
&lt;p>您还可以在 pod 模板中使用注解 &lt;code>sidecar.istio.io/inject&lt;/code> 覆盖默认策略。以下示例展示如何为 &lt;code>Deployment&lt;/code> 中的 pod 禁用 sidecar 自动注入。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: ignored
spec:
template:
metadata:
annotations:
sidecar.istio.io/inject: &amp;#34;false&amp;#34;
spec:
containers:
- name: ignored
image: tutum/curl
command: [&amp;#34;/bin/sleep&amp;#34;,&amp;#34;infinity&amp;#34;]
&lt;/code>&lt;/pre>
&lt;p>此示例显示了许多变量，这取决于是否在命名空间、ConfigMap 和 pod 中控制 sidecar 自动注入，它们是：&lt;/p>
&lt;ul>
&lt;li>webhook &lt;code>namespaceSelector&lt;/code>（&lt;code>istio-injection: enabled&lt;/code>）&lt;/li>
&lt;li>默认策略（在 ConfigMap &lt;code>istio-sidecar-injector&lt;/code> 中配置）&lt;/li>
&lt;li>每个 pod 的重载注解（&lt;code>sidecar.istio.io/inject&lt;/code>）&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="/v1.8/zh/docs/ops/common-problems/injection/">注入状态表&lt;/a>根据上述变量的值清晰显示了最终注入状态。&lt;/p>
&lt;h2 id="traffic-flow-from-application-container-to-sidecar-proxy">从应用容器到 Sidecar 代理的流量&lt;/h2>
&lt;p>既然我们已经清楚了如何将 sidecar 容器和 init 容器注入到应用清单中，那么 sidecar 代理如何捕获容器之间的入站和出站流量？我们曾简要提到过，这是通过在 pod 命名空间中设置 &lt;code>iptable&lt;/code> 规则来完成的，而规则又是由 &lt;code>istio-init&lt;/code> 容器完成的。现在，是时候验证命名空间中实际更新的内容了。&lt;/p>
&lt;p>让我们进入上一节中部署的应用程序 pod 命名空间，并查看已配置的 iptables。我们将展示一个使用 &lt;code>nsenter&lt;/code> 的例子。或者，您也可以通过特权模式进入容器并查看相同的信息。对于无法访问节点的人来说，使用 &lt;code>exec&lt;/code> 进入 sidecar 并运行 &lt;code>iptables&lt;/code> 更实用。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ docker inspect b8de099d3510 --format &amp;#39;{{ .State.Pid }}&amp;#39;
4125
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ nsenter -t 4215 -n iptables -t nat -S
-P PREROUTING ACCEPT
-P INPUT ACCEPT
-P OUTPUT ACCEPT
-P POSTROUTING ACCEPT
-N ISTIO_INBOUND
-N ISTIO_IN_REDIRECT
-N ISTIO_OUTPUT
-N ISTIO_REDIRECT
-A PREROUTING -p tcp -j ISTIO_INBOUND
-A OUTPUT -p tcp -j ISTIO_OUTPUT
-A ISTIO_INBOUND -p tcp -m tcp --dport 80 -j ISTIO_IN_REDIRECT
-A ISTIO_IN_REDIRECT -p tcp -j REDIRECT --to-ports 15001
-A ISTIO_OUTPUT ! -d 127.0.0.1/32 -o lo -j ISTIO_REDIRECT
-A ISTIO_OUTPUT -m owner --uid-owner 1337 -j RETURN
-A ISTIO_OUTPUT -m owner --gid-owner 1337 -j RETURN
-A ISTIO_OUTPUT -d 127.0.0.1/32 -j RETURN
-A ISTIO_OUTPUT -j ISTIO_REDIRECT
-A ISTIO_REDIRECT -p tcp -j REDIRECT --to-ports 15001
&lt;/code>&lt;/pre>
&lt;p>上面的输出清楚地表明，端口 80 的所有入站流量（即我们的 &lt;code>red-demo&lt;/code> 应用正在监听的端口）现在已被 &lt;code>REDIRECTED&lt;/code> 到端口 15001，即 &lt;code>istio-proxy&lt;/code> 的端口，一个 Envoy 代理正在监听的端口。对于出站流量也是如此。&lt;/p>
&lt;p>本文已经快结束了。我们希望本文有助于您弄清 Istio 是如何将 Sidecar 代理注入到现有部署中以及 Istio 是如何将流量路由到代理。&lt;/p>
&lt;div>
&lt;aside class="callout idea">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-idea"/>&lt;/svg>
&lt;/div>
&lt;div class="content">更新：现在似乎可以选择使用新的 CNI 来代替 &lt;code>istio-init&lt;/code>，其移除了对 init 容器和相关特权的要求。&lt;a href="https://github.com/istio/cni">&lt;code>istio-cni&lt;/code>&lt;/a> 插件设置了 pod 的网络来满足此要求，以代替 Istio 当前通过 &lt;code>istio-init&lt;/code> 注入 pod 的方法。&lt;/div>
&lt;/aside>
&lt;/div></description><pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/data-plane-setup/</link><author>Manish Chugtu</author><guid isPermaLink="true">/v1.8/zh/blog/2019/data-plane-setup/</guid><category>kubernetes</category><category>sidecar-injection</category><category>traffic-management</category></item><item><title>Egress gateway 性能测试</title><description>
&lt;p>为了从网格中访问外部服务（本例中使用的是 MongoDB），需要加入 Egress gateway，本次测试的主要目的就是调查这一行为对性能和资源使用造成的影响。在博客&lt;a href="/v1.8/zh/blog/2018/egress-mongo/">使用外部 MongoDB 服务&lt;/a>中介绍了为外部 MongoDB 配置 Egress gateway 的具体步骤。&lt;/p>
&lt;p>本次测试中使用的应用是 Acmeair 的 Java 版，这个应用会模拟一个航空订票系统。在 Istio 的每日构建中会使用该应用来进行性能的回归测试，但是在回归测试过程中，这些应用会使用自己的 Sidecar 来访问外部的 MongoDB，而不是 Egress gateway。&lt;/p>
&lt;p>下图描述了目前的 Istio 回归测试过程中，Acmeair 应用的运行方式：&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:62.69230769230769%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/acmeair_regpatrol3.png" title="在 Istio 性能回归测试环境中的 Acmeair 基准测试">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/acmeair_regpatrol3.png" alt="在 Istio 性能回归测试环境中的 Acmeair 基准测试" />
&lt;/a>
&lt;/div>
&lt;figcaption>在 Istio 性能回归测试环境中的 Acmeair 基准测试&lt;/figcaption>
&lt;/figure>
&lt;p>还有一个差别就是，这一应用和外部数据库使用的是明文的 MongoDB 协议。本文中的第一个变化就是将应用到外部 MongoDB 之间的连接升级为 TLS 模式，以体现更贴近实际情况的场景。&lt;/p>
&lt;p>下面会讲到一些从网格中访问外部数据库的具体案例。&lt;/p>
&lt;h2 id="egress-traffic-cases">Egress 流量案例&lt;/h2>
&lt;h3 id="case-1-bypassing-the-sidecar">案例 1：绕过 Sidecar&lt;/h3>
&lt;p>在这个案例中，Sidecar 对应用和外部数据库之间的通信不做拦截。这一配置是通过初始化容器中的 &lt;code>-x&lt;/code> 参数来完成的，将其内容设置为 MongoDB 的 CIDR 即可。这种做法导致 Sidecar 忽略流入/流出指定 IP 地址的流量。举例来说：&lt;/p>
&lt;pre>&lt;code> - -x
- &amp;#34;169.47.232.211/32&amp;#34;&lt;/code>&lt;/pre>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:76.45536869340232%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/case1_sidecar_bypass3.png" title="绕过 Sidecar 和外部 MongoDB 进行通信">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/case1_sidecar_bypass3.png" alt="绕过 Sidecar 和外部 MongoDB 进行通信" />
&lt;/a>
&lt;/div>
&lt;figcaption>绕过 Sidecar 和外部 MongoDB 进行通信&lt;/figcaption>
&lt;/figure>
&lt;h3 id="case-2-through-the-sidecar-with-service-entry">案例 2：使用 Service Entry，通过 Sidecar 完成访问&lt;/h3>
&lt;p>在 Sidecar 已经注入到应用 Pod 之后，这种方式是缺省（访问外部服务）的方式。所有的流量都被 Sidecar 拦截，然后根据配置好的规则路由到目的地，这里所说的目的地也包含了外部服务。下面为 MongoDB 配置一个 &lt;code>ServiceEntry&lt;/code>。&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:74.41253263707573%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/case2_sidecar_passthru3.png" title="Sidecar 拦截对外部 MongoDB 的流量">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/case2_sidecar_passthru3.png" alt="Sidecar 拦截对外部 MongoDB 的流量" />
&lt;/a>
&lt;/div>
&lt;figcaption>Sidecar 拦截对外部 MongoDB 的流量&lt;/figcaption>
&lt;/figure>
&lt;h3 id="case-3-egress-gateway">案例 3: Egress gateway&lt;/h3>
&lt;p>配置 Egress gateway 以及配套的 Destination rule 和 Virtual service，用于访问 MongoDB。所有进出外部数据库的流量都从 Egress gateway（Envoy）通过。&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:62.309368191721134%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/case3_egressgw3.png" title="使用 Egress gateway 访问 MongoDB">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/case3_egressgw3.png" alt="使用 Egress gateway 访问 MongoDB" />
&lt;/a>
&lt;/div>
&lt;figcaption>使用 Egress gateway 访问 MongoDB&lt;/figcaption>
&lt;/figure>
&lt;h3 id="case-4-mutual-TLS-between-sidecars-and-the-egress-gateway">案例 4：在 Sidecar 和 Egress gateway 之间的双向 TLS&lt;/h3>
&lt;p>这种方式中，在 Sidecar 和 Gateway 之中多出了一个安全层，所以会影响性能。&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:63.968957871396896%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/case4_egressgw_mtls3.png" title="在 Sidecar 和 Egress gateway 之间启用双向 TLS">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/case4_egressgw_mtls3.png" alt="在 Sidecar 和 Egress gateway 之间启用双向 TLS" />
&lt;/a>
&lt;/div>
&lt;figcaption>在 Sidecar 和 Egress gateway 之间启用双向 TLS&lt;/figcaption>
&lt;/figure>
&lt;h3 id="case-5-egress-gateway-with-SNI-proxy">案例 5：带有 SNI proxy 的 Egress gateway&lt;/h3>
&lt;p>这个场景中，因为 Envoy 目前存在的一些限制，需要另一个代理来访问通配符域名。这里创建了一个 Nginx 代理，在 Egress gateway Pod 中作为 Sidecar 来使用。&lt;/p>
&lt;figure style="width:70%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:65.2762119503946%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/case5_egressgw_sni_proxy3.png" title="带有 SNI proxy 的 Egress gateway">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/case5_egressgw_sni_proxy3.png" alt="带有 SNI proxy 的 Egress gateway" />
&lt;/a>
&lt;/div>
&lt;figcaption>带有 SNI proxy 的 Egress gateway&lt;/figcaption>
&lt;/figure>
&lt;h2 id="environment">环境&lt;/h2>
&lt;ul>
&lt;li>Istio 版本：1.0.2&lt;/li>
&lt;li>&lt;code>K8s&lt;/code> 版本：&lt;code>1.10.5_1517&lt;/code>&lt;/li>
&lt;li>Acmeair 应用：4 个服务（每个服务一个实例），跨服务事务，外部 MongoDB，平均载荷：620 字节。&lt;/li>
&lt;/ul>
&lt;h2 id="results">结果&lt;/h2>
&lt;p>使用 &lt;code>Jmeter&lt;/code> 来生成负载，负载包含了一组持续五分钟的访问，每个阶段都会逐步提高客户端数量来发出 http 请求。客户端数量为：1、5、10、20、30、40、50 和 60。&lt;/p>
&lt;h3 id="throughput">吞吐量&lt;/h3>
&lt;p>下图展示了不同案例中的吞吐量：&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:54.29638854296388%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/throughput3.png" title="不同案例中的吞吐量">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/throughput3.png" alt="不同案例中的吞吐量" />
&lt;/a>
&lt;/div>
&lt;figcaption>不同案例中的吞吐量&lt;/figcaption>
&lt;/figure>
&lt;p>如图可见，在应用和外部数据库中加入 Sidecar 和 Egress gateway 并没有对性能产生太大影响；但是启用双向 TLS、又加入 SNI 代理之后，吞吐量分别下降了 10% 和 24%。&lt;/p>
&lt;h3 id="response-time">响应时间&lt;/h3>
&lt;p>在 20 客户端的情况下，我们对不同请求的平均响应时间也进行了记录。下图展示了各个案例中平均、中位数、90%、95% 以及 99% 百分位的响应时间。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:48.76783398184176%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/response_times3.png" title="不同配置中的响应时间">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/response_times3.png" alt="不同配置中的响应时间" />
&lt;/a>
&lt;/div>
&lt;figcaption>不同配置中的响应时间&lt;/figcaption>
&lt;/figure>
&lt;p>跟吞吐量类似，前面三个案例的响应时间没有很大区别，但是双向 TLS 和 额外的代理造成了明显的延迟。&lt;/p>
&lt;h3 id="CPU-utilization">CPU 用量&lt;/h3>
&lt;p>运行过程中还搜集了所有 Istio 组件以及 Sidecar 的 CPU 使用情况。为了公平起见，用吞吐量对 Istio 的 CPU 用量进行了归一化。下图中展示了这一结果：&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:53.96174863387978%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2019/egress-performance/cpu_usage3.png" title="使用 TPS 进行归一化的 CPU 用量">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2019/egress-performance/cpu_usage3.png" alt="使用 TPS 进行归一化的 CPU 用量" />
&lt;/a>
&lt;/div>
&lt;figcaption>使用 TPS 进行归一化的 CPU 用量&lt;/figcaption>
&lt;/figure>
&lt;p>经过归一化处理之后的 CPU 用量数据表明，Istio 在使用 Egress gateway + SNI 代理的情况下，消耗了更多的 CPU。&lt;/p>
&lt;h2 id="conclusion">结论&lt;/h2>
&lt;p>在这一系列的测试之中，我们用不同的方式来访问一个启用了 TLS 的 MongoDB 来进行性能对比。Egress gateway 的引用没有对性能和 CPU 消耗的显著影响。但是启用了 Sidecar 和 Egress gateway 之间的双向 TLS 或者为通配符域名使用了额外的 SNI 代理之后，会看到性能降级的现象。&lt;/p></description><pubDate>Thu, 31 Jan 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/egress-performance/</link><author>Jose Nativio, IBM</author><guid isPermaLink="true">/v1.8/zh/blog/2019/egress-performance/</guid><category>performance</category><category>traffic-management</category><category>egress</category><category>mongo</category></item><item><title>使用 AppSwitch 进行 Sidestepping 依赖性排序</title><description>
&lt;p>我们正在经历一个有趣事情，对应用程序进行拆分和重组。虽然微服务需要把单体应用分解为多个微型服务，但服务网格会把这些服务连结为一个应用程序。因此，微服务是逻辑上分离而又不是相互独立的。它们通常是紧密相互依赖的，而拆分单体应用的同时会引入了许多新的问题，例如服务之间需要双向认证等。而 Istio 恰巧能解决大多数问题。&lt;/p>
&lt;h2 id="dependency-ordering-problem">依赖性排序问题&lt;/h2>
&lt;p>依赖性排序的问题是由于应用程序拆分而导致的问题且 Istio 也尚未解决 - 确保应用程序整体快速正确地的顺序启动应用程序的各个服务。在单体应用程序中，内置所有组件，组件之间的依赖顺序由内部锁机制强制执行。但是，如果单个服务分散在服务网格的集群中，则启动服务需要首先检查它所依赖的服务是否已启动且可用。&lt;/p>
&lt;p>依赖性排序由于存在许多相互关联的问题而具有欺骗性。对单个服务进行排序需要具有服务的依赖关系图，以便它们可以从叶节点开始返回到根节点。由于相互依赖性随着应用程序的行为而发展，因此构建这样的图并随时保持更新并不容易。即使以某种方式提供依赖图，强制执行排序本身并不容易。简单地按指定的顺序启动服务显然是行不通的。服务可能已启动但尚未准备好提供服务。例如 docker-compose 中的 depends-on 标签就存在这样的问题。&lt;/p>
&lt;p>除了在服务启动之间引入足够长的睡眠之外，还有一个常见的模式是，在启动服务之前检查被依赖的服务是否已经准备就绪。在 Kubernetes 中，可以用在 Pod 的 Init 容器中加入等待脚本的方式来完成。但是，这意味着整个应用程序将被暂停，直到所有的依赖服务都准备就绪。有时，应用程序会在启动第一次出站连接之前花几分钟时间初始化自己。不允许服务启动会增加应用程序整体启动时间的大量开销。此外，等待 init 容器的策略不适用于同一 pod 中的多个服务相互依赖的情况。&lt;/p>
&lt;h3 id="example-scenario-IBM-WebSphere">示例场景：IBM WebSphere ND&lt;/h3>
&lt;p>IBM WebSphere ND 是一个常见的应用程序中间件，通过对它的观察，能够更好地理解这种问题。它本身就是一个相当复杂的框架，由一个名为 Deployment manager（&lt;code>dmgr&lt;/code>）的中央组件组成，它管理一组节点实例。它使用 UDP 协商节点之间的集群成员资格，并要求部署管理器在任何节点实例出现并加入集群之前已启动并可运行。&lt;/p>
&lt;p>为什么我们在现代云原生环境中讨论传统应用程序？事实证明，通过使它们能够在 Kubernetes 和 Istio 平台上运行，可以获得显著的收益。从本质上讲，它是现代化之旅的一部分，它允许在同一现代平台上运行传统应用程序和全新的现代应用程序，以促进两者之间的互操作。实际上，WebSphere ND 是一个要求很高的应用程序。它期望具有特定网络接口属性的一致网络环境等。AppSwitch 可以满足这些要求。本博客的将重点关注依赖顺序需求以及 AppSwitch 在这方面的解决方法。&lt;/p>
&lt;p>在 Kubernetes 集群上简单地部署 &lt;code>dmgr&lt;/code> 和节点实例作为 pod 是行不通的。&lt;code>dmgr&lt;/code> 和节点实例碰巧有一个很长的初始化过程，可能需要几分钟。如果他们被同时部署，那么应用程序通常会处于一个有趣的状态。当一个节点实例出现并发现缺少 &lt;code>dmgr&lt;/code> 时，它将需要一个备用启动路径。相反，如果它立即退出，Kubernetes 崩溃循环将接管，也许应用程序会出现。但即使在这种情况下，事实证明及时启动并不能得到保证。&lt;/p>
&lt;p>一个 &lt;code>dmgr&lt;/code> 及其节点实例是 WebSphere ND 的基本部署配置。构建在生产环境中运行的 WebSphere ND 之上的 IBM Business Process Manager 等应用程序包括其他一些服务。在这些配置中，可能存在一系列相互依赖关系。根据节点实例托管的应用程序，它们之间也可能存在排序要求。使用较长的服务初始化时间和崩溃循环重启，应用程序几乎没有机会在任何合理的时间内启动。&lt;/p>
&lt;h3 id="sidecar-dependency-in-Istio">Istio 中的 Sidecar 依赖&lt;/h3>
&lt;p>Istio 本身受依赖性排序问题版本的影响。由于在 Istio 下运行的服务的连接通过其 sidecar 代理重定向，因此在应用程序服务及其 sidecar 之间创建了隐式依赖关系。除非 sidecar 完全正常运行，否则所有来自服务的请求都将被丢弃。&lt;/p>
&lt;h2 id="dependency-ordering-with-AppSwitch">使用 AppSwitch 进行依赖性排序&lt;/h2>
&lt;p>那么我们如何解决这些问题呢？一种方法是将其推迟到应用程序并说它们应该“表现良好”并实施适当的逻辑以使自己免受启动顺序问题的影响。但是，许多应用程序（尤其是传统应用程序）如果错误则会超时或死锁。即使对于新的应用程序，为每个服务实现一个关闭逻辑也是最大的额外负担，最好避免。服务网格需要围绕这些问题提供足够的支持。毕竟，将常见模式分解为底层框架实际上是服务网格的重点。&lt;/p>
&lt;p>&lt;a href="http://appswitch.io">AppSwitch&lt;/a> 明确地解决了依赖性排序。它位于应用程序在集群中的客户端和服务之间的网络交互的控制路径上，并且通过进行 &lt;code>connect&lt;/code> 调用以及当特定服务通过使 &lt;code>listen&lt;/code> 准备好接受连接时，准确地知道服务何时成为客户端。调用它的 &lt;em>service router&lt;/em> 组件在集群中传播有关这些事件的信息，并仲裁客户端和服务器之间的交互。AppSwitch 就是以这种简单有效的方式实现负载均衡和隔离等功能的。利用应用程序的网络控制路径的相同战略位置，可以想象这些服务所做的“连接”和“监听”调用可以以更精细的粒度排列，而不是按照依赖关系图对整个服务进行粗略排序。这将有效地解决多级依赖问题和加速应用程序启动。&lt;/p>
&lt;p>但这仍然需要一个依赖图。存在许多产品和工具来帮助发现服务依赖性。但它们通常基于对网络流量的被动监控，并且无法预先为任意应用程序提供信息。由于加密和隧道导致的网络级混淆也使它们不可靠。发现和指定依赖项的负担最终落在应用程序的开发人员或操作员身上。实际上，甚至一致性检查依赖性规范本身也非常复杂，相对来说，能够避免使用依赖图的任何方法都会更加理想。&lt;/p>
&lt;p>依赖图的要点是知道哪些客户端依赖于特定服务，以便让客户端能够等待被依赖服务准备就绪。但具体客户真的重要吗？归根结底，一个服务的所有客户端，都是依赖这个服务的。AppSwitch 正是利用这一点来解决依赖问题。事实上，这完全避免了依赖性排序。可以同时调度应用程序中的所有服务，而无需考虑启动顺序。它们之间的相互依赖性会根据各个请求和响应的粒度自动完成，从而实现快速，正确的应用程序启动。&lt;/p>
&lt;h3 id="AppSwitch-model-and-constructs">AppSwitch 模型和构造&lt;/h3>
&lt;p>既然我们对 AppSwitch 的高级方法有了概念性的理解，那么让我们来看看所涉及的结构。但首先要对使用模型进行快速总结。尽管它是针对不同的上下文编写的，但在此主题上查看我之前的 &lt;a href="/v1.8/zh/blog/2018/delayering-istio/">blog&lt;/a> 也很有用。为了完整起见，我还要注意 AppSwitch 不会打扰非网络依赖。例如，两个服务可能使用 IPC 机制或通过共享文件系统进行交互。像这样的深层联系的流程通常是同一服务的一部分，并且不需要主动地对应用程序的正常执行进行干预。&lt;/p>
&lt;p>AppSwitch 的核心能够使用 BSD Socket API 及其相关的其它调用（例如 &lt;code>fcntl&lt;/code> 和 ioctl）来完成对 Socket 的处理。它的实现细节很有意思，但是为了防止偏离本文的主题，这里仅对其独特的关键属性进行一个总结。
（1）速度很快。它使用 &lt;code>seccomp&lt;/code> 过滤和二进制检测的组合来积极地限制应用程序正常执行的干预。AppSwitch 特别适用于服务网格和应用程序网络用例，因为它实现了这些功能，而无需实际触摸数据。相反，网络级方法会导致每个数据包的成本。看看这个&lt;a href="/v1.8/zh/blog/2018/delayering-istio/">博客&lt;/a>进行一些性能测量。
（2）它不需要任何内核支持，内核模块或补丁，可以在标准的发行版内核上运行
（3）它可以作为普通用户运行（非 root）。事实上，该机制甚至可以通过删除对网络容器的根要求来运行&lt;a href="https://linuxpiter.com/en/materials/2478">非 root 的 Docker 守护进程&lt;/a>
（4）它可以不加更改的用于任何类型的应用程序上，适用于任何类型的应用程序 - 从 WebSphere ND 和 SAP 到自定义 C 应用程序，再到静态链接的 &lt;code>Golang&lt;/code> 应用程序。Linux/x86 是仅有的运行需求。&lt;/p>
&lt;h3 id="decoupling-services-from-their-references">将服务与其引用分离&lt;/h3>
&lt;p>AppSwitch 建立在应用程序应与其引用分离的基本前提之上。传统上，应用程序的标识源自它们运行的​​ 主机的标识。但是，应用程序和主机是需要独立引用的非常不同的对象。本&lt;a href="https://arxiv.org/abs/1711.02294">主题&lt;/a>介绍了围绕此主题的详细讨论以及 AppSwitch 的概念基础。&lt;/p>
&lt;p>实现服务对象及其身份之间解耦的中央 AppSwitch 构造是 _service reference_（简称 &lt;em>reference&lt;/em> ）。AppSwitch 基于上面概述的 API 检测机制实现服务引用。服务引用由 IP：端口对（以及可选的 DNS 名称）和标签选择器组成，标签选择器选择引用所代表的服务以及此引用所适用的客户端。引用支持一些关键属性。（1）它的名称可以独立于它所引用的对象的名称。也就是说，服务可能正在侦听 IP 和端口，但是引用允许在用户选择的任何其他 IP 和端口上达到该服务。这使 AppSwitch 能够运行从源环境中捕获的传统应用程序，通过静态 IP 配置在 Kubernetes 上运行，为其提供必要的 IP 地址和端口，而不管目标网络环境如何。（2）即使目标服务的位置发生变化，它也保持不变。引用自动重定向自身，因为其标签选择器现在解析为新的服务实例（3）对于此讨论最重要的是，在目标服务的启动过程中，引用就已经生效了。&lt;/p>
&lt;p>为了便于发现可通过服务引用访问的服务，AppSwitch 提供了一个 _auto-curated 服务注册表_。根据 AppSwitch 跟踪的网络 API，当服务进出群集时，注册表会自动保持最新。注册表中的每个条目都包含相应服务绑定的 IP 和端口。除此之外，它还包括一组标签，指示此服务所属的应用程序，应用程序在创建服务时通过 Socket API 传递的 IP 和端口，AppSwitch 实际绑定基础主机上的服务的 IP 和端口此外，在 AppSwitch 下创建的应用程序带有一组用户传递的标签，用于描述应用程序以及一些默认系统标签，指示创建应用程序的用户和运行应用程序的主机等。这些标签都可以在服务引用所携带的标签选择器中表示。通过创建服务引用，可以使客户端访问注册表中的服务。然后，客户端将能够以引用的名称（IP：端口）访问服务。现在让我们来看看 AppSwitch 如何在目标服务尚在启动的过程中就让服务引用开始生效的。&lt;/p>
&lt;h3 id="non-blocking-requests">非阻塞请求&lt;/h3>
&lt;p>AppSwitch 利用 BSD Socket API 的语义，确保服务引用从客户的角度看起来是有效的，因为相应的服务出现了。当客户端对一个尚未启动的服务发起阻塞式连接调用时，AppSwitch 会阻止该调用一段时间等待目标服务变为活动状态。由于已知目标服务是应用程序的一部分并且预计很快就会出现，因此客户端会被阻塞，而不是收到 ECONNREFUSED 之类的返回信息导致启动失败。如果服务没有及时出现，则会向应用程序返回一个错误，以便像 Kubernetes 崩溃循环这样的框架级机制可以启动。&lt;/p>
&lt;p>如果客户端请求被标记为非阻塞，则 AppSwitch 通过返回 &lt;code>EAGAIN&lt;/code> 来处理该请求以通知应用程序重试而不是放弃。再次，这与 Socket API 的语义一致，并防止由于启动竞争而导致的失败。AppSwitch 通过对 BSD Socket API 的支持，将重试逻辑内置到应用程序之中，从而透明的为应用提供了依赖排序支持。&lt;/p>
&lt;h3 id="application-timeouts">应用程序超时&lt;/h3>
&lt;p>如果应用程序基于其自己的内部计时器超时怎么办？说实话，如果需要，AppSwitch 还可以伪造应用程序对时间的感知，但这种做法不仅越界，而且并无必要。应用程序决定并知道它应该等待多长时间，这对 AppSwitch 来说是不合适的。应用程序超过保守时长，如果目标服务仍未及时出现，则不太可能是依赖性排序问题。一定是出现了其它问题，AppSwitch 不应掩盖这些问题。&lt;/p>
&lt;h3 id="wildcard-service-references-for-sidecar-dependency">为 Sidecar 提供服务引用的通配符支持&lt;/h3>
&lt;p>服务引用可用于解决前面提到的 Istio sidecar 依赖性问题。AppSwitch 用 IP：端口的方式来描述对服务的引用，这种描述中是可以使用通配符的。也就是说，服务引用描述中可以用 IP 掩码的形式来表达要捕捉的 IP 地址的范围。如果服务引用的标签选择器指向 sidecar 服务，则应用此服务引用的任何应用程序的所有传出连接将被透明地重定向到 sidecar。当然，在 Sidecar 启动过程中，服务引用仍然是有效的。&lt;/p>
&lt;p>使用 sidecar 依赖性排序的服务引用也隐式地将应用程序的连接重定向到 sidecar ，而不需要 iptables 和随之而来的权限问题。基本上它就像应用程序直接连接到 sidecar 而不是目标目的地一样工作，让 sidecar 负责做什么。AppSwitch 将使用 sidecar 可以在将连接传递到应用程序之前解码的代理协议将关于原始目的地等的元数据插入到连接的数据流中。其中一些细节已在&lt;a href="/v1.8/zh/blog/2018/delayering-istio/">此处&lt;/a>进行了讨论。出站连接是这样处理的，那么入站连接呢？由于所有服务及其 sidecar 都在 AppSwitch 下运行，因此来自远程节点的任何传入连接都将被重定向到各自的远程 sidecar 。所以传入连接没有什么特别处理。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>依赖顺序是一个讨厌的问题。这主要是由于无法访问有关服务间交互的细粒度应用程序级事件。解决这个问题通常需要应用程序来实现自己的内部逻辑。但 AppSwitch 使这些内部应用程序事件无需更改应用程序即可进行检测。然后，AppSwitch 利用对 BSD Socket API 的普遍支持来回避排序依赖关系的要求。&lt;/p>
&lt;h2 id="acknowledgements">致谢&lt;/h2>
&lt;p>感谢 Eric Herness 和团队对 IBM WebSphere 和 BPM 产品的见解和支持，我们将它们应用到现代化 Kubernetes 平台，还要感谢 Mandar Jog，Martin Taillefer 和 Shriram Rajagopalan 对于此博客早期草稿的评审。&lt;/p></description><pubDate>Mon, 14 Jan 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/appswitch/</link><author>Dinesh Subhraveti (AppOrbit and Columbia University)</author><guid isPermaLink="true">/v1.8/zh/blog/2019/appswitch/</guid><category>appswitch</category><category>performance</category></item><item><title>使用 Cert-Manager 部署一个自定义 Ingress 网关</title><description>
&lt;p>本文介绍了手工创建自定义 Ingress &lt;a href="/v1.8/zh/docs/reference/config/networking/gateway/">Gateway&lt;/a> 的过程，其中使用 cert-manager 完成了证书的自动管理。&lt;/p>
&lt;p>自定义 Ingress 网关在使用不同负载均衡器来隔离通信的情况下很有帮助。&lt;/p>
&lt;h2 id="before-you-begin">开始之前&lt;/h2>
&lt;ul>
&lt;li>根据&lt;a href="/v1.8/zh/docs/setup/">安装指南&lt;/a>完成 Istio 的部署。&lt;/li>
&lt;li>用 Helm &lt;a href="https://github.com/helm/charts/tree/master/stable/cert-manager#installing-the-chart">Chart&lt;/a> 部署 &lt;code>cert-manager&lt;/code>。&lt;/li>
&lt;li>我们会使用 &lt;code>demo.mydemo.com&lt;/code> 进行演示，因此你的 DNS 解析要能够解析这个域名。&lt;/li>
&lt;/ul>
&lt;h2 id="configuring-the-custom-ingress-gateway">配置自定义 Ingress 网关&lt;/h2>
&lt;ol>
&lt;li>&lt;p>用下面的 &lt;code>helm&lt;/code> 命令检查 &lt;a href="https://github.com/helm/charts/tree/master/stable/cert-manager">cert-manager&lt;/a> 是否已经完成部署：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ helm ls
&lt;/code>&lt;/pre>
&lt;p>该命令的输出大概如下所示，其中的 &lt;code>cert-manager&lt;/code> 的 &lt;code>STATUS&lt;/code> 字段应该是 &lt;code>DEPLOYED&lt;/code>&lt;/p>
&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >NAME REVISION UPDATED STATUS CHART APP VERSION NAMESPACE
istio 1 Thu Oct 11 13:34:24 2018 DEPLOYED istio-1.0.X 1.0.X istio-system
cert 1 Wed Oct 24 14:08:36 2018 DEPLOYED cert-manager-v0.6.0-dev.2 v0.6.0-dev.2 istio-system
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>要创建集群的证书签发者，可以使用如下的配置：&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">用自己的配置修改集群的&lt;a href="https://cert-manager.readthedocs.io/en/latest/reference/issuers.html">证书签发者&lt;/a>。例子中使用的是 &lt;code>route53&lt;/code>。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: certmanager.k8s.io/v1alpha1
kind: ClusterIssuer
metadata:
name: letsencrypt-demo
namespace: kube-system
spec:
acme:
# ACME 服务器地址
server: https://acme-v02.api.letsencrypt.org/directory
# ACME 注册的 Email 地址
email: &amp;lt;REDACTED&amp;gt;
# Secret 的名字，用于保存 ACME 账号的私钥
privateKeySecretRef:
name: letsencrypt-demo
dns01:
# 这里定义了一个列表，包含了 DNS-01 的相关内容，用于应对 DNS Challenge。
providers:
- name: your-dns
route53:
accessKeyID: &amp;lt;REDACTED&amp;gt;
region: eu-central-1
secretAccessKeySecretRef:
name: prod-route53-credentials-secret
key: secret-access-key
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>如果使用的是 &lt;code>route53&lt;/code> &lt;a href="https://cert-manager.readthedocs.io/en/latest/tasks/acme/configuring-dns01/route53.html">provider&lt;/a>，必须提供一个 Secret 来进行 DNS 的 ACME 验证。可以使用下面的配置来创建需要的 Secret：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Secret
metadata:
name: prod-route53-credentials-secret
type: Opaque
data:
secret-access-key: &amp;lt;REDACTED BASE64&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建自己的证书：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
name: demo-certificate
namespace: istio-system
spec:
acme:
config:
- dns01:
provider: your-dns
domains:
- &amp;#39;*.mydemo.com&amp;#39;
commonName: &amp;#39;*.mydemo.com&amp;#39;
dnsNames:
- &amp;#39;*.mydemo.com&amp;#39;
issuerRef:
kind: ClusterIssuer
name: letsencrypt-demo
secretName: istio-customingressgateway-certs
&lt;/code>&lt;/pre>
&lt;p>记录一下 &lt;code>secretName&lt;/code> 的值，后面会使用它。&lt;/p>&lt;/li>
&lt;li>&lt;p>要进行自动扩容，可以新建一个 HPA 对象：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
name: my-ingressgateway
namespace: istio-system
spec:
maxReplicas: 5
minReplicas: 1
scaleTargetRef:
apiVersion: apps/v1beta1
kind: Deployment
name: my-ingressgateway
targetCPUUtilizationPercentage: 80
status:
currentCPUUtilizationPercentage: 0
currentReplicas: 1
desiredReplicas: 1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>使用&lt;a href="/v1.8/zh/blog/2019/custom-ingress-gateway/deployment-custom-ingress.yaml">附件 YAML 中的定义&lt;/a>进行部署。&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">其中类似 &lt;code>aws-load-balancer-type&lt;/code> 这样的注解，只对 AWS 生效。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;/li>
&lt;li>&lt;p>创建你的服务：&lt;/p>
&lt;div>
&lt;aside class="callout warning">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-warning"/>&lt;/svg>
&lt;/div>
&lt;div class="content">&lt;code>NodePort&lt;/code> 需要是一个可用端口。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Service
metadata:
name: my-ingressgateway
annotations:
service.beta.kubernetes.io/aws-load-balancer-type: nlb
labels:
app: my-ingressgateway
istio: my-ingressgateway
spec:
type: LoadBalancer
selector:
app: my-ingressgateway
istio: my-ingressgateway
ports:
-
name: http2
nodePort: 32380
port: 80
targetPort: 80
-
name: https
nodePort: 32390
port: 443
-
name: tcp
nodePort: 32400
port: 31400
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建你的自定义 Ingress 网关配置对象：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
annotations:
name: istio-custom-gateway
namespace: default
spec:
selector:
istio: my-ingressgateway
servers:
- hosts:
- &amp;#39;*.mydemo.com&amp;#39;
port:
name: http
number: 80
protocol: HTTP
tls:
httpsRedirect: true
- hosts:
- &amp;#39;*.mydemo.com&amp;#39;
port:
name: https
number: 443
protocol: HTTPS
tls:
mode: SIMPLE
privateKey: /etc/istio/ingressgateway-certs/tls.key
serverCertificate: /etc/istio/ingressgateway-certs/tls.crt
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>使用 &lt;code>VirtualService&lt;/code> 连接 &lt;code>istio-custom-gateway&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: my-virtualservice
spec:
hosts:
- &amp;#34;demo.mydemo.com&amp;#34;
gateways:
- istio-custom-gateway
http:
- route:
- destination:
host: my-demoapp
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>服务器返回了正确的证书，并成功完成验证（&lt;code>SSL certificate verify ok&lt;/code>）：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ curl -v `https://demo.mydemo.com`
Server certificate:
SSL certificate verify ok.
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>恭喜你！&lt;/strong> 现在你可以使用自定义的 &lt;code>istio-custom-gateway&lt;/code> &lt;a href="/v1.8/zh/docs/reference/config/networking/gateway/">网关&lt;/a>对象了。&lt;/p></description><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/custom-ingress-gateway/</link><author>Julien Senon</author><guid isPermaLink="true">/v1.8/zh/blog/2019/custom-ingress-gateway/</guid><category>ingress</category><category>traffic-management</category></item><item><title>Istio 论坛成立</title><description>&lt;p>我们在 Istio 论坛中一直努力寻找合适的方法，让用户与论坛的其他成员进行互动、交流，寻求其他用户的帮助，以及与该项目的开发者进行沟通。&lt;/p>
&lt;p>我们尝试了几种不同的途径，但是每种途径都有一些不足。RocketChat 是我们最近的工作，但是缺少某些功能（例如，线程方面），意味着它不再适合围绕任何单一问题进行讨论。这也给一些用户带来了困惑：什么时候应该向 &lt;code>istio-users@googlegroups.com&lt;/code> 发送电子邮件，什么时候又该使用 RocketChat ？&lt;/p>
&lt;p>我们认为我们已经在单一的平台上找到了正确平衡功能，因此我们很高兴地宣布 &lt;a href="https://discuss.istio.io">discuss.istio.io&lt;/a> 论坛成立啦。这是一个功能全面的论坛，我们将从这里开始对 Istio 进行讨论沟通，它允许你提出问题并获得主题回复！真正的好处是，你可以使用你的 GitHub 身份进行这些操作。&lt;/p>
&lt;p>如果你喜欢使用电子邮件，那么你可以将其配置为用电子邮件去发送，就像 Google groups 一样。&lt;/p>
&lt;p>我们会将 Google groups 标记为 “只读”，以便保留其原始内容，但是请你发送进一步的问题到 &lt;a href="https://discuss.istio.io">discuss.istio.io&lt;/a> 。如果在你的小组中有任何未解决的问题或讨论，请结束讨论。&lt;/p>
&lt;p>Happy meshing!&lt;/p></description><pubDate>Thu, 10 Jan 2019 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2019/announcing-discuss.istio.io/</link><author/><guid isPermaLink="true">/v1.8/zh/blog/2019/announcing-discuss.istio.io/</guid></item><item><title>增量式应用 Istio 第一部分，流量管理</title><description>
&lt;p>流量管理是 Istio 提供的重要优势之一。Istio 流量管理的核心是在将通信流量和基础设施的伸缩进行解耦。如果没有 Istio 这样的服务网格，这种流量控制方式是不可能实现的。&lt;/p>
&lt;p>例如，您希望执行一次&lt;a href="https://martinfowler.com/bliki/CanaryRelease.html">金丝雀发布&lt;/a>。当使用 Istio 时，您可以指定 service 的 &lt;strong>v1&lt;/strong> 版本接收 90% 的传入流量，而该 service &lt;strong>v2&lt;/strong> 版本仅接收 10%。如果使用标准的 Kubernetes deployment，实现此目的的唯一方法是手动控制每个版本的可用 Pod 数量，例如使 9 个 Pod 运行 v1 版本，使 1 个 Pod 运行 v2 版本。这种类型的手动控制难以实现，并且随着时间的推移可能无法扩展。有关更多信息，请查看&lt;a href="/v1.8/zh/blog/2017/0.1-canary/">使用 Istio 进行金丝雀发布&lt;/a>。&lt;/p>
&lt;p>部署现有 service 的更新时存在同样的问题。虽然您可以使用 Kubernetes 更新 deployment，但它需要将 v1 Pod 替换为 v2 Pod。使用 Istio，您可以部署 service 的 v2 版本，并使用内置流量管理机制在网络层面将流量转移到更新后的 service，然后删除 v1 版本的 Pod。&lt;/p>
&lt;p>除了金丝雀发布和一般流量转移之外，Istio 还使您能够实现动态请求路由（基于 HTTP header）、故障恢复、重试、断路器和故障注入。有关更多信息，请查看&lt;a href="/v1.8/zh/docs/concepts/traffic-management/">流量管理文档&lt;/a>。&lt;/p>
&lt;p>这篇文章介绍的技术重点突出了一种特别有用的方法，可以逐步实现 Istio（在这种情况下，只有流量管理功能），而无需单独更新每个 Pod。&lt;/p>
&lt;h2 id="setup-why-implement-Istio-traffic-management-features">设置：为什么要实施 Istio 流量管理功能？&lt;/h2>
&lt;p>当然，第一个问题是：为什么要这样做？&lt;/p>
&lt;p>如果你是众多拥有大量团队和大型集群的组织中的一员，那么答案是很清楚的。假设 A 团队正在开始使用 Istio，并希望在 service A 上开始一些金丝雀发布，但是 B 团队还没有开始使用 Istio，所以他们没有部署 sidecar。&lt;/p>
&lt;p>使用 Istio，A 团队仍然可以让 service B 通过 Istio 的 ingress gateway 调用 service A 来实现他们的金丝雀发布。&lt;/p>
&lt;h2 id="background-traffic-routing-in-an-Istio-mesh">背景：Istio 网格中的流量路由&lt;/h2>
&lt;p>但是，如何在不更新每个应用程序的 Pod 的情况下，使用 Istio 的流量管理功能来包含 Istio sidecar？在回答这个问题之前，让我们以高层视角，快速地看看流量如何进入 Istio 网格以及如何被路由。&lt;/p>
&lt;p>Pod 包含一个 sidecar 代理，该代理作为 Istio 网格的一部分，负责协调 Pod 的所有入站和出站流量。在 Istio 网格中，Pilot 负责将高级路由规则转换为配置并将它们传播到 sidecar 代理。这意味着当服务彼此通信时，它们的路由决策是由客户端确定的。&lt;/p>
&lt;p>假设您有 service A 和 service B 两个服务，他们是 Istio 网格的一部分。当 A 想要与 B 通信时，Pod A 的 sidecar 代理负责将流量引导到 service B。例如，如果你希望到 service B v1 版本和 v2 版本之间的流量按 &lt;sup>50&lt;/sup>&amp;frasl;&lt;sub>50&lt;/sub> 分割，流量将按如下方式流动：&lt;/p>
&lt;figure style="width:60%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:42.66666666666667%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/incremental-traffic-management/fifty-fifty.png" title="50/50 流量分割">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/incremental-traffic-management/fifty-fifty.png" alt="50/50 流量分割" />
&lt;/a>
&lt;/div>
&lt;figcaption>50/50 流量分割&lt;/figcaption>
&lt;/figure>
&lt;p>如果 service A 和 B 不是 Istio 网格的一部分，则没有 sidecar 代理知道如何将流量路由到 service B 的不同版本。在这种情况下，您需要使用另一种方法来使 service A 到 service B 的流量遵循您设置的 &lt;sup>50&lt;/sup>&amp;frasl;&lt;sub>50&lt;/sub> 规则。&lt;/p>
&lt;p>幸运的是，标准的 Istio 部署已经包含了一个 &lt;a href="/v1.8/zh/docs/concepts/traffic-management/#gateways">Gateway&lt;/a>，它专门处理 Istio 网格之外的入口流量。此 Gateway 用于允许通过外部负载均衡器进入的集群外部入口流量；或来自 Kubernetes 集群，但在服务网格之外的入口流量。网关可以进行配置，对没有 Sidecar 支持的入口流量进行代理，引导流量进入相应的 Pod。这种方法允许您利用 Istio 的流量管理功能，其代价是通过入口网关的流量将产生额外的跃点。&lt;/p>
&lt;figure style="width:60%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:54.83870967741935%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/incremental-traffic-management/fifty-fifty-ingress-gateway.png" title="使用 Ingress Gateway 的 50/50 流量分割">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/incremental-traffic-management/fifty-fifty-ingress-gateway.png" alt="使用 Ingress Gateway 的 50/50 流量分割" />
&lt;/a>
&lt;/div>
&lt;figcaption>使用 Ingress Gateway 的 50/50 流量分割&lt;/figcaption>
&lt;/figure>
&lt;h2 id="in-action-traffic-routing-with-Istio">实践：Istio 流量路由&lt;/h2>
&lt;p>一种实践的简单方法是首先按照&lt;a href="/v1.8/zh/docs/setup/platform-setup/">平台设置&lt;/a>说明设置 Kubernetes 环境，然后使用 &lt;a href="/v1.8/zh/docs/setup/install/helm/">Helm&lt;/a> 安装仅包含流量管理组件（ingress gateway、egress gateway、Pilot）的 Istio。下面的示例使用 &lt;a href="https://cloud.google.com/gke">Google Kubernetes Engine&lt;/a>。&lt;/p>
&lt;p>首先，安装并配置 &lt;a href="/v1.8/zh/docs/setup/platform-setup/gke/">GKE&lt;/a>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ gcloud container clusters create istio-inc --zone us-central1-f
$ gcloud container clusters get-credentials istio-inc
$ kubectl create clusterrolebinding cluster-admin-binding \
--clusterrole=cluster-admin \
--user=$(gcloud config get-value core/account)
&lt;/code>&lt;/pre>
&lt;p>然后，&lt;a href="https://helm.sh/docs/intro/install/">安装 Helm&lt;/a> 并&lt;a href="/v1.8/zh/docs/setup/install/helm/">生成 Istio 最小配置安装&lt;/a> &amp;ndash; 只有流量管理组件：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ helm template install/kubernetes/helm/istio \
--name istio \
--namespace istio-system \
--set security.enabled=false \
--set galley.enabled=false \
--set sidecarInjectorWebhook.enabled=false \
--set mixer.enabled=false \
--set prometheus.enabled=false \
--set pilot.sidecar=false &amp;gt; istio-minimal.yaml
&lt;/code>&lt;/pre>
&lt;p>然后创建 &lt;code>istio-system&lt;/code> namespace 并部署 Istio：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl create namespace istio-system
$ kubectl apply -f istio-minimal.yaml
&lt;/code>&lt;/pre>
&lt;p>然后，在没有 Istio sidecar 容器的前提下部署 Bookinfo 示例：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/platform/kube/bookinfo.yaml@
&lt;/code>&lt;/pre>&lt;/div>
&lt;p>现在，配置一个新的 Gateway 允许从 Istio 网格外部访问 reviews service；一个新的 &lt;code>VirtualService&lt;/code> 用于平均分配到 reviews service v1 和 v2 版本的流量；以及一系列新的、将目标子集与服务版本相匹配的 &lt;code>DestinationRule&lt;/code> 资源：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: reviews-gateway
spec:
selector:
istio: ingressgateway # 使用 istio 默认控制器
servers:
- port:
number: 80
name: http
protocol: HTTP
hosts:
- &amp;#34;*&amp;#34;
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: reviews
spec:
hosts:
- &amp;#34;*&amp;#34;
gateways:
- reviews-gateway
http:
- match:
- uri:
prefix: /reviews
route:
- destination:
host: reviews
subset: v1
weight: 50
- destination:
host: reviews
subset: v2
weight: 50
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: reviews
spec:
host: reviews
subsets:
- name: v1
labels:
version: v1
- name: v2
labels:
version: v2
- name: v3
labels:
version: v3
EOF
&lt;/code>&lt;/pre>
&lt;p>最后，使用 &lt;code>curl&lt;/code> 部署一个用于测试的 Pod（没有 Istio sidecar 容器）：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/sleep/sleep.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/sleep/sleep.yaml@
&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="testing-your-deployment">测试您的部署&lt;/h2>
&lt;p>现在就可以通过 Sleep pod 使用 curl 命令来测试不同的行为了。&lt;/p>
&lt;p>第一个示例是使用标准 Kubernetes service DNS 行为向 reviews service 发出请求（&lt;strong>注意&lt;/strong>：下面的示例中使用了 &lt;a href="https://stedolan.github.io/jq/">&lt;code>jq&lt;/code>&lt;/a> 来过滤 &lt;code>curl&lt;/code> 的输出）：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export SLEEP_POD=$(kubectl get pod -l app=sleep \
-o jsonpath={.items..metadata.name})
$ for i in `seq 3`; do \
kubectl exec -it $SLEEP_POD curl http://reviews:9080/reviews/0 | \
jq &amp;#39;.reviews|.[]|.rating?&amp;#39;; \
done
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;stars&amp;#34;: 5,
&amp;#34;color&amp;#34;: &amp;#34;black&amp;#34;
}
{
&amp;#34;stars&amp;#34;: 4,
&amp;#34;color&amp;#34;: &amp;#34;black&amp;#34;
}
null
null
{
&amp;#34;stars&amp;#34;: 5,
&amp;#34;color&amp;#34;: &amp;#34;red&amp;#34;
}
{
&amp;#34;stars&amp;#34;: 4,
&amp;#34;color&amp;#34;: &amp;#34;red&amp;#34;
}
&lt;/code>&lt;/pre>
&lt;p>请注意我们是如何从 reviews service 的所有三个版本获得响应（&lt;code>null&lt;/code> 来自 reviews v1 版本，它没有评级数据）并且流量没有在 v1 和 v2 版本间平均拆分。这是预期的行为，因为 &lt;code>curl&lt;/code> 命令在 reviews service 所有三个版本之间进行 Kubernetes service 负载均衡。为了以 &lt;sup>50&lt;/sup>&amp;frasl;&lt;sub>50&lt;/sub> 的流量拆分形式访问 reviews，我们需要通过 ingress Gateway 访问 service：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ for i in `seq 4`; do \
kubectl exec -it $SLEEP_POD curl http://istio-ingressgateway.istio-system/reviews/0 | \
jq &amp;#39;.reviews|.[]|.rating?&amp;#39;; \
done
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;stars&amp;#34;: 5,
&amp;#34;color&amp;#34;: &amp;#34;black&amp;#34;
}
{
&amp;#34;stars&amp;#34;: 4,
&amp;#34;color&amp;#34;: &amp;#34;black&amp;#34;
}
null
null
{
&amp;#34;stars&amp;#34;: 5,
&amp;#34;color&amp;#34;: &amp;#34;black&amp;#34;
}
{
&amp;#34;stars&amp;#34;: 4,
&amp;#34;color&amp;#34;: &amp;#34;black&amp;#34;
}
null
null
&lt;/code>&lt;/pre>
&lt;p>任务完成！这篇文章展示了如何部署仅包含流量管理组件（Pilot、ingress Gateway）的 Istio 的最小安装，然后使用这些组件将流量定向到特定版本的 reviews service。由于不是必须通过部署 Istio sidecar 代理来获得这些功能，因此几乎没有给现有工作负载或应用程序造成中断。&lt;/p>
&lt;p>这篇文章展示了如何利用 Istio 及内置的 ingress Gateway（以及一些 &lt;code>VirtualService&lt;/code> 和 &lt;code>DestinationRule&lt;/code> 资源），轻松实现集群外部入口流量和集群内部服务到服务的流量管理。这种技术是增量式应用 Istio 的一个很好的例子，在 Pod 由不同团队拥有，或部署到不同命名空间的现实案例中尤其有用。&lt;/p></description><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/incremental-traffic-management/</link><author>Sandeep Parikh</author><guid isPermaLink="true">/v1.8/zh/blog/2018/incremental-traffic-management/</guid><category>traffic-management</category><category>gateway</category></item><item><title>使用外部 MongoDB 服务</title><description>
&lt;p>在&lt;a href="/v1.8/zh/blog/2018/egress-tcp/">使用外部 TCP 服务&lt;/a>博文中，我描述了网格内的 Istio 应用程序如何通过 TCP 使用外部服务。在本文中，我将演示如何使用外部 MongoDB
服务。您将使用 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Istio Bookinfo 示例应用程序&lt;/a>，它的书籍评级数据保存在 MongoDB 数据库中。您会将此数据库部署在集群外部，并配置 &lt;code>ratings&lt;/code>
微服务使用它。您将学习控制到外部 MongoDB 服务流量的多种选择及其利弊。&lt;/p>
&lt;h2 id="Bookinfo-with-external-ratings-database">使用外部 ratings 数据库的 Bookinfo&lt;/h2>
&lt;p>首先，在您的 Kubernetes 集群外部建立一个 MongoDB 数据库实例以保存书籍评级数据。然后修改 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo 示例应用程序&lt;/a>使用该数据库。&lt;/p>
&lt;h3 id="setting-up-the-ratings-database">建立 ratings 数据库&lt;/h3>
&lt;p>在这个任务中您将建立一个 &lt;a href="https://www.mongodb.com">MongoDB&lt;/a> 实例。您可以使用任何 MongoDB 实例；我使用 &lt;a href="https://www.ibm.com/cloud/compose/mongodb">Compose for MongoDB&lt;/a>。&lt;/p>
&lt;ol>
&lt;li>&lt;p>为 &lt;code>admin&lt;/code> 用户的密码设置一个环境变量。为了避免密码被保存在 Bash 历史记录中，在运行命令之后，请立即使用 &lt;a href="https://www.gnu.org/software/bash/manual/html_node/Bash-History-Builtins.html#Bash-History-Builtins">history -d&lt;/a> 将其从历史记录中删除。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export MONGO_ADMIN_PASSWORD=&amp;lt;your MongoDB admin password&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为需要创建的新用户（即 &lt;code>bookinfo&lt;/code>）的密码设置环境变量，并使用 &lt;a href="https://www.gnu.org/software/bash/manual/html_node/Bash-History-Builtins.html#Bash-History-Builtins">history -d&lt;/a> 将其从历史记录中删除。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export BOOKINFO_PASSWORD=&amp;lt;password&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为您的 MongoDB 服务设置环境变量 &lt;code>MONGODB_HOST&lt;/code> 和 &lt;code>MONGODB_PORT&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>创建 &lt;code>bookinfo&lt;/code> 用户：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | mongo --ssl --sslAllowInvalidCertificates $MONGODB_HOST:$MONGODB_PORT -u admin -p $MONGO_ADMIN_PASSWORD --authenticationDatabase admin
use test
db.createUser(
{
user: &amp;#34;bookinfo&amp;#34;,
pwd: &amp;#34;$BOOKINFO_PASSWORD&amp;#34;,
roles: [ &amp;#34;read&amp;#34;]
}
);
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建一个 &lt;em>collection&lt;/em> 来保存评级数据。以下命令将两个评级都设置为 &lt;code>1&lt;/code>，以便在 Bookinfo &lt;em>ratings&lt;/em> service 使用数据库时提供视觉验证（默认 Bookinfo &lt;em>ratings&lt;/em>
为 &lt;code>4&lt;/code> 和 &lt;code>5&lt;/code>）&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | mongo --ssl --sslAllowInvalidCertificates $MONGODB_HOST:$MONGODB_PORT -u admin -p $MONGO_ADMIN_PASSWORD --authenticationDatabase admin
use test
db.createCollection(&amp;#34;ratings&amp;#34;);
db.ratings.insert(
[{rating: 1},
{rating: 1}]
);
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>检查 &lt;code>bookinfo&lt;/code> 用户是否可以获取评级数据:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | mongo --ssl --sslAllowInvalidCertificates $MONGODB_HOST:$MONGODB_PORT -u bookinfo -p $BOOKINFO_PASSWORD --authenticationDatabase test
use test
db.ratings.find({});
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>输出应该类似于:&lt;/p>
&lt;pre>&lt;code>&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >MongoDB server version: 3.4.10
switched to db test
{ &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;5b7c29efd7596e65b6ed2572&amp;#34;), &amp;#34;rating&amp;#34; : 1 }
{ &amp;#34;_id&amp;#34; : ObjectId(&amp;#34;5b7c29efd7596e65b6ed2573&amp;#34;), &amp;#34;rating&amp;#34; : 1 }
bye
&lt;/code>&lt;/pre>&lt;/code>&lt;/pre>
&lt;h3 id="Initial-setting-of-Bookinfo-application">Bookinfo 应用程序的初始设置&lt;/h3>
&lt;p>为了演示使用外部数据库的场景，请首先运行一个&lt;a href="/v1.8/zh/docs/setup/getting-started/">安装了 Istio&lt;/a> 的 Kubernetes 集群。然后部署
&lt;a href="/v1.8/zh/docs/examples/bookinfo/">Istio Bookinfo 示例应用程序&lt;/a>并&lt;a href="/v1.8/zh/docs/examples/bookinfo/#apply-default-destination-rules">应用默认 destination rules&lt;/a> 和&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-control/#change-to-the-blocking-by-default-policy">改变 Istio 到 blocking-egress-by-default 策略&lt;/a>。&lt;/p>
&lt;p>此应用程序从 &lt;code>ratings&lt;/code> 微服务获取书籍评级（1 到 5 的数字）。评级以星标形式显示每条评论。&lt;code>ratings&lt;/code> 微服务有几个版本。在下一小节中，请部署使用 &lt;a href="https://www.mongodb.com">MongoDB&lt;/a>
作为 ratings 数据库的版本。&lt;/p>
&lt;p>本博文中的示例命令适用于 Istio 1.0。&lt;/p>
&lt;p>作为提醒，这是 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo 示例应用程序&lt;/a>的端到端架构。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:59.086918235567985%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/docs/examples/bookinfo/withistio.svg" title="The original Bookinfo application">
&lt;img class="element-to-stretch" src="/v1.8/zh/docs/examples/bookinfo/withistio.svg" alt="The original Bookinfo application" />
&lt;/a>
&lt;/div>
&lt;figcaption>The original Bookinfo application&lt;/figcaption>
&lt;/figure>
&lt;h3 id="use-the-external-database-in-Bookinfo-application">在 Bookinfo 应用程序中使用外部数据库&lt;/h3>
&lt;ol>
&lt;li>&lt;p>部署使用 MongoDB 数据库的 &lt;em>ratings&lt;/em> 微服务（_ratings v2_）：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml@
serviceaccount &amp;#34;bookinfo-ratings-v2&amp;#34; created
deployment &amp;#34;ratings-v2&amp;#34; created
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>为你的 MongoDB 设置 &lt;code>MONGO_DB_URL&lt;/code> 环境变量：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl set env deployment/ratings-v2 &amp;#34;MONGO_DB_URL=mongodb://bookinfo:$BOOKINFO_PASSWORD@$MONGODB_HOST:$MONGODB_PORT/test?authSource=test&amp;amp;ssl=true&amp;#34;
deployment.extensions/ratings-v2 env updated
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>将所有到 &lt;em>reviews&lt;/em> service 的流量路由到它的 &lt;em>v3&lt;/em> 版本，以确保 &lt;em>reviews&lt;/em> service 总是调用 &lt;em>ratings&lt;/em> service。此外，将所有到 &lt;code>ratings&lt;/code> service
的流量路由到使用外部数据库的 _ratings v2_。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>通过添加两个 &lt;a href="/v1.8/zh/docs/reference/config/networking/virtual-service/">virtual services&lt;/a> 来为以上两个 services 指定路由。这些 virtual service
在 Istio 发布包中 &lt;code>samples/bookinfo/networking/virtual-service-ratings-mongodb.yaml&lt;/code> 有指定 。
&lt;strong>&lt;em>重要：&lt;/em>&lt;/strong> 请确保在运行以下命令之前&lt;a href="/v1.8/zh/docs/examples/bookinfo/#apply-default-destination-rules">应用了默认的 destination rules&lt;/a>。&lt;/p>
&lt;pre>&lt;code>&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-ratings-db.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/networking/virtual-service-ratings-db.yaml@
&lt;/code>&lt;/pre>&lt;/div>&lt;/code>&lt;/pre>
&lt;p>更新的架构如下所示。请注意，网格内的蓝色箭头标记对应于我们添加的 virtual service。根据 virtual service，流量将被发送到 &lt;code>reviews v3&lt;/code> 和 &lt;code>ratings v2&lt;/code>。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:59.314858206480224%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-mongo/bookinfo-ratings-v2-mongodb-external.svg" title="The Bookinfo application with ratings v2 and an external MongoDB database">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-mongo/bookinfo-ratings-v2-mongodb-external.svg" alt="The Bookinfo application with ratings v2 and an external MongoDB database" />
&lt;/a>
&lt;/div>
&lt;figcaption>The Bookinfo application with ratings v2 and an external MongoDB database&lt;/figcaption>
&lt;/figure>
&lt;p>请注意，MongoDB 数据库位于 Istio 服务网格之外，或者更确切地说是在 Kubernetes 集群之外。服务网格的边界使用虚线标记。&lt;/p>
&lt;h3 id="access-the-webpage">访问网页&lt;/h3>
&lt;p>&lt;a href="/v1.8/zh/docs/examples/bookinfo/#determine-the-ingress-IP-and-port">确认 ingress IP 和端口之后&lt;/a>，访问应用程序的网页。&lt;/p>
&lt;p>由于您尚未配置 egress 流量控制，所以 Istio 会阻止到 MongoDB 服务的访问。这就是为什么您当前不能看到评级的星标，只能看到 &lt;em>&amp;ldquo;Ratings service is currently unavailable&amp;rdquo;&lt;/em> 的信息：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:36.18705035971223%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-mongo/errorFetchingBookRating.png" title="The Ratings service error messages">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-mongo/errorFetchingBookRating.png" alt="The Ratings service error messages" />
&lt;/a>
&lt;/div>
&lt;figcaption>The Ratings service error messages&lt;/figcaption>
&lt;/figure>
&lt;p>在以下部分中，您将使用不同的 Istio egress 控制选项，配置对外部 MongoDB 服务的访问。&lt;/p>
&lt;h2 id="egress-control-for-TCP">TCP 的 egress 控制&lt;/h2>
&lt;p>由于 &lt;a href="https://zh/docs.mongodb.com/manual/reference/mongodb-wire-protocol/">MongoDB 协议&lt;/a>运行在 TCP 之上，您可以像控制到&lt;a href="/v1.8/zh/blog/2018/egress-tcp/">其余 TCP 服务&lt;/a>的流量一样控制到 MongoDB 的 egress 流量。为了控制 TCP 流量，您必须指定一个 &lt;a href="https://tools.ietf.org/html/rfc2317">CIDR&lt;/a> 表示的 IP 块，该 IP 块包含 MongoDB 的地址。需要注意的是，有时候 MongoDB 主机的 IP 并不稳定或无法事先得知。&lt;/p>
&lt;p>在 MongoDB IP 不稳定的情况下，可以以 &lt;a href="#egress-control-for-TLS">TLS 方式控制&lt;/a> egress 流量，或绕过 Istio sidecar &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-control/#direct-access-to-external-services">直接&lt;/a>路由流量。&lt;/p>
&lt;p>获取 MongoDB 数据库实例的 IP 地址。一种选择是使用 &lt;a href="https://linux.die.net/man/1/host">host&lt;/a> 命令。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export MONGODB_IP=$(host $MONGODB_HOST | grep &amp;#34; has address &amp;#34; | cut -d&amp;#34; &amp;#34; -f4)
&lt;/code>&lt;/pre>
&lt;h3 id="control-TCP-egress-traffic-without-a-gateway">在没有 gateway 的情况下控制 TCP egress 流量&lt;/h3>
&lt;p>如果您不用通过 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#use-case">egress gateway&lt;/a> 定向流量，例如不要求所有流量都通过 gateway 流出网格时，请遵循以下部分的说明。或者，如果您确实希望通过 egress gateway 定向流量，请继续阅读&lt;a href="#direct-tcp-egress-traffic-through-an-egress-gateway">通过 egress gateway 定向 TCP egress 流量&lt;/a>。&lt;/p>
&lt;ol>
&lt;li>&lt;p>定义一个网格外 TCP service entry：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: mongo
spec:
hosts:
- my-mongo.tcp.svc
addresses:
- $MONGODB_IP/32
ports:
- number: $MONGODB_PORT
name: tcp
protocol: TCP
location: MESH_EXTERNAL
resolution: STATIC
endpoints:
- address: $MONGODB_IP
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>请注意，protocol 被指定为 &lt;code>TCP&lt;/code> 而不是 &lt;code>MONGO&lt;/code>，因为如果 &lt;a href="https://zh/docs.mongodb.com/manual/tutorial/configure-ssl/">MongoDB 协议运行在 TLS 之上时&lt;/a>，流量可以加密。如果加密了流量，该加密的 MongoDB 协议就不能被 Istio 代理解析。&lt;/p>
&lt;p>如果您知道使用的是未加密的 MongoDB 协议，可以指定 protocol 为 &lt;code>MONGO&lt;/code>，从而使 Istio 代理产生 &lt;a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/mongo_proxy_filter#statistics">MongoDB 相关的统计数据&lt;/a>。还要注意，当指定 protocol &lt;code>TCP&lt;/code> 时，配置不是特定于 MongoDB 的，对于其余使用基于 TCP 协议的数据库同样适用。&lt;/p>
&lt;ol>
&lt;li>&lt;p>刷新应用程序的网页。应用程序现在应该显示评级数据而非错误：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:36.69064748201439%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-mongo/externalDBRatings.png" title="Book Ratings Displayed Correctly">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-mongo/externalDBRatings.png" alt="Book Ratings Displayed Correctly" />
&lt;/a>
&lt;/div>
&lt;figcaption>Book Ratings Displayed Correctly&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;/ol>
&lt;p>请注意，和预期的一样，您会看到两个显示评论的一星评级。您将评级设置为一星，以作为外部数据库确实被使用了的视觉证据。&lt;/p>
&lt;ol>
&lt;li>如果要通过出口网关引导流量，请继续下一节。否则，请执行 &lt;a href="#cleanup-of-TCP-egress-traffic-control">cleanup&lt;/a>.&lt;/li>
&lt;/ol>
&lt;h3 id="direct-TCP-egress-traffic-through-an-egress-gateway">通过 egress gateway 定向 TCP Egress 流量&lt;/h3>
&lt;p>在本节中，您将处理通过 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#use-case">egress gateway&lt;/a> 定向流量的情况。Sidecar 代理通过匹配 MongoDB 主机的 IP 地址（一个 32 位长度的 CIDR 块），将 TCP 连接从 MongoDB 客户端路由到 egress gateway。Egress gateway 按照其 hostname，转发流量到 MongoDB 主机。&lt;/p>
&lt;ol>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#deploy-Istio-egress-gateway">部署 Istio egress gateway&lt;/a>.&lt;/p>&lt;/li>
&lt;li>&lt;p>如果您未执行&lt;a href="#control-TCP-egress-traffic-without-a-gateway">上一节&lt;/a>中的步骤，则立即执行这些步骤。&lt;/p>&lt;/li>
&lt;li>&lt;p>您可能希望启用 sidecar 代理和 MongoDB 客户端之间以及 egress gateway 的 &lt;span class="term" data-title="Mutual TLS Authentication" data-body="&amp;lt;p&amp;gt;双向 TLS 通过内置身份和凭证管理，提供强大的服务到服务身份验证。
&amp;lt;a href=&amp;#34;/zh/docs/concepts/security/#mutual-TLS-authentication&amp;#34;&amp;gt;了解更多关于双向 TLS 身份验证&amp;lt;/a&amp;gt;。&amp;lt;/p&amp;gt;
">mutual TLS Authentication&lt;/span>，以使 egress gateway 监控来源 pod 的身份并基于该 identity 启用 Mixer 策略。启用双向 TLS 时同样对流量进行了加密。
如果你不想开启双向 TLS，参考 &lt;a href="#mutual-TLS-between-the-sidecar-proxies-and-the-egress-gateway">Mutual TLS between the sidecar proxies and the egress gateway&lt;/a> 小节
否则，请继续以下部分。&lt;/p>&lt;/li>
&lt;/ol>
&lt;h4 id="configure-TCP-traffic-from-sidecars-to-the-egress-gateway">配置从 sidecar 到 egress gateway 的 TCP 流量&lt;/h4>
&lt;ol>
&lt;li>&lt;p>定义 &lt;code>EGRESS_GATEWAY_MONGODB_PORT&lt;/code> 环境变量来保存用于通过 egress gateway 定向流量的端口，例如 &lt;code>7777&lt;/code>。必须选择没有被网格中其余 service 使用的端口。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export EGRESS_GATEWAY_MONGODB_PORT=7777
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>添加选择的端口到 &lt;code>istio-egressgateway&lt;/code> service。您需要使用和安装 Istio 时一样的端口，特别是必须指定前面配置 &lt;code>istio-egressgateway&lt;/code> 的所有端口。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ helm template install/kubernetes/helm/istio/ --name istio-egressgateway --namespace istio-system -x charts/gateways/templates/deployment.yaml -x charts/gateways/templates/service.yaml --set gateways.istio-ingressgateway.enabled=false --set gateways.istio-egressgateway.enabled=true --set gateways.istio-egressgateway.ports[0].port=80 --set gateways.istio-egressgateway.ports[0].name=http --set gateways.istio-egressgateway.ports[1].port=443 --set gateways.istio-egressgateway.ports[1].name=https --set gateways.istio-egressgateway.ports[2].port=$EGRESS_GATEWAY_MONGODB_PORT --set gateways.istio-egressgateway.ports[2].name=mongo | kubectl apply -f -
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>检查 &lt;code>istio-egressgateway&lt;/code> service 确实有选择的端口：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get svc istio-egressgateway -n istio-system
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
istio-egressgateway ClusterIP 172.21.202.204 &amp;lt;none&amp;gt; 80/TCP,443/TCP,7777/TCP 34d
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为 &lt;code>istio-egressgateway&lt;/code> 服务 关闭双向 TLS 认证&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
name: istio-egressgateway
namespace: istio-system
spec:
targets:
- name: istio-egressgateway
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为您的 MongoDB service 创建一个 egress &lt;code>Gateway&lt;/code>、一个 destination rules 和 virtual services，以定向流量到 egress gateway，并从 egress gateway 发送到外部服务。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: istio-egressgateway
spec:
selector:
istio: egressgateway
servers:
- port:
number: $EGRESS_GATEWAY_MONGODB_PORT
name: tcp
protocol: TCP
hosts:
- my-mongo.tcp.svc
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: egressgateway-for-mongo
spec:
host: istio-egressgateway.istio-system.svc.cluster.local
subsets:
- name: mongo
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: mongo
spec:
host: my-mongo.tcp.svc
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-mongo-through-egress-gateway
spec:
hosts:
- my-mongo.tcp.svc
gateways:
- mesh
- istio-egressgateway
tcp:
- match:
- gateways:
- mesh
destinationSubnets:
- $MONGODB_IP/32
port: $MONGODB_PORT
route:
- destination:
host: istio-egressgateway.istio-system.svc.cluster.local
subset: mongo
port:
number: $EGRESS_GATEWAY_MONGODB_PORT
- match:
- gateways:
- istio-egressgateway
port: $EGRESS_GATEWAY_MONGODB_PORT
route:
- destination:
host: my-mongo.tcp.svc
port:
number: $MONGODB_PORT
weight: 100
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>&lt;a href="#verify-that-egress-traffic-is-directed-through-the-egress-gateway">验证 TCP egress 流量是否被定向到 egress gateway&lt;/a>.&lt;/p>&lt;/li>
&lt;/ol>
&lt;h4 id="mutual-TLS-between-the-sidecar-proxies-and-the-egress-gateway">Sidecar 代理和 egress gateway 之间的双向 TLS&lt;/h4>
&lt;ol>
&lt;li>&lt;p>删除前面小节中的配置：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete gateway istio-egressgateway --ignore-not-found=true
$ kubectl delete virtualservice direct-mongo-through-egress-gateway --ignore-not-found=true
$ kubectl delete destinationrule egressgateway-for-mongo mongo --ignore-not-found=true
$ kubectl delete policy istio-egressgateway -n istio-system --ignore-not-found=true
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>Enforce mutual TLS authentication for the &lt;code>istio-egressgateway&lt;/code> service:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: authentication.istio.io/v1alpha1
kind: Policy
metadata:
name: istio-egressgateway
namespace: istio-system
spec:
targets:
- name: istio-egressgateway
peers:
- mtls: {}
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为您的 MongoDB service 创建一个 egress &lt;code>Gateway&lt;/code>、一个 destination rules 和 virtual services，以定向流量到 egress gateway，并从 egress gateway 发送到外部服务。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: istio-egressgateway
spec:
selector:
istio: egressgateway
servers:
- port:
number: 443
name: tls
protocol: TLS
hosts:
- my-mongo.tcp.svc
tls:
mode: MUTUAL
serverCertificate: /etc/certs/cert-chain.pem
privateKey: /etc/certs/key.pem
caCertificates: /etc/certs/root-cert.pem
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: egressgateway-for-mongo
spec:
host: istio-egressgateway.istio-system.svc.cluster.local
subsets:
- name: mongo
trafficPolicy:
loadBalancer:
simple: ROUND_ROBIN
portLevelSettings:
- port:
number: 443
tls:
mode: ISTIO_MUTUAL
sni: my-mongo.tcp.svc
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: mongo
spec:
host: my-mongo.tcp.svc
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-mongo-through-egress-gateway
spec:
hosts:
- my-mongo.tcp.svc
gateways:
- mesh
- istio-egressgateway
tcp:
- match:
- gateways:
- mesh
destinationSubnets:
- $MONGODB_IP/32
port: $MONGODB_PORT
route:
- destination:
host: istio-egressgateway.istio-system.svc.cluster.local
subset: mongo
port:
number: 443
- match:
- gateways:
- istio-egressgateway
port: 443
route:
- destination:
host: my-mongo.tcp.svc
port:
number: $MONGODB_PORT
weight: 100
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>继续下一节。&lt;/p>&lt;/li>
&lt;/ol>
&lt;h4 id="verify-that-egress-traffic-is-directed-through-the-egress-gateway">验证 TCP egress 流量是否通过 egress gateway 定向&lt;/h4>
&lt;ol>
&lt;li>&lt;p>再次刷新应用程序的网页，并验证等级是否仍正确显示。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/observability/logs/access-log/#enable-envoy-s-access-logging">开启 Envoy 访问日志&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>检查 egress gateway 的 Envoy 的统计数据，找到对应请求 MongoDB service 的 counter。如果 Istio 步骤在 &lt;code>istio-system&lt;/code> namespace 中，打印 counter 的命令为：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs -l istio=egressgateway -n istio-system
[2019-04-14T06:12:07.636Z] &amp;#34;- - -&amp;#34; 0 - &amp;#34;-&amp;#34; 1591 4393 94 - &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;&amp;lt;Your MongoDB IP&amp;gt;:&amp;lt;your MongoDB port&amp;gt;&amp;#34; outbound|&amp;lt;your MongoDB port&amp;gt;||my-mongo.tcp.svc 172.30.146.119:59924 172.30.146.119:443 172.30.230.1:59206 -
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h3 id="cleanup-of-TCP-egress-traffic-control">清理通过 egress gateway 定向 TCP egress 流量的配置&lt;/h3>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry mongo
$ kubectl delete gateway istio-egressgateway --ignore-not-found=true
$ kubectl delete virtualservice direct-mongo-through-egress-gateway --ignore-not-found=true
$ kubectl delete destinationrule egressgateway-for-mongo mongo --ignore-not-found=true
$ kubectl delete policy istio-egressgateway -n istio-system --ignore-not-found=true
&lt;/code>&lt;/pre>
&lt;h2 id="egress-control-for-TLS">TLS egress 控制&lt;/h2>
&lt;p>在现实生活中，绝大多数到外部服务的通信都必须被加密，而 &lt;a href="https://zh/docs.mongodb.com/manual/tutorial/configure-ssl/">MongoDB 协议在 TLS 之上运行&lt;/a>。
并且，TLS 客户端经常发送&lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">服务器名称指示&lt;/a>，SNI，作为握手的一部分。
如果您的 MongoDB 服务器运行 TLS 且 MongoDB 客户端发送 SNI 作为握手的一部分，您就可以像任何其余带有 SNI 的 TLS 流量一样控制 MongoDB egress 流量。
您不需要指定 MongoDB 服务器的 IP 地址，而只需指定他们的主机名称，这样会更加方便，因为您无需依赖 IP 地址的稳定性。
您还可以指定通配符为主机名的前缀，例如允许从 &lt;code>*.com&lt;/code> 域访问任意服务器。&lt;/p>
&lt;p>要想检查您的 MongoDB 服务器是否支持 TLS，请运行：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ openssl s_client -connect $MONGODB_HOST:$MONGODB_PORT -servername $MONGODB_HOST
&lt;/code>&lt;/pre>
&lt;p>如果上述命令打印了一个服务器返回的证书，说明该服务器支持 TLS。如果没有，您就需要像前面小节描述的一样在 TCP 层面控制 MongoDB egress 流量。&lt;/p>
&lt;h3 id="control-TLS-egress-traffic-without-a-gateway">无 gateway 情况下控制 TLS egress 流量&lt;/h3>
&lt;p>如果您&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#use-case">不需要 egress gateway&lt;/a>，请遵循本小节中的说明。
如果您需要通过 egress gateway 定向流量，请继续阅读&lt;a href="#direct-tcp-egress-traffic-through-an-egress-gateway">通过 egress gateway 定向 TCP Egress 流量&lt;/a>。&lt;/p>
&lt;ol>
&lt;li>&lt;p>为 MongoDB service 创建一个 &lt;code>ServiceEntry&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: mongo
spec:
hosts:
- $MONGODB_HOST
ports:
- number: $MONGODB_PORT
name: tls
protocol: TLS
resolution: DNS
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>刷新应用程序的网页。应用程序应该正确显示评级数据。&lt;/p>&lt;/li>
&lt;/ol>
&lt;h4 id="cleanup-of-the-egress-configuration-for-TLS">清理 TLS 的 egress 配置&lt;/h4>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry mongo
&lt;/code>&lt;/pre>
&lt;h3 id="direct-tcp-egress-traffic-through-an-egress-gateway">通过 egress gateway 定向 TLS Egress 流量&lt;/h3>
&lt;p>在本小节中，您将处理通过 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#use-case">egress gateway&lt;/a> 定向流量的情况。
Sidecar 代理通过匹配 MongoDB 主机的 SNI，将 TLS 连接从 MongoDB 客户端路由到 egress gateway。
Egress gateway 再将流量转发到 MongoDB 主机。请注意，sidecar 代理会将目的端口重写为 443。
Egress gateway 在 443 端口上接受 MongoDB 流量，按照 SNI 匹配 MongoDB 主机，并再次将端口重写为 MongoDB 服务器的端口。&lt;/p>
&lt;ol>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#deploy-Istio-egress-gateway">部署 Istio egress gateway&lt;/a>.&lt;/p>&lt;/li>
&lt;li>&lt;p>为 MongoDB service 创建一个 &lt;code>ServiceEntry&lt;/code>:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: mongo
spec:
hosts:
- $MONGODB_HOST
ports:
- number: $MONGODB_PORT
name: tls
protocol: TLS
- number: 443
name: tls-port-for-egress-gateway
protocol: TLS
resolution: DNS
location: MESH_EXTERNAL
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>刷新应用程序的网页并验证评级数据是否显示正常。&lt;/p>&lt;/li>
&lt;li>&lt;p>为您的 MongoDB service 创建一个 egress &lt;code>Gateway&lt;/code>、一个 destination rules 和 virtual services，以将流量定向到 egress gateway，并从 egress gateway 发送到外部服务。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>如果您希望启用 sidecar 代理和应用程序 pod 以及 egress gateway 之间的&lt;a href="/v1.8/zh/docs/tasks/security/authentication/authn-policy/#auto-mutual-TLS">双向 TLS 认证&lt;/a>，可以使用下面的命令。（您可能希望启用双向 TLS 以使 egress gateway 监控来源 pod 的身份并基于该 identity 启用 Mixer 策略。）&lt;/p>
&lt;pre>&lt;code>&lt;div id="tabset-zh-blog-2018-egress-mongo-1" role="tablist" class="tabset">
&lt;div class="tab-strip" data-category-name="mtls">&lt;button aria-selected="true" data-category-value="enabled"
aria-controls="tabset-zh-blog-2018-egress-mongo-1-0-panel" id="tabset-zh-blog-2018-egress-mongo-1-0-tab" role="tab">&lt;span>mutual TLS enabled&lt;/span>
&lt;/button>&lt;button tabindex="-1" data-category-value="disabled"
aria-controls="tabset-zh-blog-2018-egress-mongo-1-1-panel" id="tabset-zh-blog-2018-egress-mongo-1-1-tab" role="tab">&lt;span>mutual TLS disabled&lt;/span>
&lt;/button>&lt;/div>
&lt;div class="tab-content">&lt;div id="tabset-zh-blog-2018-egress-mongo-1-0-panel" role="tabpanel" tabindex="0" aria-labelledby="tabset-zh-blog-2018-egress-mongo-1-0-tab">&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: istio-egressgateway
spec:
selector:
istio: egressgateway
servers:
- port:
number: 443
name: tls
protocol: TLS
hosts:
- $MONGODB_HOST
tls:
mode: MUTUAL
serverCertificate: /etc/certs/cert-chain.pem
privateKey: /etc/certs/key.pem
caCertificates: /etc/certs/root-cert.pem
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: egressgateway-for-mongo
spec:
host: istio-egressgateway.istio-system.svc.cluster.local
subsets:
- name: mongo
trafficPolicy:
loadBalancer:
simple: ROUND_ROBIN
portLevelSettings:
- port:
number: 443
tls:
mode: ISTIO_MUTUAL
sni: $MONGODB_HOST
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-mongo-through-egress-gateway
spec:
hosts:
- $MONGODB_HOST
gateways:
- mesh
- istio-egressgateway
tls:
- match:
- gateways:
- mesh
port: $MONGODB_PORT
sni_hosts:
- $MONGODB_HOST
route:
- destination:
host: istio-egressgateway.istio-system.svc.cluster.local
subset: mongo
port:
number: 443
tcp:
- match:
- gateways:
- istio-egressgateway
port: 443
route:
- destination:
host: $MONGODB_HOST
port:
number: $MONGODB_PORT
weight: 100
EOF
&lt;/code>&lt;/pre>
&lt;/div>&lt;div hidden id="tabset-zh-blog-2018-egress-mongo-1-1-panel" role="tabpanel" tabindex="0" aria-labelledby="tabset-zh-blog-2018-egress-mongo-1-1-tab">&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: istio-egressgateway
spec:
selector:
istio: egressgateway
servers:
- port:
number: 443
name: tls
protocol: TLS
hosts:
- $MONGODB_HOST
tls:
mode: PASSTHROUGH
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: egressgateway-for-mongo
spec:
host: istio-egressgateway.istio-system.svc.cluster.local
subsets:
- name: mongo
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-mongo-through-egress-gateway
spec:
hosts:
- $MONGODB_HOST
gateways:
- mesh
- istio-egressgateway
tls:
- match:
- gateways:
- mesh
port: $MONGODB_PORT
sni_hosts:
- $MONGODB_HOST
route:
- destination:
host: istio-egressgateway.istio-system.svc.cluster.local
subset: mongo
port:
number: 443
- match:
- gateways:
- istio-egressgateway
port: 443
sni_hosts:
- $MONGODB_HOST
route:
- destination:
host: $MONGODB_HOST
port:
number: $MONGODB_PORT
weight: 100
EOF
&lt;/code>&lt;/pre>
&lt;/div>&lt;/div>
&lt;/div>
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>&lt;a href="#verify-that-egress-traffic-is-directed-through-the-egress-gateway">验证 TCP egress 流量是否通过 egress gateway 定向&lt;/a>&lt;/li>
&lt;/ol>
&lt;h4 id="cleanup-directing-TLS-Egress-traffic-through-an-egress-gateway">清除通过 egress gateway 定向 TLS Egress 流量的配置&lt;/h4>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry mongo
$ kubectl delete gateway istio-egressgateway
$ kubectl delete virtualservice direct-mongo-through-egress-gateway
$ kubectl delete destinationrule egressgateway-for-mongo
&lt;/code>&lt;/pre>
&lt;h3 id="enable-MongoDB-TLS-egress-traffic-to-arbitrary-wildcarded-domains">启用到任意通配符域名的 MongoDB TLS egress 流量&lt;/h3>
&lt;p>有时，您希望将 egress 流量配置为来自同一域的多个主机名，例如到 &lt;code>*.&amp;lt;your company domain&amp;gt;.com&lt;/code> 中的所有 MongoDB service。
您不希望创建多个配置项，而是一个用于公司中所有 MongoDB service 的通用配置项。
要想通过一个配置来控制到所有相同域中的外部服务的访问，您需要使用 &lt;em>通配符&lt;/em> 主机。&lt;/p>
&lt;p>在本节中，您将为通配符域名配置 egress gateway。我在 &lt;code>composedb.com&lt;/code> 处使用了 MongoDB instance，
因此为 &lt;code>*.com&lt;/code> 配置出口流量对我有效（我也可以使用&lt;code>*.composedb.com&lt;/code>）。
您可以根据 MongoDB 主机选择通配符域名。&lt;/p>
&lt;p>要为通配符域名配置 egress gateway 流量，
您需要使用&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/wildcard-egress-hosts/#wildcard-configuration-for-arbitrary-domains">一个额外的 SNI 代理&lt;/a>来部署一个自定义的 egress gateway。由于 Envoy（Istio egress gateway 使用的标准代理）目前的限制，这是必须的。&lt;/p>
&lt;h4 id="prepare-a-new-egress-gateway-with-an-SNI-proxy">准备一个 SNI 代理使用新的 egress gateway&lt;/h4>
&lt;p>在本节中，除了标准的 Istio Envoy 代理之外，您还将部署具有 SNI 代理的 egress gateway。您可以使用任何能够根据任意未预先配置的 SNI 值路由流量的 SNI 代理；我们使用 &lt;a href="http://nginx.org">Nginx&lt;/a> 来实现这一功能。&lt;/p>
&lt;ol>
&lt;li>&lt;p>为 Nginx SNI 代理创建配置文件。如果需要，您可以编辑该文件以指定其他 Nginx 设置。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF &amp;gt; ./sni-proxy.conf
user www-data;
events {
}
stream {
log_format log_stream &amp;#39;\$remote_addr [\$time_local] \$protocol [\$ssl_preread_server_name]&amp;#39;
&amp;#39;\$status \$bytes_sent \$bytes_received \$session_time&amp;#39;;
access_log /var/log/nginx/access.log log_stream;
error_log /var/log/nginx/error.log;
# tcp forward proxy by SNI
server {
resolver 8.8.8.8 ipv6=off;
listen 127.0.0.1:$MONGODB_PORT;
proxy_pass \$ssl_preread_server_name:$MONGODB_PORT;
ssl_preread on;
}
}
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建一个 Kubernetes &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">ConfigMap&lt;/a> 来保存 Nginx SNI 代理的配置：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl create configmap egress-sni-proxy-configmap -n istio-system --from-file=nginx.conf=./sni-proxy.conf
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>下面的命令将产生用于编辑和部署的 &lt;code>istio-egressgateway-with-sni-proxy.yaml&lt;/code> 文件。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | helm template install/kubernetes/helm/istio/ --name istio-egressgateway-with-sni-proxy --namespace istio-system -x charts/gateways/templates/deployment.yaml -x charts/gateways/templates/service.yaml -x charts/gateways/templates/serviceaccount.yaml -x charts/gateways/templates/autoscale.yaml -x charts/gateways/templates/role.yaml -x charts/gateways/templates/rolebindings.yaml --set global.mtls.enabled=true --set global.istioNamespace=istio-system -f - &amp;gt; ./istio-egressgateway-with-sni-proxy.yaml
gateways:
enabled: true
istio-ingressgateway:
enabled: false
istio-egressgateway:
enabled: false
istio-egressgateway-with-sni-proxy:
enabled: true
labels:
app: istio-egressgateway-with-sni-proxy
istio: egressgateway-with-sni-proxy
replicaCount: 1
autoscaleMin: 1
autoscaleMax: 5
cpu:
targetAverageUtilization: 80
serviceAnnotations: {}
type: ClusterIP
ports:
- port: 443
name: https
secretVolumes:
- name: egressgateway-certs
secretName: istio-egressgateway-certs
mountPath: /etc/istio/egressgateway-certs
- name: egressgateway-ca-certs
secretName: istio-egressgateway-ca-certs
mountPath: /etc/istio/egressgateway-ca-certs
configVolumes:
- name: sni-proxy-config
configMapName: egress-sni-proxy-configmap
additionalContainers:
- name: sni-proxy
image: nginx
volumeMounts:
- name: sni-proxy-config
mountPath: /etc/nginx
readOnly: true
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>部署新的 egress gateway：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f ./istio-egressgateway-with-sni-proxy.yaml
serviceaccount &amp;#34;istio-egressgateway-with-sni-proxy-service-account&amp;#34; created
role &amp;#34;istio-egressgateway-with-sni-proxy-istio-system&amp;#34; created
rolebinding &amp;#34;istio-egressgateway-with-sni-proxy-istio-system&amp;#34; created
service &amp;#34;istio-egressgateway-with-sni-proxy&amp;#34; created
deployment &amp;#34;istio-egressgateway-with-sni-proxy&amp;#34; created
horizontalpodautoscaler &amp;#34;istio-egressgateway-with-sni-proxy&amp;#34; created
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>验证新 egress gateway 是否工作正常。请注意 pod 有两个容器（一个是 Envoy 代理，另一个是 SNI 代理）。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pod -l istio=egressgateway-with-sni-proxy -n istio-system
NAME READY STATUS RESTARTS AGE
istio-egressgateway-with-sni-proxy-79f6744569-pf9t2 2/2 Running 0 17s
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建一个使用静态地址 127.0.0.1 (&lt;code>localhost&lt;/code>) 的 service entry，并对定向到新 service entry 的流量禁用双向 TLS：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: sni-proxy
spec:
hosts:
- sni-proxy.local
location: MESH_EXTERNAL
ports:
- number: $MONGODB_PORT
name: tcp
protocol: TCP
resolution: STATIC
endpoints:
- address: 127.0.0.1
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: disable-mtls-for-sni-proxy
spec:
host: sni-proxy.local
trafficPolicy:
tls:
mode: DISABLE
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h4 id="configure-access-to-com-using-the-new-egress-gateway">使用新 egress gateway 配置到 &lt;code>*.com&lt;/code> 的访问&lt;/h4>
&lt;ol>
&lt;li>&lt;p>为 &lt;code>*.com&lt;/code> 定义一个 &lt;code>ServiceEntry&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl create -f -
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: mongo
spec:
hosts:
- &amp;#34;*.com&amp;#34;
ports:
- number: 443
name: tls
protocol: TLS
- number: $MONGODB_PORT
name: tls-mongodb
protocol: TLS
location: MESH_EXTERNAL
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>为 *.com 创建一个 egress Gateway，使用 443 端口和 TLS 协议。创建一个 destination rule 来为 gateway 设置 &lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI&lt;/a>。
以及为 Envoy 过滤器，以防止恶意应用程序篡改 SNI (过滤器验证这个应用程序发布的 SNI 与报告给 Mixer 的 SNI 是否相同)&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: istio-egressgateway-with-sni-proxy
spec:
selector:
istio: egressgateway-with-sni-proxy
servers:
- port:
number: 443
name: tls
protocol: TLS
hosts:
- &amp;#34;*.com&amp;#34;
tls:
mode: MUTUAL
serverCertificate: /etc/certs/cert-chain.pem
privateKey: /etc/certs/key.pem
caCertificates: /etc/certs/root-cert.pem
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: mtls-for-egress-gateway
spec:
host: istio-egressgateway-with-sni-proxy.istio-system.svc.cluster.local
subsets:
- name: mongo
trafficPolicy:
loadBalancer:
simple: ROUND_ROBIN
portLevelSettings:
- port:
number: 443
tls:
mode: ISTIO_MUTUAL
---
# The following filter is used to forward the original SNI (sent by the application) as the SNI of the mutual TLS
# connection.
# The forwarded SNI will be reported to Mixer so that policies will be enforced based on the original SNI value.
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
name: forward-downstream-sni
spec:
filters:
- listenerMatch:
portNumber: $MONGODB_PORT
listenerType: SIDECAR_OUTBOUND
filterName: forward_downstream_sni
filterType: NETWORK
filterConfig: {}
---
# The following filter verifies that the SNI of the mutual TLS connection (the SNI reported to Mixer) is
# identical to the original SNI issued by the application (the SNI used for routing by the SNI proxy).
# The filter prevents Mixer from being deceived by a malicious application: routing to one SNI while
# reporting some other value of SNI. If the original SNI does not match the SNI of the mutual TLS connection, the
# filter will block the connection to the external service.
apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
name: egress-gateway-sni-verifier
spec:
workloadLabels:
app: istio-egressgateway-with-sni-proxy
filters:
- listenerMatch:
portNumber: 443
listenerType: GATEWAY
filterName: sni_verifier
filterType: NETWORK
filterConfig: {}
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>将目的为 &lt;em>*.com&lt;/em> 的流量路由到 egress gateway，并从 egress gateway 路由到 SNI 代理.&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-mongo-through-egress-gateway
spec:
hosts:
- &amp;#34;*.com&amp;#34;
gateways:
- mesh
- istio-egressgateway-with-sni-proxy
tls:
- match:
- gateways:
- mesh
port: $MONGODB_PORT
sni_hosts:
- &amp;#34;*.com&amp;#34;
route:
- destination:
host: istio-egressgateway-with-sni-proxy.istio-system.svc.cluster.local
subset: mongo
port:
number: 443
weight: 100
tcp:
- match:
- gateways:
- istio-egressgateway-with-sni-proxy
port: 443
route:
- destination:
host: sni-proxy.local
port:
number: $MONGODB_PORT
weight: 100
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>再次刷新应用程序的网页，验证评级数据仍然显示正确。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/observability/logs/access-log/#enable-envoy-s-access-logging">开启 Envoy 访问日志&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>检查 egress gateway 的 Envoy 的日志。如果 Istio 部署在 &lt;code>istio-system&lt;/code> namespace 中，打印日志的的命令为：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs -l istio=egressgateway-with-sni-proxy -c istio-proxy -n istio-system
&lt;/code>&lt;/pre>
&lt;p>You should see lines similar to the following:&lt;/p>
&lt;pre>&lt;code class='language-plain' data-expandlinks='true' data-repo='istio' >[2019-01-02T17:22:04.602Z] &amp;#34;- - -&amp;#34; 0 - 768 1863 88 - &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;127.0.0.1:28543&amp;#34; outbound|28543||sni-proxy.local 127.0.0.1:49976 172.30.146.115:443 172.30.146.118:58510 &amp;lt;your MongoDB host&amp;gt;
[2019-01-02T17:22:04.713Z] &amp;#34;- - -&amp;#34; 0 - 1534 2590 85 - &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;-&amp;#34; &amp;#34;127.0.0.1:28543&amp;#34; outbound|28543||sni-proxy.local 127.0.0.1:49988 172.30.146.115:443 172.30.146.118:58522 &amp;lt;your MongoDB host&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>检查 SNI 代理的日志。如果 Istio 部署在 &lt;code>istio-system&lt;/code> namespace 中，打印日志的命令为：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs -l istio=egressgateway-with-sni-proxy -n istio-system -c sni-proxy
127.0.0.1 [23/Aug/2018:03:28:18 +0000] TCP [&amp;lt;your MongoDB host&amp;gt;]200 1863 482 0.089
127.0.0.1 [23/Aug/2018:03:28:18 +0000] TCP [&amp;lt;your MongoDB host&amp;gt;]200 2590 1248 0.095
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h4 id="understanding-what-happened">理解原理&lt;/h4>
&lt;p>在本节中，您使用通配符域名为您的 MongoDB 主机配置了 egress 流量。对于单个 MongoDB 主机使用通配符域名没有任何好处（可以指定确切的主机名），
而当集群中的应用程序需要访问多个匹配某个通配符域名的 MongoDB 主机时可能有用。
例如，如果应用程序需要访问 &lt;code>mongodb1.composedb.com&lt;/code>、&lt;code>mongodb2.composedb.com&lt;/code> 和 &lt;code>mongodb3.composedb.com&lt;/code> 时，
egress 流量可以使用针对泛域名 &lt;code>*.composedb.com&lt;/code> 的单个配置实现。&lt;/p>
&lt;p>当配置一个应用使用另一个主机名匹配本小节中的通配符域名的 MongoDB 实例时，不需要额外的 Istio 配置。
我将这留作一个练习，让读者自行验证。&lt;/p>
&lt;h4 id="cleanup-of-configuration-for-MongoDB-TLS-egress-traffic-to-arbitrary-wildcarded-domains">清理到任意通配符域名的 MongoDB TLS egress 流量的配置&lt;/h4>
&lt;ol>
&lt;li>&lt;p>删除针对 &lt;code>*.com&lt;/code> 的配置项：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry mongo
$ kubectl delete gateway istio-egressgateway-with-sni-proxy
$ kubectl delete virtualservice direct-mongo-through-egress-gateway
$ kubectl delete destinationrule mtls-for-egress-gateway
$ kubectl delete envoyfilter forward-downstream-sni egress-gateway-sni-verifier
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>删除 &lt;code>egressgateway-with-sni-proxy&lt;/code> &lt;code>Deployment&lt;/code> 的配置项：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry sni-proxy
$ kubectl delete destinationrule disable-mtls-for-sni-proxy
$ kubectl delete -f ./istio-egressgateway-with-sni-proxy.yaml
$ kubectl delete configmap egress-sni-proxy-configmap -n istio-system
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>删除您创建的配置文件：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ rm ./istio-egressgateway-with-sni-proxy.yaml
$ rm ./nginx-sni-proxy.conf
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="cleanup">清理&lt;/h2>
&lt;ol>
&lt;li>&lt;p>删除&lt;code>bookinfo&lt;/code>用户：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | mongo --ssl --sslAllowInvalidCertificates $MONGODB_HOST:$MONGODB_PORT -u admin -p $MONGO_ADMIN_PASSWORD --authenticationDatabase admin
use test
db.dropUser(&amp;#34;bookinfo&amp;#34;);
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>删除 &lt;code>ratings&lt;/code> 集合：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | mongo --ssl --sslAllowInvalidCertificates $MONGODB_HOST:$MONGODB_PORT -u admin -p $MONGO_ADMIN_PASSWORD --authenticationDatabase admin
use test
db.ratings.drop();
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>取消您使用的环境变量：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ unset MONGO_ADMIN_PASSWORD BOOKINFO_PASSWORD MONGODB_HOST MONGODB_PORT MONGODB_IP
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>删除 virtual services：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-ratings-db.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete -f @samples/bookinfo/networking/virtual-service-ratings-db.yaml@
Deleted config: virtual-service/default/reviews
Deleted config: virtual-service/default/ratings
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>删除 &lt;code>ratings v2-mongodb&lt;/code> deployment：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete -f @samples/bookinfo/platform/kube/bookinfo-ratings-v2.yaml@
deployment &amp;#34;ratings-v2&amp;#34; deleted
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;h2 id="conclusion">总结&lt;/h2>
&lt;p>在这篇博文中，我演示了 MongoDB egress 流量控制的各种选项。您可以在 TCP 或 TLS 层面上控制 MongoDB egress 流量。
根据您的组织的安全需求，在 TCP 和 TLS 场景下您都可以将流量从 sidecar 代理定向到外部 MongoDB 主机
，或者通过一个 egress gateway 进行转发。在后面一种场景中，您还可以决定是否禁用 sidecar 代理到 egress gateway 的双向 TLS 认证。
如果您想要通过指定类似 &lt;code>*.com&lt;/code> 的通配符域名来从 TLS 层面控制 MongoDB 的 egress 流量，并且通过 egress gateway 定向流量时，
您必须部署一个使用 SNI 代理的自定义 egress gateway。&lt;/p>
&lt;p>请注意，本博客文章中描述的 MongoDB 配置和注意事项与 TCP/TLS 之上的其他非 HTTP 协议相同。&lt;/p></description><pubDate>Fri, 16 Nov 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/egress-mongo/</link><author>Vadim Eisenberg</author><guid isPermaLink="true">/v1.8/zh/blog/2018/egress-mongo/</guid><category>traffic-management</category><category>egress</category><category>tcp</category><category>mongo</category></item><item><title>Istio 在 Twitch 上全天直播</title><description>
&lt;p>为了庆祝 Istio 1.0 版本的发布并向更广泛的受众推广该软件，8 月 17 日 Istio 社区在 Twitch 举办了一天的实况直播。&lt;/p>
&lt;h2 id="what-is-twitch">Twitch 是什么？&lt;/h2>
&lt;p>&lt;a href="https://twitch.tv/">Twitch&lt;/a> 是一个流行的视频游戏直播流媒体平台，最近也看到了大量的编码内容出现。IBM 的倡导者一直在那里进行实况编码和演示，这是很有趣的事情。虽然大多数都是和游戏有关的内容，但是在网站上与编程相关的分享和观看的&lt;a href="https://www.twitch.tv/communities/programming">社区&lt;/a>在持续增长中。&lt;/p>
&lt;h2 id="what-does-this-have-to-do-with-Istio">它用 Istio 做了什么？&lt;/h2>
&lt;p>Istio 在平台上发布的全天的内容，希望可以给观众讲解如何将深度技术内容、初级内容和业务线内容做良好融合。我们有开发人员、用户和布道者来分享示例和故事。期待现场编码，QA 和一些惊喜。我们有来自 IBM、Google、Datadog、Pivotal 和更多的明星嘉宾。&lt;/p>
&lt;h2 id="recordings">如何观看&lt;/h2>
&lt;p>很简单！只要在 8 月 17 日上午 10 点导航到&lt;a href="https://twitch.tv/ibmcode">这里&lt;/a>。&lt;/p>
&lt;h2 id="schedule">安排&lt;/h2>
&lt;p>任何时候都是 &lt;code>PDT&lt;/code>.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>时间&lt;/th>
&lt;th>演讲者&lt;/th>
&lt;th>从属关系&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>10:00 - 10:30&lt;/td>
&lt;td>&lt;code>Spencer Krum + Lisa-Marie Namphy&lt;/code>&lt;/td>
&lt;td>&lt;code>IBM / Portworx&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10:30 - 11:00&lt;/td>
&lt;td>&lt;code>Lin Sun / Spencer Krum / Sven Mawson&lt;/code>&lt;/td>
&lt;td>&lt;code>IBM / Google&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11:00 - 11:10&lt;/td>
&lt;td>&lt;code>Lin Sun / Spencer Krum&lt;/code>&lt;/td>
&lt;td>&lt;code>IBM&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11:10 - 11:30&lt;/td>
&lt;td>&lt;code>Jason Yee / Ilan Rabinovich&lt;/code>&lt;/td>
&lt;td>&lt;code>Datadog&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11:30 - 11:50&lt;/td>
&lt;td>&lt;code>April Nassl&lt;/code>&lt;/td>
&lt;td>&lt;code>Google&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11:50 - 12:10&lt;/td>
&lt;td>&lt;code>Spike Curtis&lt;/code>&lt;/td>
&lt;td>&lt;code>Tigera&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12:10 - 12:30&lt;/td>
&lt;td>&lt;code>Shannon Coen&lt;/code>&lt;/td>
&lt;td>&lt;code>Pivotal&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12:30 - 1:00&lt;/td>
&lt;td>&lt;code>Matt Klein&lt;/code>&lt;/td>
&lt;td>&lt;code>Lyft&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1:00 - 1:20&lt;/td>
&lt;td>&lt;code>Zach Jory&lt;/code>&lt;/td>
&lt;td>&lt;code>F5/Aspen Mesh&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1:20 - 1:40&lt;/td>
&lt;td>&lt;code>Dan Ciruli&lt;/code>&lt;/td>
&lt;td>&lt;code>Google&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1:40 - 2:00&lt;/td>
&lt;td>&lt;code>Isaiah Snell-Feikema&lt;/code> / &lt;code>Greg Hanson&lt;/code>&lt;/td>
&lt;td>&lt;code>IBM&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2:00 - 2:20&lt;/td>
&lt;td>&lt;code>Zach Butcher&lt;/code>&lt;/td>
&lt;td>&lt;code>Tetrate&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2:20 - 2:40&lt;/td>
&lt;td>&lt;code>Ray Hudaihed&lt;/code>&lt;/td>
&lt;td>&lt;code>American Airlines&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2:40 - 3:00&lt;/td>
&lt;td>&lt;code>Christian Posta&lt;/code>&lt;/td>
&lt;td>&lt;code>Red Hat&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3:00 - 3:20&lt;/td>
&lt;td>&lt;code>Google/IBM China&lt;/code>&lt;/td>
&lt;td>&lt;code>Google / IBM&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3:20 - 3:40&lt;/td>
&lt;td>&lt;code>Colby Dyess&lt;/code>&lt;/td>
&lt;td>&lt;code>Tuffin&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3:40 - 4:00&lt;/td>
&lt;td>&lt;code>Rohit Agarwalla&lt;/code>&lt;/td>
&lt;td>&lt;code>Cisco&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description><pubDate>Fri, 03 Aug 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/istio-twitch-stream/</link><author>Spencer Krum, IBM</author><guid isPermaLink="true">/v1.8/zh/blog/2018/istio-twitch-stream/</guid></item><item><title>Istio 是惠普 FitStation 平台的改变者</title><description>&lt;p>惠普的 FitStation 团队坚信，未来的 Kubernetes、BPF 和服务网络是云基础设施的下一个标准。
我们也很高兴看到 Istio 即将推出其官方的 Istio 1.0 版本 - 这要归功于 2017 年 5 月从 Google、IBM 和 Lyft 开始的联合合作。&lt;/p>
&lt;p>在 FitStation 大规模和渐进式云平台的开发过程中，Istio 、Cilium 和 Kubernetes 的技术提供了大量机会，使我们的系统更加健壮和易于扩展。
Istio 在创建可靠和动态的网络通信方面改变了游戏规则。&lt;/p>
&lt;p>&lt;a href="http://www.fitstation.com">由惠普提供支持的 FitStation&lt;/a> 是一个技术平台，可捕获 3D 生物识别数据，设计个性化鞋类，
完美贴合个人足部尺寸和形状以及步态轮廓。它使用 3D 扫描，压力感应，3D 打印和可变密度注塑成型来制造独特的鞋类。
Brooks、Steitz Secura 或 Superfeet 等鞋类品牌正在连接 FitStation，以打造下一代高性能运动鞋，专业鞋和医用鞋。&lt;/p>
&lt;p>FitStation 建立在对用户生物识别数据的最终安全性和隐私承诺的基础上。Istio 是我们在云中实现数据传输的基石。
通过在基础架构级别管理这些方面，我们专注于解决业务问题，而不是花时间在安全服务通信的单独实现上。
使用 Istio 可以大大降低维护大量库和服务的复杂性，从而提供安全的通信服务。&lt;/p>
&lt;p>作为使用 Istio 1.0 的额外好处，我们获得了网络可见性，指标和开箱即用的追踪。这极大地改善了我们开发和 DevOps 团队的的决策和响应质量
。团队深入了解包括新应用程序和传统应用程序在内的整个平台的网络通信。Cilium 与 Envoy 的整合，
让 Istio 服务网格网络通信能力的性能取得了显著提升，同时还提供了内核驱动的细粒度 L7 网络安全层。这归功于 Cilium 为 Istio 提供的 BPF 功能。
我们认为未来将推动 Linux 的内核安全。&lt;/p>
&lt;p>跟随 Istio 的成长一直非常令人兴奋。我们已经能够看到不同开发版本的性能和稳定性的明显改进。
版本 0.7 和 0.8 之间的改进使我们的团队对 1.0 版本感到满意，我们可以说 Istio 现在已经准备好用于实际生产。&lt;/p>
&lt;p>我们期待着 Istio、Envoy、Cilium 和 CNCF 充满希望的路线图。&lt;/p></description><pubDate>Tue, 31 Jul 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/hp/</link><author>Steven Ceuppens, Chief Software Architect @ HP FitStation, Open Source Advocate &amp; Contributor</author><guid isPermaLink="true">/v1.8/zh/blog/2018/hp/</guid></item><item><title>使用 AppSwitch 精简 Istio 层次</title><description>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">计算机科学中的所有问题，都可以用另一个层来解决，除了层数太多的问题。—— David Wheeler&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>Sidecar proxy 模式成就了很多奇迹。Sidecar 身处微服务的数据路径之中，能够精确的了解到应用程序的意图。它在应用程序级别而非网络层级别对流量进行监控和协议的检测，从而实现了深度的可见性、访问控制以及流量管理能力。&lt;/p>
&lt;p>如果我们仔细观察，在执行应用流量的高级分析之前，数据必须通过许多中间层。这些层中的大部分都是基础设施的一部分，是数据传输的管道。这样一来，就增加了数据通信的延迟，也提高了整个系统的复杂性。&lt;/p>
&lt;p>多年以来，在网络数据路径层内实现积极的细粒度优化方面，已经有了很多集体努力。每次迭代可能都节省了几个毫秒。但这些层本身的必要性却无人质疑。&lt;/p>
&lt;h2 id="do-not-optimize-layers-remove-them">优化层还是删除层&lt;/h2>
&lt;p>在我看来，在对某些东西进行优化之前，应该先行考虑的是这个方面的需求是否可以取消。我最初的操作系统级虚拟化工作目标(broken link: &lt;code>https://apporbit.com/a-brief-history-of-containers-from-reality-to-hype/&lt;/code>)，就是移除虚拟机(broken link: &lt;code>https://apporbit.com/a-brief-history-of-containers-from-reality-to-hype/&lt;/code>)，用 Linux 容器直接在主机操作系统上运行应用，从而免除中间层的困扰。很长一段时间里，业界都在努力的对虚拟机进行优化，这是一场错误的战斗，真正应该做的是删除附加层。&lt;/p>
&lt;p>在微服务以及网络的连接方面，历史再次重演。网络已经经历了物理服务器十年前所经历的变化。新引进层和结构正被深入集成到了协议栈甚至是晶片之中，却没有人认真考虑替代的可能。也许移除这些附加层才是更好的办法。&lt;/p>
&lt;p>这个问题我已经思考了一段时间，我相信网络栈应该可以借鉴容器的做法，能够从基础上简化应用端点跨越复杂中间层进行连接的过程。我从容器的原始工作中总结的原则，也被应用到了创建 &lt;a href="http://appswitch.io">AppSwitch&lt;/a> 的过程之中。容器所提供的接口可以直接被应用拿来消费，AppSwitch 会直接插入到应用程序所用的定义良好的网络 API 之中，并跳过所有中间层，直接将应用程序的客户端连接到适当的服务器上。这才是网络的应有之意。&lt;/p>
&lt;p>在详细说明 AppSwitch 如何从 Istio 栈中清理无用层次之前，首先介绍一下产品架构。更多内容请移步浏览&lt;a href="https://appswitch.readthedocs.io/en/latest/">产品文档页面&lt;/a>。&lt;/p>
&lt;h2 id="appswitch">AppSwitch&lt;/h2>
&lt;p>和容器运行时相比，AppSwitch 由客户端和一个守护进程组成，二者通过 HTTP 协议的 REST API 进行通信。客户端和守护进程构建为一个自包含的二进制文件 &lt;code>ax&lt;/code>。客户端透明的注入 s 应用程序，并追踪网络相关的系统调用，随后通知守护进程。例如一个应用进行了 &lt;code>connect(2)&lt;/code> 系统调用，目标是一个 Kubernetes 服务的 IP。AppSwitch 客户端拦截这一调用并令其失效，然后把这一事件及其参数和上下文环境告知守护进程。守护进程会处理系统调用，例如代表应用程序直接连接到上游服务器的 Pod IP。&lt;/p>
&lt;p>值得注意的一点是，AppSwitch 的客户端和服务器之间不做任何数据转发。它们中间会通过 Unix socket 交换文件描述符，从而避免数据拷贝。另外客户端也不是独立进程，而是运行在应用本身的上下文之中的，因此应用和 AppSwitch 之间也不存在数据拷贝的操作。&lt;/p>
&lt;h2 id="Delayering-the-stack">删减堆栈层&lt;/h2>
&lt;p>现在我们大概知道了 AppSwitch 的功能，接下来看看它从标准服务网格中优化掉的层。&lt;/p>
&lt;h3 id="network-devirtualization">网络的去虚拟化&lt;/h3>
&lt;p>Kubernetes 为运行其上的微服务应用提供了简单的设计优良的网络结构。然而为了支持这些设计，也为下层网络强加了特定的&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/networking/">需求&lt;/a>。要符合这些需求并不简单。通常会通过另加一层的方式来满足要求。典型方案就是在下层网络和 Kubernetes 之间加入叠加层。应用产生的流量会在源头进行封包，在目的地进行解包，这一过程消耗的不仅是网络资源，还包括 CPU。&lt;/p>
&lt;p>AppSwitch 会通过和平台之间的接触，来决定应用程序的可见范围。它会为应用程序提供一个关于下层网络的虚拟视图，这一视图类似于叠加层，但是不会在数据路径中引入额外的处理工作。和容器的情况类似，容器内部看起来也像是一个虚拟机，但是其基础实现不会干扰低级中断之类的高发事件的控制过程。&lt;/p>
&lt;p>AppSwitch 能注入到标准的 Kubernetes 清单文件之中（和 Istio 注入类似），这样应用的网络就直接被 AppSwitch 控制，跳过任何的网络叠加过程。稍后介绍更多细节。&lt;/p>
&lt;h3 id="artifacts-of-container-networking">容器网络的组件&lt;/h3>
&lt;p>将网络从主机扩展到容器是一个&lt;a href="https://kubernetes.io/blog/2016/01/why-kubernetes-doesnt-use-libnetwork/">巨大挑战&lt;/a>。新的网络层应运而生。容器中的进程只是主机上的一个进程。然而应用所期待的网络抽象和容器网络命名空间之间存在一个&lt;a href="http://appswitch.io/blog/kubernetes_istio_and_network_function_devirtualization_with_appswitch/">错位&lt;/a>，进程无法直接访问主机网络。应用程序眼里的网络是 Socket 或者 Session，而网络命名空间暴露的是设备抽象。一旦进入网络命名空间，进程会失去所有连接。为此发明了 &lt;code>veth-pair&lt;/code> 之类的工具用来弥合这一鸿沟。数据现在必须从主机接口进入虚拟交换机，然后通过 &lt;code>veth-pair&lt;/code> 才能进入容器网络空间里面的虚拟网络接口。&lt;/p>
&lt;p>AppSwitch 能够有效的移除连接两端的虚拟交换机和 &lt;code>veth-pair&lt;/code> 层。运行在主机上的守护进程所用的主机网络既然已经就绪，就无需再使用网桥方式把主机网络桥接到容器了。主机上创建的 Socket 文件描述符被传递给运行在 Pod 网络命名空间中的应用程序。应用收到 FD 之后，控制路径的所有工作都已就绪，就可以使用 FD 进行实际 IO 了。&lt;/p>
&lt;h3 id="skip-TCP-IP-for-colocated-endpoints">跳过共生端点的 TCP/IP&lt;/h3>
&lt;p>TCP/IP 几乎是所有通信过程的媒介。如果恰好应用端点处于同一主机，还有必要继续使用 TCP/IP 么？毕竟 TCP/IP 会完成很多工作，并且非常复杂。Unix Socket 是为主机内通信设计的，AppSwitch 可以透明的将共生端点之间的通信切换到 Unix Socket 上。&lt;/p>
&lt;p>应用所监听的每个 Socket，AppSwitch 都会管理两个监听 Socket，一个对应 TCP，一个对应 Unix。当客户端尝试连接到的服务器恰好在同一主机，AppSwitch 守护进程就会选择连接到服务器的 Unix 监听 Socket 上。连接两端的 Unix Socket 被传递给相应的应用程序之中。返回完成的连接 FD 之后，应用会把它当做简单的字节管道。协议真的不重要。有个应用偶尔会做一些协议相关的调用，例如 &lt;code>getsockname(2)&lt;/code>，AppSwitch 会自行处理。它会提供一致的响应，保证程序持续运行。&lt;/p>
&lt;h3 id="data-pushing-proxy">数据推送代理&lt;/h3>
&lt;p>我们一直在讨论移除层的问题，再回头看看代理层自身的需求。有时候代理服务器可能退化成为普通的数据推送装置：&lt;/p>
&lt;ul>
&lt;li>可能不需要协议解码。&lt;/li>
&lt;li>协议可能不被代理支持。&lt;/li>
&lt;li>通信过程是加密的，代理无法访问其中的 Header。&lt;/li>
&lt;li>应用（Redis、Memcached 等）对延迟非常敏感，无法忍受中间代理服务器的花销。&lt;/li>
&lt;/ul>
&lt;p>这些情况下，代理服务器和低层的管道层并无区别。实际上，代理无法对这种情况作出合适的优化，这种延迟可能会更高。&lt;/p>
&lt;p>举例说明，看看下图的应用。其中包含了一个 Python 应用以及一组 Memcached。根据连接时间进行路由，选择了一个 Memcached 作为上游服务器。速度是这里的首要考量。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:38.63965267727931%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/delayering-istio/memcached.png" title="延迟敏感的应用场景">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/delayering-istio/memcached.png" alt="无代理的数据路径" />
&lt;/a>
&lt;/div>
&lt;figcaption>延迟敏感的应用场景&lt;/figcaption>
&lt;/figure>
&lt;p>浏览图中的数据流，Python 应用发起了到 Memcached IP 的连接。该连接被重定向到客户端的 Sidecar。Sidecar 把连接路由到一个 Memcached 服务器，并在两个 Socket 之间复制数据——一端是应用，一端是 Memcached。同样的事情也发生在服务端的 Sidecar 和 Memcached 之间。这一场景之下，代理服务器的角色只是无聊的在两个 Socket 之间传送字节流，同时还给端到端连接造成了大量延迟。&lt;/p>
&lt;p>想象一下，如果应用跳过两个代理，直接连接到 Memcached。数据会在应用和 Memcached 服务之间直接流动。AppSwitch 在 Python 应用发起 &lt;code>connect(2)&lt;/code> 系统调用时会透明地对系统调用的目标地址进行调整。&lt;/p>
&lt;h3 id="proxyless-protocol-decoding">无代理的协议解码&lt;/h3>
&lt;p>这一节要谈的事情有点奇怪。在前面我们看到，在无需了解流量内容的情况下，可以跳过代理服务器。但是其它场景呢？也是可以的。&lt;/p>
&lt;p>在典型的微服务通信场景中，Header 中会有很多有用的信息。Header 之后会是信息本体或者负载，这些构成通信的主体。这里代理服务器再一次退行成为数据推送器。AppSwitch 为这些用例提供了一个花招，用于跳过代理服务器。&lt;/p>
&lt;p>虽说 AppSwitch 并非代理，它会对应用端点之间的连接进行仲裁，还能访问对应 Socket 的文件描述符。通常 AppSwitch 简单的把这些 FD 传给应用。但是它也可以使用 &lt;code>recvfrom(2)&lt;/code> 系统调用的 &lt;code>MSG_PEEK&lt;/code> 选项查看连接上收到的初始消息。这样 AppSwitch 就能在不从 Socket 缓冲区中取出信息的情况下获取流量的内容。当 AppSwitch 将 FD 发给应用并退出数据路径之后，应用程序才会对连接进行真正的读取。AppSwitch 使用这一技术，对应用级的流量进行深层分析，在不进入数据路径的前提下，实现下面将要谈到的复杂网络功能。&lt;/p>
&lt;h3 id="zero-cost-load-balancer-firewall-and-network-analyzer">零损耗的负载均衡器、防火墙和网络分析器&lt;/h3>
&lt;p>负载均衡器和防火墙这样的典型网络功能，通常的实现方式都是引入一个中间层，介入到数据/包之中。Kubernetes 的负载均衡器（&lt;code>kube-proxy&lt;/code>）实现利用 iptables 完成对数据包流的探测，Istio 也在代理层中实现了同样的功能。但是如果目标只是根据策略来对连接进行重定向或者丢弃，那么在整个连接过程中都介入到数据通路上是不必要的。AppSwitch 能够更有效的处理这些任务，只要简单的在 API 层面处理控制路径即可。AppSwitch 和应用紧密结合，因此还能够获取更多的应用信息，例如堆栈动态和堆利用情况、服务就绪时间以及活动连接属性等，这些信息可以为监控和分析提供更大发的操作空间。&lt;/p>
&lt;p>更进一步，AppSwitch 还能够利用从 Socket 缓冲区获取的协议数据，完成七层负载均衡和防火墙功能。它能够利用从 Pilot 获取的策略信息，合成协议数据和各种其它信号，从而实现高效的路由和访问控制能力。实际上，无需对应用程序自身或配置做出任何变动，AppSwitch 也可以“诱导”应用连接到正确的后端服务器。看起来好像应用程序本身就具备了策略和流量管理能力。&lt;/p>
&lt;p>实际上还存在一种可能的黑魔法就是，无需进入数据路径，也能够对应用的数据流进行修改，后面我会专门撰文描述这一功能。目前如果有对应用协议流量进行修改的需要，AppSwitch 当前的实现是使用一个代理，AppSwitch 使用一种高度优化的机制来完成代理任务，下一节将继续说明。&lt;/p>
&lt;h3 id="traffic-redirection">流量重定向&lt;/h3>
&lt;p>Sidecar 代理要获知应用的协议流量，首先需要接入连接。利用包过滤层改写包，让数据包进入对应的 Sidecar，从而完成对应用程序进入和发出连接的重定向任务。要实现重定向规则，就意味着要编写大量规则，这是很繁琐的工作。Sidecar 捕获的目标子网发生变化时，规则的应用和更新也是很昂贵的操作。&lt;/p>
&lt;p>虽说 Linux 社区正在解决一些性能问题，但是还有特权相关的问题：不论何时策略发生变化，iptables 的规则都要随之更新。当前架构下，所有特权操作都是在初始化容器中执行，初始化容器只会在应用启动时执行一次，然后这一特权就会被删除；更新 iptables 规则需要 root 权限，所以如果不重新启动应用，则无法再次执行更新。&lt;/p>
&lt;p>AppSwitch 提供了无需 root 特权就能重定向应用连接的方法。这样一个无特权应用也能够连接任何主机。应用程序的所有者无需额外权限，就可以修改应用的 &lt;code>connect(2)&lt;/code> 调用时的主机地址。&lt;/p>
&lt;h4 id="socket-delegation">Socket 委托&lt;/h4>
&lt;p>接下来看看 AppSwitch 如何在不使用 iptables 的情况下进行连接重定向。想象一下，应用程序能够以某种方式主动传递它用于与 Sidecar 通信的 Socket 文件描述符的话，就不需要 iptables 了。AppSwitch 提供了一种称为 &lt;strong>Socket 委托&lt;/strong>的机制用于完成这一任务。这个功能让 Sidecar 在不更改应用程序的情况下，透明的访问应用程序用于通信的 Socket 文件描述符的副本。&lt;/p>
&lt;p>举个例子，在我们的 Python 示例应用中用于完成这一目标的几个步骤。&lt;/p>
&lt;ol>
&lt;li>应用初始化一个到 memcached 服务 IP 的连接请求。&lt;/li>
&lt;li>客户端发出的连接请求被转发给守护进程。&lt;/li>
&lt;li>守护进程创建一对预连接的 Unix socket（用 &lt;code>socketpair(2)&lt;/code> 系统调用）。&lt;/li>
&lt;li>发送 Socket 对中的一端给应用，应用会用这个 FD 进行读写。它还要确保应用始终视其为合法 Socket，以便于侵入所有对连接属性的查询。&lt;/li>
&lt;li>另外一端会通过一个不同的用于开放守护进程 API 的 Unix Socket 发送给 Sidecar。原始目的之类的信息也会由相同的接口进行传输。&lt;/li>
&lt;/ol>
&lt;figure style="width:50%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:22.442748091603054%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/delayering-istio/socket-delegation.png" title="基于 Socket 委托的连接重定向">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/delayering-istio/socket-delegation.png" alt="Socket 委托协议" />
&lt;/a>
&lt;/div>
&lt;figcaption>基于 Socket 委托的连接重定向&lt;/figcaption>
&lt;/figure>
&lt;p>应用和 Sidecar 连接之后，接下来的事情就很普通了。Sidecar 初始化一个到上游服务器的连接，并在从守护进程接收到的 Socket 和连接到上游服务器的 Socket 之间充当数据代理。这里的主要区别在于，Sidecar 得到的连接不是通过 &lt;code>accept(2)&lt;/code> 系统调用而来的，而是由守护进程的 Unix socket 来的。Sidecar 不再通过监听来自应用的 &lt;code>accept(2)&lt;/code> 通道，而是连接到 AppSwitch 守护进程的 REST 端点获取到的 Socket。&lt;/p>
&lt;p>为了完整叙述，再说说服务端发生的事情：&lt;/p>
&lt;ol>
&lt;li>应用接收到一个连接。&lt;/li>
&lt;li>AppSwitch 守护进程代应用程序接受这个连接。&lt;/li>
&lt;li>用 &lt;code>socketpair(2)&lt;/code> 系统调用创建一对预连接的 Unix Socket。&lt;/li>
&lt;li>Socket 对的一端通过 &lt;code>accept(2)&lt;/code> 系统调用返回给应用。&lt;/li>
&lt;li>Socket 对的另外一端会和守护进程以应用程序身份接收的 Socket 一起发送给 Sidecar。&lt;/li>
&lt;li>Sidecar 会解开这两个 Socket FD - 一个 Unix Socket FD 连接到应用，另一个 TCP Socket FD 连接到远程客户端。&lt;/li>
&lt;li>Sidecar 会读取守护进程提供的关于远程客户端的元数据，并执行正常操作。&lt;/li>
&lt;/ol>
&lt;h4 id="sidecar-aware-applications">Sidecar 感知的应用&lt;/h4>
&lt;p>Socket 委托功能对于知晓 Sidecar 存在并希望利用其能力的应用非常有用。应用程序可以通过相同的功能，把 Socket 传递给 Sidecar，委托其进行网络交互。一定程度上，AppSwitch 透明的把每个应用都转换成为了 Sidecar 感知应用。&lt;/p>
&lt;h2 id="how-does-it-all-come-together">如何整合这些功能？&lt;/h2>
&lt;p>退一步看，Istio 把应用程序的连接问题转嫁给 Sidecar，由 Sidecar 代表应用执行这些功能。AppSwitch 对这些服务网格进行了简化和优化，绕过了中间层，仅在确实需要时才调用代理。&lt;/p>
&lt;p>接下来讲讲 AppSwitch 可以如何初步集成到 Istio 之中。这不是设计文档，其中涉及到的可能的集成方式并没有经过完全的验证，一些细节还没能解决。这里的尝试是一个大致的将两个系统组合在一起的概要。在这一方案中 AppSwitch 作为一个类似垫片的东西出现在 Istio（应该是网格内应用——译者注）和真正的代理之间。它会作为一个快速通路，用绕过 Sidecar 代理的方式更高效的运作。对于需要使用代理的场合，也会通过移除层的方式缩短数据路径。这篇&lt;a href="http://appswitch.io/blog/kubernetes_istio_and_network_function_devirtualization_with_appswitch/">博客&lt;/a>中记录了更多这方面的细节。&lt;/p>
&lt;h3 id="appswitch-client-injection">AppSwitch 的客户端注入&lt;/h3>
&lt;p>和 Istio 的 sidecar-injector 类似，AppSwitch 提供了一个 &lt;code>ax-injector&lt;/code> 工具用来把 AppSwitch 客户端注入到标准的 Kubernetes 清单文件中。被注入的客户端会透明的监测应用，并把应用程序生成的控制路径上的网络 API 事件报告给 AppSwitch 守护进程。&lt;/p>
&lt;p>如果使用了 AppSwitch CNI 插件，还可能仅使用标准 Kubernetes 清单文件，无需注入。这种情况下，CNI 插件会在获得初始化回调时完成必要的注入任务。注入器有以下优点：&lt;/p>
&lt;ol>
&lt;li>可以在 GKE 这样的的严格受控的环境中工作。&lt;/li>
&lt;li>可以轻松的扩展到其它平台，例如 Mesos。&lt;/li>
&lt;li>同一个集群中可以同时运行标准应用以及启用 AppSwitch 支持的应用。&lt;/li>
&lt;/ol>
&lt;h3 id="appswitch-daemonset">AppSwitch &lt;code>DaemonSet&lt;/code>&lt;/h3>
&lt;p>AppSwitch 守护进程可以配置成 &lt;code>DaemonSet&lt;/code> 的运行方式，也可以作为直接注入应用程序清单的扩展。两种方式下都能够处理来自受支持应用的网络事件。&lt;/p>
&lt;h3 id="agent-for-policy-acquisition">用于获取策略的 Agent&lt;/h3>
&lt;p>这一组件用来将 Istio 的配置和策略转达给 AppSwitch。它实现了 xDS API，用来监听 Pilot，并调用对应的 AppSwitch API，来完成守护进程的程控。例如可以把 &lt;code>istioctl&lt;/code> 制定的负载均衡策略翻译成等效的 AppSwitch 能力。&lt;/p>
&lt;h3 id="platform-adapter-for-appswitch-auto-curated-service-registry">AppSwitch 服务注册表的平台适配器&lt;/h3>
&lt;p>AppSwitch 是存在于应用网络 API 的控制路径上的，因此也就具备了访问集群上服务拓扑的能力。AppSwitch 用服务注册表的形式公布信息，这个注册表会随着应用和服务的变化来自动的进行同步更新。Kubernetes 之外的平台适配器，例如 Eureka，会为 Istio 提供上游服务的详细信息。这虽然并非必要，但更有助于上面提到的 AppSwitch Agent 关联从 Pilot 接收到的端点信息。&lt;/p>
&lt;h3 id="proxy-integration-and-chaining">代理集成和链路&lt;/h3>
&lt;p>通过前面讨论过的 Socket 委托机制，能够将需要深度扫描和应用程序流量突变的连接传递给外部代理。这一过程使用了一个扩展的&lt;a href="https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt">代理服务器协议&lt;/a>。在简单的代理协议参数之外，加入了其它的元数据（包括从 Socket 缓冲区中获取的协议 Header）以及活跃的 Socket FD（代表应用的连接），转发给代理服务器。&lt;/p>
&lt;p>代理服务器取得元数据之后会进行处理决策。可能接受连接执行代理任务，也可能重定向给 AppSwitch 从而把连接送入快速通道，当然，还有可能直接丢弃连接。&lt;/p>
&lt;p>这个机制中有一点比较有趣，当代理从 AppSwitch 接收一个 Socket 的时候，它可以把这个委托转交给其它代理。实际上 AppSwitch 目前就是这么做的。它会用一个简单的内置代理来检查元数据，然后决定在内部处理连接，还是交出去给外部代理（Envoy）。这种机制可以扩展为插件链条，每个环节都
在其中查找特定签名，链条最后一节完成真正的代理工作。&lt;/p>
&lt;h2 id="it-is-not-just-about-performance">不仅仅是性能&lt;/h2>
&lt;p>从数据路径上移除中间层，不仅仅意味着性能的提高。性能提高是好事，但这仅仅是一个副产品。在 API 级别上，有更多的重要提升。&lt;/p>
&lt;h3 id="automatic-application-onboarding-and-policy-authoring">应用接入和策略生成的自动化&lt;/h3>
&lt;p>在微服务和服务网格之前，流量管理由负载均衡器完成，而访问控制则由防火墙完成。通过 IP 地址和 相对静态的 DNS 名称来鉴别应用。实际上这仍然是当前大多数环境的现状。这样的环境将从服务网格中受益匪浅。相对于新功能的开发来说，转型难度并不高，但是需要对整个基础设施进行重新思考和重新实现，这就需要投入了。目前多数策略和配置存在于负载均衡和防火墙中，现存的上下文需要有一个可扩展的路径来完成到服务网格模型的过渡。&lt;/p>
&lt;p>AppSwitch 能够大大简化接入流程。它可以把应用程序源环境投射到目标环境。如果传统应用的配置文件包含了硬编码的 IP 地址或者 DNS 名称，通常是难于迁移的。AppSwitch 可以协助捕获这些应用及其配置，在无需更改的情况下将其接入服务网格。&lt;/p>
&lt;h3 id="broader-application-and-protocol-support">更大范围的应用和协议支持&lt;/h3>
&lt;p>众所周知，HTTP 是的现代应用程序领域的主导协议，但是一旦涉及传统应用和环境，我们会遇到各种协议和传输方式。有时候连 UDP 的支持都是必要选项，例如 IBM 的 WebSphere 就广泛的依赖 UDP，多数多媒体应用也在使用 UDP 媒体流。当然，DNS 可能是最多使用的 UDP 应用。AppSwitch 在 API 级别为 UDP 提供了和 TCP 非常相似的支持，它检测到 UDP 连接之后，会透明的在快速路径中进行处理，而不是委托给代理。&lt;/p>
&lt;h3 id="client-IP-preservation-and-end-to-end-principle">保留客户端 IP 以及端到端原则&lt;/h3>
&lt;p>和保留源网络环境的机制类似，同样也可以保留服务器视角的客户端 IP 地址。在 Sidecar 的干扰下，连接通常是来自于 Sidecar 而非客户端，这样服务端应用看到的对端地址就被替换为代理服务器的 IP。AppSwitch 能让服务器看到客户端的真实地址，进行正确的记录，并且能够通过该地址进行准确的决策。另外 AppSwitch 保留了&lt;a href="https://en.wikipedia.org/wiki/End-to-end_principle">端到端原则&lt;/a>，中间层的存在会打破这一规则，并对真正的底层上下文造成混淆。&lt;/p>
&lt;h3 id="enhanced-application-signal-with-access-to-encrypted-headers">访问加密 Header 以增强应用信号&lt;/h3>
&lt;p>加密流量会阻止服务网格对流量的分析。API 级别的介入提供了一种可行的解决方法。AppSwitch 目前的实现能够在系统调用层面获得对应用网络 API 的访问。然而还有进一步的可能，在应用尚未加密或者已经加密的高级 API 边界上对应用程序施加影响。最终的视角上，应用生成明文数据，在发出之前的某个时间点进行加密。既然 AppSwitch 运行在应用的内存上下文中，因此就可能在更高层的数据中获取到明文。当然要完成这种功能，应用需要进行明确定义并且适合介入。同时这一功能还要访问应用二进制文件的符号表。目前 AppSwitch 还没有实现这一功能。&lt;/p>
&lt;h2 id="so-what-is-the-net">所以收益如何？&lt;/h2>
&lt;p>AppSwitch 从标准服务网格中移除了一组层次和操作。到底会对性能造成什么影响？&lt;/p>
&lt;p>我们做了一些初级的实验，来对前面提到的 AppSwitch 集成方式在提高性能方面的优化进行定性。这个实验运行在 GKE 上，对应的软件系统包括 Fortio 0.11.0、Istio 0.8.0 以及 AppSwitch 0.4.0-2。在无代理测试中，AppSwitch 守护进程以 &lt;code>DaemonSet&lt;/code> 的形式运行在 Kubernetes 集群中，并给 Fortio Pod 注入了 AppSwitch 客户端。这是仅有的两个步骤。这个测试的目的是衡量 100 并发连接的情况下，GRPC 的延迟情况。&lt;/p>
&lt;figure style="width:100%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:54.66034755134282%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/delayering-istio/perf.png" title="有无 AppSwitch 的对比。">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/delayering-istio/perf.png" alt="性能对比" />
&lt;/a>
&lt;/div>
&lt;figcaption>有无 AppSwitch 的对比。&lt;/figcaption>
&lt;/figure>
&lt;p>初步显示，p50 延迟在有无 AppSwitch 的情况下有高达 18 倍的差距（3.99 毫秒 vs 72.96 毫秒）。如果禁用了日志和 Mixer，差距会缩减为 8 倍。很明显，这一差距就是因为数据路径上的多余层造成的。客户端和服务器分属两台不同主机，因此 Unix Socket 优化在这一场景上没有触发，有理由相信，如果客户端和服务器恰好在同一节点上，延迟会进一步缩小。究其根本，在 Kubernetes 上各自 Pod 中运行的服务器和客户端是通过 GKE 网络上的 TCP Socket 直接连接的——没有隧道、网桥或者代理。&lt;/p>
&lt;h2 id="net-net">Net Net&lt;/h2>
&lt;p>从 David Wheeler 的引言开始说到，另起一层并非解决层次过多问题的方案。我的博客中经常提到，目前的网络栈已经层次太多，应该精简，但是 AppSwitch 是不是又加了一层？&lt;/p>
&lt;p>是的，AppSwitch 的确是另外一层。然而它的存在，能够移除更多层。这样一来，就把新的服务网格层和传统的网络层无缝的结合在一起。AppSwitch 不但抵消了 Sidecar 的成本，并且随着 Istio 1.0 的到来，还提供了一个从现有应用及其网络环境过度到服务网格世界的桥梁。&lt;/p>
&lt;p>可能 Wheeler 的引言可以换个说法：&lt;/p>
&lt;div>
&lt;aside class="callout quote">
&lt;div class="type">
&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-quote"/>&lt;/svg>
&lt;/div>
&lt;div class="content">计算机科学中的所有问题，都可以用另一个层来解决，&lt;strong>即使&lt;/strong>是层数太多的问题。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;h2 id="acknowledgements">感谢&lt;/h2>
&lt;p>感谢 Mandar Jog（Google）进行了多次沟通，讨论 AppSwitch 对 Istio 的存在价值。同时也要感谢对本文稿件进行 Review 的几位朋友（以字母排序）：&lt;/p>
&lt;ul>
&lt;li>Frank Budinsky (IBM)&lt;/li>
&lt;li>Lin Sun (IBM)&lt;/li>
&lt;li>Shriram Rajagopalan (VMware)&lt;/li>
&lt;/ul></description><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/delayering-istio/</link><author>Dinesh Subhraveti (AppOrbit and Columbia University)</author><guid isPermaLink="true">/v1.8/zh/blog/2018/delayering-istio/</guid><category>appswitch</category><category>performance</category></item><item><title>基于 Istio 授权的 Micro-Segmentation</title><description>
&lt;p>Micro-Segmentation 是一种安全技术，可在云部署中创建安全区域，并允许各组织将工作负载彼此隔离以单独保护它们。
&lt;a href="/v1.8/zh/docs/concepts/security/#authorization">Istio 的授权功能&lt;/a>也称为 Istio 基于角色的访问控制，为 Istio 网格中的服务提供
Micro-Segmentation。它的特点是：&lt;/p>
&lt;ul>
&lt;li>不同粒度级别的授权，包括命名空间级别、服务级别和方法级别。&lt;/li>
&lt;li>服务间和最终用户到服务授权。&lt;/li>
&lt;li>高性能，因为它在 Envoy 上本地执行。&lt;/li>
&lt;li>基于角色的语义，使其易于使用。&lt;/li>
&lt;li>灵活性高，因为它允许用户使用&lt;a href="/v1.8/zh/docs/reference/config/security/constraints-and-properties">组合属性&lt;/a>定义条件。&lt;/li>
&lt;/ul>
&lt;p>在这篇博客文章中，您将了解主要授权功能以及如何在不同情况下使用它们。&lt;/p>
&lt;h2 id="characteristics">特点&lt;/h2>
&lt;h3 id="RPC-level-authorization">RPC 级别授权&lt;/h3>
&lt;p>授权在各个 RPC 级别执行。具体来说，它控制“谁可以访问我的 &lt;code>bookstore&lt;/code> 服务”，或者“谁可以在我的 &lt;code>bookstore&lt;/code> 服务中访问
&lt;code>getBook&lt;/code> 方法 ”。它不是为了控制对于应用程序具体资源实例的访问而设计的，例如访问“存储桶 X ”或访问“第二层架上的第 3 本书”。目前这种应用特定的访问控制逻辑需要由应用程序本身处理。&lt;/p>
&lt;h3 id="role-based-access-control-with-conditions">具有条件的基于角色的访问控制&lt;/h3>
&lt;p>授权是&lt;a href="https://en.wikipedia.org/wiki/Role-based_access_control">基于角色的访问控制（RBAC）&lt;/a> 系统，
将此与&lt;a href="https://en.wikipedia.org/wiki/Attribute-based_access_control">基于属性的访问控制（ABAC）&lt;/a> 系统对比。
与 ABAC 相比，RBAC 具有以下优势：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>角色允许对属性进行分组。&lt;/strong> 角色是权限组，用于指定允许的操作在系统上执行。用户根据组织内的角色进行分组。
您可以针对不同的情况定义角色并重用他们。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>关于谁有权访问，更容易理解和推理。&lt;/strong> RBAC 概念自然地映射到业务概念。例如，数据库管理员可能拥有对数据库后端服务的所有访问权限，
而 Web 客户端可能只能查看数据库后端服务前端服务。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>它减少了无意的错误。&lt;/strong> RBAC 策略使得复杂的安全更改变得更加容易。你不会有在多个位置重复配置，以后在需要进行更改时忘记更新其中一些配置。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>另一方面，Istio 的授权系统不是传统的 RBAC 系统。它还允许用户使用定义&lt;strong>条件&lt;/strong>&lt;a href="/v1.8/zh/docs/reference/config/security/constraints-and-properties">属性组合&lt;/a>。这给了 Istio 表达复杂的访问控制策略的灵活性。实际上，&lt;strong>Istio 授权采用“RBAC + 条件”模型，具有 RBAC 系统的所有优点，并支持通常是 ABAC 系统提供的灵活性。&lt;/strong>你会在下面看到一些&lt;a href="#examples">示例&lt;/a>。&lt;/p>
&lt;h3 id="high-performance">高性能&lt;/h3>
&lt;p>由于其简单的语义，Istio 授权直接在 Envoy 本地执行。在运行时，授权决策完全在 Envoy 过滤器内部完成，不依赖于任何外部模块。
这允许 Istio 授权实现高性能和可用性。&lt;/p>
&lt;h3 id="work-with-without-primary-identities">使用/不使用主要标识&lt;/h3>
&lt;p>与任何其他 RBAC 系统一样，Istio 授权具有身份识别功能。在 Istio 授权政策中，有一个主要的
身份称为 &lt;code>user&lt;/code>，代表客户的主体。&lt;/p>
&lt;p>除主要标识外，您还可以自己定义标识。例如，您可以将客户端标识指定为“用户 &lt;code>Alice&lt;/code> 从 &lt;code>Bookstore&lt;/code> 前端服务调用”，在这种情况下，
你有一个调用服务（&lt;code>Bookstore frontend&lt;/code>）和最终用户（&lt;code>Alice&lt;/code>）的组合身份。&lt;/p>
&lt;p>要提高安全性，您应该启用&lt;a href="/v1.8/zh/docs/concepts/security/#authentication">认证功能&lt;/a>, 并在授权策略中使用经过验证的身份。但是，
使用授权不强迫一定要有身份验证。Istio 授权可以使用或不使用身份。如果您正在使用遗留系统，您可能没有网格的双向 TLS 或 JWT 身份验证
设置。在这种情况下，识别客户端的唯一方法是，例如，通过 IP。您仍然可以使用 Istio 授权来控制允许哪些 IP 地址或 IP 范围访问您的服务。&lt;/p>
&lt;h2 id="examples">示例&lt;/h2>
&lt;p>&lt;a href="/v1.8/zh/docs/tasks/security/authorization/authz-http">授权任务&lt;/a>通过 &lt;a href="/v1.8/zh/docs/examples/bookinfo">Bookinfo 应用&lt;/a>向您展示如何使用 Istio 的授权功能来控制命名空间级别
和服务级别的访问。在本节中，您将看到更多使用 Istio 授权进行权限细分的示例。&lt;/p>
&lt;h3 id="namespace-level-segmentation-via-rbac-conditions">通过 RBAC + 条件进行命名空间级别细分&lt;/h3>
&lt;p>假设你在 &lt;code>frontend&lt;/code> 和 &lt;code>backend&lt;/code> 命名空间中有服务。您想要允许所有在 &lt;code>frontend&lt;/code> 命名空间中的服务访问 &lt;code>backend&lt;/code> 命名空间中标记
为 &lt;code>external&lt;/code> 的所有服务。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRole
metadata:
name: external-api-caller
namespace: backend
spec:
rules:
- services: [&amp;#34;*&amp;#34;]
methods: [&amp;#34;*”]
constraints:
- key: &amp;#34;destination.labels[visibility]”
values: [&amp;#34;external&amp;#34;]
---
apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRoleBinding
metadata:
name: external-api-caller
namespace: backend
spec:
subjects:
- properties:
source.namespace: &amp;#34;frontend”
roleRef:
kind: ServiceRole
name: &amp;#34;external-api-caller&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>上面的 &lt;code>ServiceRole&lt;/code> 和 &lt;code>ServiceRoleBinding&lt;/code> 表示“允许&lt;em>谁&lt;/em> 在 &lt;em>什么条件&lt;/em> （RBAC + 条件）下执行&lt;em>什么&lt;/em> ”。其中：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>“谁”&lt;/strong> 是 &lt;code>frontend&lt;/code> 命名空间中的服务。&lt;/li>
&lt;li>&lt;strong>“什么”&lt;/strong> 是在 &lt;code>backend&lt;/code> 命名空间中调用服务。&lt;/li>
&lt;li>&lt;strong>“条件”&lt;/strong> 是具有值 &lt;code>external&lt;/code> 的目标服务的 &lt;code>visibility&lt;/code> 标签。&lt;/li>
&lt;/ul>
&lt;h3 id="service-method-level-isolation-with-without-primary-identities">具有/不具有主要身份的服务/方法级别隔离&lt;/h3>
&lt;p>这是演示另一个服务/方法级别的细粒度访问控制的示例。第一步是定义一个 &lt;code>book-reader&lt;/code> &lt;code>ServiceRole&lt;/code>，它允许对 &lt;code>bookstore&lt;/code> 服务中的 &lt;code>/books/*&lt;/code> 资源进行 READ 访问。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRole
metadata:
name: book-reader
namespace: default
spec:
rules:
- services: [&amp;#34;bookstore.default.svc.cluster.local&amp;#34;]
paths: [&amp;#34;/books/*”]
methods: [&amp;#34;GET”]
&lt;/code>&lt;/pre>
&lt;h4 id="using-authenticated-client-identities">使用经过身份验证的客户端身份&lt;/h4>
&lt;p>假设你想把这个 &lt;code>book-reader&lt;/code> 角色授予你的 &lt;code>bookstore-frontend&lt;/code> 服务。如果您已启用
您的网格的&lt;a href="/v1.8/zh/docs/concepts/security/#mutual-TLS-authentication">双向 TLS 身份验证&lt;/a>, 您可以使用服务帐户，以识别您的 &lt;code>bookstore-frontend&lt;/code> 服务。授予 &lt;code>book-reader&lt;/code> 角色到 &lt;code>bookstore-frontend&lt;/code> 服务可以通过创建一个 &lt;code>ServiceRoleBinding&lt;/code> 来完成，如下所示：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRoleBinding
metadata:
name: book-reader
namespace: default
spec:
subjects:
- user: &amp;#34;cluster.local/ns/default/sa/bookstore-frontend”
roleRef:
kind: ServiceRole
name: &amp;#34;book-reader&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>您可能希望通过添加“仅属于 &lt;code>qualified-reviewer&lt;/code> 组的用户的条件来进一步限制此操作允许阅读书籍“。&lt;code>qualified-reviewer&lt;/code> 组是经过身份验证的最终用户身份 &lt;a href="/v1.8/zh/docs/concepts/security/#authorization">JWT 身份验证&lt;/a>。在这种情况下，客户端服务标识（&lt;code>bookstore-frontend&lt;/code>）和最终用户身份（&lt;code>qualified-reviewer&lt;/code>）的组合将用于授权策略。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRoleBinding
metadata:
name: book-reader
namespace: default
spec:
subjects:
- user: &amp;#34;cluster.local/ns/default/sa/bookstore-frontend”
properties:
request.auth.claims[group]: &amp;#34;qualified-reviewer”
roleRef:
kind: ServiceRole
name: &amp;#34;book-reader&amp;#34;
&lt;/code>&lt;/pre>
&lt;h4 id="client-does-not-have-identity">无身份客户&lt;/h4>
&lt;p>强烈建议在授权策略中使用经过身份验证的身份以确保安全性。但是，如果你有一个如果遗留系统不支持身份验证，您可能没有经过身份验证的身份验证。即使没有经过身份验证的身份，您仍然可以使用 Istio 授权来保护您的服务。以下示例表明您可以在授权策略中指定允许的源 IP 范围。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;rbac.istio.io/v1alpha1&amp;#34;
kind: ServiceRoleBinding
metadata:
name: book-reader
namespace: default
spec:
subjects:
- properties:
source.ip: 10.20.0.0/9
roleRef:
kind: ServiceRole
name: &amp;#34;book-reader&amp;#34;
&lt;/code>&lt;/pre>
&lt;h2 id="summary">概要&lt;/h2>
&lt;p>Istio 在命名空间级别，服务级别和方法级别粒度上提供授权功能。它采用“ RBAC + 条件”模型，使其成为易于使用和理解的 RBAC 系统，同时提供 ABAC 系统级别的灵活性。由于 Istio 授权在 Envoy 上本地运行，它有很高的性能。Istio 授权既可以与 &lt;a href="/v1.8/zh/docs/concepts/security/#authentication">Istio 认证功能&lt;/a>一起提供最佳的安全性，也可以用于为没有身份验证的旧系统提供访问控制。&lt;/p></description><pubDate>Fri, 20 Jul 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/istio-authorization/</link><author>Limin Wang</author><guid isPermaLink="true">/v1.8/zh/blog/2018/istio-authorization/</guid><category>authorization</category><category>rbac</category><category>security</category></item><item><title>通过 Stackdriver 将日志导出到 BigQuery、GCS、Pub/Sub</title><description>
&lt;p>这篇文章展示了如何将 Istio 日志指向 &lt;a href="https://cloud.google.com/stackdriver/">&lt;code>Stackdriver&lt;/code>&lt;/a> 并将这些日志导出到各种配置的接收器，例如 &lt;a href="https://cloud.google.com/bigquery/">&lt;code>BigQuery&lt;/code>&lt;/a>、&lt;a href="https://cloud.google.com/storage/">&lt;code>Google Cloud Storage(GCS)&lt;/code>&lt;/a> 或 &lt;a href="https://cloud.google.com/pubsub/">&lt;code>Cloud Pub/Sub&lt;/code>&lt;/a>。在这篇文章的最后，可以从喜欢的地方（如 BigQuery、GCS 或 Cloud Pub/Sub）对 Istio 数据进行分析。&lt;/p>
&lt;p>&lt;a href="/v1.8/zh/docs/examples/bookinfo/">&lt;code>Bookinfo&lt;/code>&lt;/a> 示例应用程序在整个任务中用作示例应用程序。&lt;/p>
&lt;h2 id="before-you-begin">开始之前&lt;/h2>
&lt;p>在集群中 &lt;a href="/v1.8/zh/docs/setup/">&lt;code>安装 Istio&lt;/code>&lt;/a> 并部署应用程序。&lt;/p>
&lt;h2 id="configuring-Istio-to-export-logs">配置 Istio 导出日志&lt;/h2>
&lt;p>Istio 使用 &lt;code>logentry&lt;/code> &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/templates/logentry">&lt;code>模板&lt;/code>&lt;/a> 导出日志。这里指定了可用于分析的所有变量。它包含源服务、目标服务、&lt;code>auth&lt;/code> 指标（即将实现&amp;hellip;&amp;hellip;）等信息。以下是示意图：&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:75%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/export-logs-through-stackdriver/istio-analytics-using-stackdriver.png" title="导出日志到 Stackdriver 进行分析的图释">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/export-logs-through-stackdriver/istio-analytics-using-stackdriver.png" alt="导出日志到 Stackdriver 进行分析的图释" />
&lt;/a>
&lt;/div>
&lt;figcaption>导出日志到 Stackdriver 进行分析的图释&lt;/figcaption>
&lt;/figure>
&lt;p>Istio 支持将日志导出到 Stackdriver，而 Stackdriver 又可以配置为将日志导出到喜欢的接收器，如 BigQuery、Pub/Sub 或 GCS。请按照以下步骤设置喜欢的接收器，首先导出日志，然后在 Istio 中使用 Stackdriver。&lt;/p>
&lt;h3 id="setting-up-various-log-sinks">设置各种日志接收器&lt;/h3>
&lt;p>所有接收器的通用设置：&lt;/p>
&lt;ol>
&lt;li>为项目启用 &lt;a href="https://cloud.google.com/monitoring/api/enable-api">&lt;code>Stackdriver Monitoring API&lt;/code>&lt;/a> 。&lt;/li>
&lt;li>确保配置的接收器的 &lt;code>principalEmail&lt;/code> 具有对项目写入的权限和日志管理员角色的权限。&lt;/li>
&lt;li>确保已设置 &lt;code>GOOGLE_APPLICATION_CREDENTIALS&lt;/code> 环境变量。请按照 &lt;a href="https://cloud.google.com/docs/authentication/getting-started">&lt;code>此处&lt;/code>&lt;/a> 的说明进行设置。&lt;/li>
&lt;/ol>
&lt;h4 id="big-query">BigQuery&lt;/h4>
&lt;ol>
&lt;li>&lt;a href="https://cloud.google.com/bigquery/docs/datasets">&lt;code>创建 BigQuery 数据集&lt;/code>&lt;/a> 作为日志导出的目标。&lt;/li>
&lt;li>记录数据集的 ID。这里需要设置 Stackdriver 处理程序。它的格式为 &lt;code>bigquery.googleapis.com/projects/[PROJECT_ID]/datasets/[DATASET_ID]&lt;/code>&lt;/li>
&lt;li>给 &lt;a href="https://cloud.google.com/logging/docs/api/tasks/exporting-logs#writing_to_the_destination">&lt;code>接收器授权&lt;/code>&lt;/a>：cloud-logs@system.gserviceaccount.com。它具有 IAM 中的 BigQuery Data Editor 的角色。&lt;/li>
&lt;li>如果使用 &lt;a href="/v1.8/zh/docs/setup/platform-setup/gke/">&lt;code>Google Kubernetes Engine&lt;/code>&lt;/a>，请确保在集群上启用了 &lt;code>bigquery&lt;/code> &lt;a href="https://cloud.google.com/sdk/gcloud/reference/container/clusters/create">&lt;code>Scope&lt;/code>&lt;/a>。&lt;/li>
&lt;/ol>
&lt;h4 id="google-cloud-storage">Google Cloud Storage (GCS)&lt;/h4>
&lt;ol>
&lt;li>&lt;a href="https://cloud.google.com/storage/docs/creating-buckets">&lt;code>创建 GCS 存储桶&lt;/code>&lt;/a>，希望导出日志到 GCS 中。&lt;/li>
&lt;li>记录存储桶的 ID。这里需要配置 Stackdriver。它的形式为 &lt;code>storage.googleapis.com/[BUCKET_ID]&lt;/code>。&lt;/li>
&lt;li>给 &lt;a href="https://cloud.google.com/logging/docs/api/tasks/exporting-logs#writing_to_the_destination">&lt;code>接收器授权&lt;/code>&lt;/a>：&lt;code>cloud-logs @ system.gserviceaccount.com&lt;/code>。它具有 IAM 中的 Storage Object Creator 的角色。&lt;/li>
&lt;/ol>
&lt;h4 id="google-cloud-pub-sub">Google Cloud Pub/Sub&lt;/h4>
&lt;ol>
&lt;li>&lt;a href="https://cloud.google.com/pubsub/docs/admin">&lt;code>创建主题&lt;/code>&lt;/a>，希望导出日志到 Google Cloud Pub/Sub 中。&lt;/li>
&lt;li>记录主题的 ID。这里需要配置 Stackdriver。它的形式为&lt;code>pubsub.googleapis.com/projects/[PROJECT_ID]/topics/[TOPIC_ID]&lt;/code>。&lt;/li>
&lt;li>给 &lt;a href="https://cloud.google.com/logging/docs/api/tasks/exporting-logs#writing_to_the_destination">&lt;code>接收器授权&lt;/code>&lt;/a>：&lt;code>cloud-logs @ system.gserviceaccount.com&lt;/code>。它具有 IAM 中的 Pub/Sub Publisher 角色。&lt;/li>
&lt;li>如果使用 &lt;a href="/v1.8/zh/docs/setup/platform-setup/gke/">&lt;code>Google Kubernetes Engine&lt;/code>&lt;/a>，请确保在集群中启动了 &lt;code>pubsub&lt;/code> &lt;a href="https://cloud.google.com/sdk/gcloud/reference/container/clusters/create">&lt;code>Scope&lt;/code>&lt;/a>。&lt;/li>
&lt;/ol>
&lt;h3 id="setting-up-stack-driver">设置 Stackdriver&lt;/h3>
&lt;p>必须创建 Stackdriver 处理程序，将数据导出到 Stackdriver。Stackdriver 处理程序的配置在 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/stackdriver/">&lt;code>此处&lt;/code>&lt;/a> 描述。&lt;/p>
&lt;ol>
&lt;li>&lt;p>保存如下的 yaml 文件为 &lt;code>stackdriver.yaml&lt;/code> 。并替换 &lt;code>&amp;lt;project_id&amp;gt;,
&amp;lt;sink_id&amp;gt;, &amp;lt;sink_destination&amp;gt;, &amp;lt;log_filter&amp;gt;&lt;/code> 为相应的值。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: stackdriver
metadata:
name: handler
namespace: istio-system
spec:
# 设置 pushInterval 值。默认值是每分钟一次，不设置使用默认值。
# pushInterval: 1m
# 必须设置 Stacldriver 适配器 project_id 的值。
project_id: &amp;#34;&amp;lt;project_id&amp;gt;&amp;#34;
# apiCredentials 和 apiKey 必须设置之一；首选方法是`appCredentials`，它对应于 Google 应用程序默认凭据。
# 如果没有提供，我们使用默认应用凭据。
# appCredentials:
# apiKey:
# serviceAccountPath:
# 描述如何将 Istio 日志映射到 Stackdriver。
logInfo:
accesslog.logentry.istio-system:
payloadTemplate: &amp;#39;{{or (.sourceIp) &amp;#34;-&amp;#34;}} - {{or (.sourceUser) &amp;#34;-&amp;#34;}} [{{or (.timestamp.Format &amp;#34;02/Jan/2006:15:04:05 -0700&amp;#34;) &amp;#34;-&amp;#34;}}] &amp;#34;{{or (.method) &amp;#34;-&amp;#34;}} {{or (.url) &amp;#34;-&amp;#34;}} {{or (.protocol) &amp;#34;-&amp;#34;}}&amp;#34; {{or (.responseCode) &amp;#34;-&amp;#34;}} {{or (.responseSize) &amp;#34;-&amp;#34;}}&amp;#39;
httpMapping:
url: url
status: responseCode
requestSize: requestSize
responseSize: responseSize
latency: latency
localIp: sourceIp
remoteIp: destinationIp
method: method
userAgent: userAgent
referer: referer
labelNames:
- sourceIp
- destinationIp
- sourceService
- sourceUser
- sourceNamespace
- destinationIp
- destinationService
- destinationNamespace
- apiClaims
- apiKey
- protocol
- method
- url
- responseCode
- responseSize
- requestSize
- latency
- connectionMtls
- userAgent
- responseTimestamp
- receivedBytes
- sentBytes
- referer
sinkInfo:
id: &amp;#39;&amp;lt;sink_id&amp;gt;&amp;#39;
destination: &amp;#39;&amp;lt;sink_destination&amp;gt;&amp;#39;
filter: &amp;#39;&amp;lt;log_filter&amp;gt;&amp;#39;
---
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: stackdriver
namespace: istio-system
spec:
match: &amp;#34;true&amp;#34; # 缺省 match 为 true
actions:
- handler: handler.stackdriver
instances:
- accesslog.logentry
---
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建配置&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f stackdriver.yaml
stackdriver &amp;#34;handler&amp;#34; created
rule &amp;#34;stackdriver&amp;#34; created
logentry &amp;#34;stackdriverglobalmr&amp;#34; created
metric &amp;#34;stackdriverrequestcount&amp;#34; created
metric &amp;#34;stackdriverrequestduration&amp;#34; created
metric &amp;#34;stackdriverrequestsize&amp;#34; created
metric &amp;#34;stackdriverresponsesize&amp;#34; created
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>访问示例应用程序。
对于 &lt;code>Bookinfo&lt;/code> 示例，请使用浏览器访问 &lt;code>http://$GATEWAY_URL/productpage&lt;/code> 或发出以下命令：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ curl http://$GATEWAY_URL/productpage
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>验证日志是否正在通过 Stackdriver 流向配置的接收器。&lt;/p>&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>Stackdriver：导航到项目的 &lt;a href="https://pantheon.corp.google.com/logs/viewer">&lt;code>Stackdriver Logs Viewer&lt;/code>&lt;/a>，查看 “GKE Container” -&amp;gt; “Cluster Name” -&amp;gt; “Namespace Id”，查看 Istio 访问日志。&lt;/li>
&lt;li>BigQuery：导航到项目的 &lt;a href="https://bigquery.cloud.google.com/">&lt;code>BigQuery Interface&lt;/code>&lt;/a>，在接收器的数据集中找到一个前缀为 &lt;code>accesslog_logentry_istio&lt;/code> 的表。&lt;/li>
&lt;li>GCS：导航到项目的 &lt;a href="https://pantheon.corp.google.com/storage/browser/">&lt;code>Storage Brower&lt;/code>&lt;/a>，在接收器的桶中找到一个名为 &lt;code>accesslog.logentry.istio-system&lt;/code> 的桶。&lt;/li>
&lt;li>Pub/Sub：导航到项目的 &lt;a href="https://pantheon.corp.google.com/cloudpubsub/topicList">&lt;code>Pub/Sub 主题列表&lt;/code>&lt;/a>，在接收器的主题中找到 &lt;code>accesslog&lt;/code> 主题。&lt;/li>
&lt;/ul>
&lt;h2 id="understanding-what-happened">了解发生了什么&lt;/h2>
&lt;p>上面的 &lt;code>Stackdriver.yaml&lt;/code> 文件配置了 Istio 将访问日志发送到 Stackdriver，然后添加了一个接收器配置，将日志导出。具体如下：&lt;/p>
&lt;ol>
&lt;li>&lt;p>添加一个 &lt;code>stackdriver&lt;/code> 类型的处理程序：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: stackdriver
metadata:
name: handler
namespace: &amp;lt;your defined namespace&amp;gt;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>在 &lt;code>spec&lt;/code> 上增加 &lt;code>logInfo&lt;/code>&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >spec:
logInfo: accesslog.logentry.istio-system:
labelNames:
- sourceIp
- destinationIp
...
...
sinkInfo:
id: &amp;#39;&amp;lt;sink_id&amp;gt;&amp;#39;
destination: &amp;#39;&amp;lt;sink_destination&amp;gt;&amp;#39;
filter: &amp;#39;&amp;lt;log_filter&amp;gt;&amp;#39;
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>在上面的配置中，sinkInfo 包含有关日志导出到所需接收器的信息。有关如何填写不同接收器的更多信息，请参阅 &lt;a href="https://cloud.google.com/logging/docs/export/#sink-terms">&lt;code>此处&lt;/code>&lt;/a>。
 
1. 为 Stackdriver 添加规则&lt;/p>
&lt;pre>&lt;code>&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: stackdriver
namespace: istio-system spec:
match: &amp;#34;true&amp;#34; # 缺省 match 为 true
actions:
- handler: handler.stackdriver
instances:
- accesslog.logentry
&lt;/code>&lt;/pre>&lt;/code>&lt;/pre>
&lt;h2 id="cleanup">清理&lt;/h2>
&lt;ul>
&lt;li>&lt;p>删除新的 Stackdriver 配置：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete -f stackdriver.yaml
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>如果不打算任何后续任务，请参阅 &lt;a href="/v1.8/zh/docs/examples/bookinfo/#cleanup">&lt;code>Bookinfo cleanup&lt;/code>&lt;/a> 指令关闭应用程序。&lt;/p>&lt;/li>
&lt;/ul>
&lt;h2 id="availability-of-logs-in-export-sinks">日志导出的可用性&lt;/h2>
&lt;p>导出到 BigQuery 只需几分钟（可以认为是瞬间完成的），不过 GCS 要延迟 2 至 12 小时，而 Pub/Sub 则几乎没有延迟。&lt;/p></description><pubDate>Mon, 09 Jul 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/export-logs-through-stackdriver/</link><author>Nupur Garg and Douglas Reid</author><guid isPermaLink="true">/v1.8/zh/blog/2018/export-logs-through-stackdriver/</guid></item><item><title>HTTP Egress 流量监控和访问策略</title><description>
&lt;p>虽然 Istio 的主要关注点是管理服务网格内微服务之间的流量，但它也可以管理 ingress (从外部进入网格) 和 egress (从网格向外) 的流量。Istio 可以统一执行访问策略，并为网格内部、ingress 和 egress 流量聚合遥测数据。&lt;/p>
&lt;p>在这篇博客文章中，将向您展示如何使用 Istio 进行 HTTP Egress 流量监控和访问策略。&lt;/p>
&lt;h2 id="use-case">用例&lt;/h2>
&lt;p>考虑一个运行处理 &lt;em>cnn.com&lt;/em> 内容的应用程序的组织。应用程序被解耦为部署在 Istio 服务网格中的微服务。应用程序访问 &lt;em>cnn.com&lt;/em> 的各种话题页面：&lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a>，&lt;a href="https://edition.cnn.com/sport">edition.cnn.com/sport&lt;/a> 和 &lt;a href="https://edition.cnn.com/health">edition.cnn.com/health&lt;/a>。该组织&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination/">配置了访问 edition.cnn.com 的权限&lt;/a>，一切都正常运行。然而，在某一时刻，本组织决定移除政治话题。实际上，这意味着禁止访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> ，只允许访问 &lt;a href="https://edition.cnn.com/sport">edition.cnn.com/sport&lt;/a> 和 &lt;a href="https://edition.cnn.com/health">edition.cnn.com/health&lt;/a> 。该组织将根据具体情况，向个别应用程序和特定用户授予访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 的权限。&lt;/p>
&lt;p>为了实现这一目标，组织的运维人员监控对外部服务的访问，并分析 Istio 日志，以验证没有向 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 发送未经授权的请求。他们还配置了 Istio 来防止自动访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 。&lt;/p>
&lt;p>本组织决心防止对新策略的任何篡改，决定设置一些机制以防止恶意应用程序访问禁止的话题。&lt;/p>
&lt;h2 id="related-tasks-and-examples">相关工作和示例&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/">Control Egress 流量&lt;/a>任务演示了网格内的应用程序如何访问外部(Kubernetes 集群之外) HTTP 和 HTTPS 服务。&lt;/li>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/">配置 Egress 网关&lt;/a>示例描述了如何配置 Istio 来通过一个称为 &lt;em>出口网关&lt;/em> 的专用网关服务来引导出口流量。&lt;/li>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination/">带 TLS 发起的 Egress 网关&lt;/a>示例演示了如何允许应用程序向需要 HTTPS 的外部服务器发送 HTTP 请求，同时通过 Egress Gateway 引导流量。&lt;/li>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/observability/metrics/collecting-metrics/">收集指标&lt;/a>任务描述如何为网格中的服务配置指标。&lt;/li>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/observability/metrics/using-istio-dashboard/">Grafana 的可视化指标&lt;/a>描述了用于监控网格流量的 Istio 仪表板。&lt;/li>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/policy-enforcement/denial-and-list/">基本访问控制&lt;/a>任务显示如何控制对网格内服务的访问。&lt;/li>
&lt;li>&lt;a href="/v1.8/zh/docs/tasks/policy-enforcement/denial-and-list/">拒绝和白/黑名单&lt;/a>任务显示如何使用黑名单或白名单检查器配置访问策略。&lt;/li>
&lt;/ul>
&lt;p>与上面的遥测和安全任务相反，这篇博客文章描述了 Istio 的监控和访问策略，专门应用于 egress 流量。&lt;/p>
&lt;h2 id="before-you-begin">开始之前&lt;/h2>
&lt;p>按照&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination/">带 TLS 发起的 Egress 网关&lt;/a>中的步骤，&lt;strong>启用了双向 TLS 身份验证&lt;/strong>，而不需要&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination//#cleanup">清除&lt;/a>步骤。完成该示例后，您可以从安装了 &lt;code>curl&lt;/code> 的网格中容器访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a>。本文假设 &lt;code>SOURCE_POD&lt;/code> 环境变量包含源 pod 的名称，容器的名称为 &lt;code>sleep&lt;/code>。&lt;/p>
&lt;h2 id="configure-monitoring-and-access-policies">配置监控和访问策略&lt;/h2>
&lt;p>由于您希望以 &lt;em>安全方式&lt;/em> 完成您的任务，您应该通过 &lt;em>egress 网关&lt;/em> 引导流量，正如&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination/">带 TLS 发起的 Egress 网关&lt;/a>任务中所描述的那样。这里的 &lt;em>安全方式&lt;/em> 意味着您希望防止恶意应用程序绕过 Istio 监控和策略强制。&lt;/p>
&lt;p>根据我们的场景，组织执行了&lt;a href="#before-you-begin">开始之前&lt;/a>部分中的命令，启用 HTTP 流量到 &lt;em>edition.cnn.com&lt;/em> ，并将该流量配置为通过 egress 网关。egress 网关执行 TLS 发起到 &lt;em>edition.cnn.com&lt;/em> ，因此流量在网格中被加密。此时，组织已经准备好配置 Istio 来监控和应用 &lt;em>edition.cnn.com&lt;/em> 流量的访问策略。&lt;/p>
&lt;h3 id="logging">日志&lt;/h3>
&lt;p>配置 Istio 以记录对 &lt;em>*.cnn.com&lt;/em> 的访问。创建一个 &lt;code>logentry&lt;/code> 和两个 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/stdio/">stdio&lt;/a> &lt;code>handlers&lt;/code>，一个用于记录禁止访问(&lt;em>error&lt;/em> 日志级别)，另一个用于记录对 &lt;em>*.cnn.com&lt;/em> 的所有访问(&lt;em>info&lt;/em> 日志级别)。然后创建规则将 &lt;code>logentry&lt;/code> 实例定向到 &lt;code>handlers&lt;/code>。一个规则指导访问 &lt;em>*.cnn.com/politics&lt;/em> 为日志禁止访问处理程序, 另一个规则指导日志条目的处理程序，输出每个访问 &lt;em>*.cnn.com&lt;/em> 作为 &lt;em>info&lt;/em> 的日志级别。要了解 Istio &lt;code>logentries&lt;/code>、&lt;code>rules&lt;/code> 和 &lt;code>handlers&lt;/code>，请参见 &lt;a href="/v1.8/zh/blog/2017/adapter-model/">Istio 适配器模型&lt;/a>。下图显示了涉及的实体和它们之间的依赖关系：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:46.46700562636976%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-monitoring-access-control/egress-adapters-monitoring.svg" title="用于 egress 监视和访问策略的实例、规则和处理程序">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-monitoring-access-control/egress-adapters-monitoring.svg" alt="用于 egress 监视和访问策略的实例、规则和处理程序" />
&lt;/a>
&lt;/div>
&lt;figcaption>用于 egress 监视和访问策略的实例、规则和处理程序&lt;/figcaption>
&lt;/figure>
&lt;ol>
&lt;li>&lt;p>创建 &lt;code>logentry&lt;/code>、&lt;code>rules&lt;/code> 和 &lt;code>handlers&lt;/code>。注意您指定了 &lt;code>context.reporter.uid&lt;/code> 作为
&lt;code>kubernetes://istio-egressgateway&lt;/code> 在规则中只能从 egress 网关获取日志信息。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
# Log entry for egress access
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: logentry
metadata:
name: egress-access
namespace: istio-system
spec:
severity: &amp;#39;&amp;#34;info&amp;#34;&amp;#39;
timestamp: request.time
variables:
destination: request.host | &amp;#34;unknown&amp;#34;
path: request.path | &amp;#34;unknown&amp;#34;
responseCode: response.code | 0
responseSize: response.size | 0
reporterUID: context.reporter.uid | &amp;#34;unknown&amp;#34;
sourcePrincipal: source.principal | &amp;#34;unknown&amp;#34;
monitored_resource_type: &amp;#39;&amp;#34;UNSPECIFIED&amp;#34;&amp;#39;
---
# Handler for error egress access entries
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: stdio
metadata:
name: egress-error-logger
namespace: istio-system
spec:
severity_levels:
info: 2 # output log level as error
outputAsJson: true
---
# Rule to handle access to *.cnn.com/politics
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: handle-politics
namespace: istio-system
spec:
match: request.host.endsWith(&amp;#34;cnn.com&amp;#34;) &amp;amp;&amp;amp; request.path.startsWith(&amp;#34;/politics&amp;#34;) &amp;amp;&amp;amp; context.reporter.uid.startsWith(&amp;#34;kubernetes://istio-egressgateway&amp;#34;)
actions:
- handler: egress-error-logger.stdio
instances:
- egress-access.logentry
---
# Handler for info egress access entries
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: stdio
metadata:
name: egress-access-logger
namespace: istio-system
spec:
severity_levels:
info: 0 # output log level as info
outputAsJson: true
---
# Rule to handle access to *.cnn.com
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: handle-cnn-access
namespace: istio-system
spec:
match: request.host.endsWith(&amp;#34;.cnn.com&amp;#34;) &amp;amp;&amp;amp; context.reporter.uid.startsWith(&amp;#34;kubernetes://istio-egressgateway&amp;#34;)
actions:
- handler: egress-access-logger.stdio
instances:
- egress-access.logentry
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>发送三个 HTTP 请求到 &lt;em>cnn.com&lt;/em> 、&lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a>、&lt;a href="https://edition.cnn.com/sport">edition.cnn.com/sport&lt;/a> 和 &lt;a href="https://edition.cnn.com/health">edition.cnn.com/health&lt;/a>。
三个请求都应该返回 &lt;em>200 OK&lt;/em> 。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD -c sleep -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
200
200
200
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>查询 Mixer 日志，查看请求信息出现在日志中:&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n istio-system logs -l istio-mixer-type=telemetry -c mixer | grep egress-access | grep cnn | tail -4
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:43:24.611462Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/politics&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:1883355,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:43:24.886316Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/sport&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:2094561,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:43:25.369663Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/health&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:2157009,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;error&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:43:24.611462Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/politics&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:1883355,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
&lt;/code>&lt;/pre>
&lt;p>您将看到与您的三个请求相关的四个日志条目。三个关于访问 &lt;em>edition.cnn.com&lt;/em> 的 &lt;em>info&lt;/em> 信息和一个关于访问 &lt;em>edition.cnn.com/politics&lt;/em> 的 &lt;em>error&lt;/em> 信息。服务网格 operators 可以查看所有访问实例，还可以搜索日志中表示禁止访问的 &lt;em>error&lt;/em> 日志。这是在自动地阻塞禁止访问之前可以应用的第一个安全措施，即将所有禁止访问实例记录为错误。在某些设置中，这可能是一个足够的安全措施。&lt;/p>
&lt;p>注意以下属性：&lt;/p>
&lt;ul>
&lt;li>&lt;code>destination&lt;/code>、&lt;code>path&lt;/code>、&lt;code>responseCode&lt;/code> 和 &lt;code>responseSize&lt;/code> 与请求的 HTTP 参数相关&lt;/li>
&lt;li>&lt;code>sourcePrincipal&lt;/code>:&lt;code>cluster.local/ns/default/sa/sleep&lt;/code> —— 表示 &lt;code>default&lt;/code> 命名空间中的 &lt;code>sleep&lt;/code> 服务帐户的字符串&lt;/li>
&lt;li>&lt;code>reporterUID&lt;/code>: &lt;code>kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&lt;/code> —— 报告 pod 的 UID，在本例中为 &lt;code>istio-egressgateway-747b6764b8-44rrh&lt;/code>，位于 &lt;code>istio-system&lt;/code> 命名空间中&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ol>
&lt;h3 id="access-control-by-routing">路由访问控制&lt;/h3>
&lt;p>启用对 &lt;em>edition.cnn.com&lt;/em> 的访问进行日志记录之后，自动执行访问策略，即只允许访问 &lt;em>/health&lt;/em> 和 &lt;em>/sport&lt;/em> URL 路径。这样一个简单的策略控制可以通过 Istio 路由实现。&lt;/p>
&lt;ol>
&lt;li>&lt;p>为 &lt;em>edition.cnn.com&lt;/em> 重定义 &lt;code>VirtualService&lt;/code> ：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-cnn-through-egress-gateway
spec:
hosts:
- edition.cnn.com
gateways:
- istio-egressgateway
- mesh
http:
- match:
- gateways:
- mesh
port: 80
route:
- destination:
host: istio-egressgateway.istio-system.svc.cluster.local
subset: cnn
port:
number: 443
weight: 100
- match:
- gateways:
- istio-egressgateway
port: 443
uri:
regex: &amp;#34;/health|/sport&amp;#34;
route:
- destination:
host: edition.cnn.com
port:
number: 443
weight: 100
EOF
&lt;/code>&lt;/pre>
&lt;p>注意，您通过 &lt;code>url&lt;/code> 添加添加了一个 &lt;code>match&lt;/code>，该条件检查 URL 路径是 &lt;em>/health&lt;/em> 还是 &lt;em>/sport&lt;/em> 。还要注意，此条件已添加到 &lt;code>VirtualService&lt;/code> 的 &lt;code>istio-egressgateway&lt;/code> 部分，因为就安全性而言，egress 网关是一个经过加固的组件（请参阅 &lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#additional-security-considerations">egress 网关安全性注意事项&lt;/a>）。您一定不希望您的任何策略被篡改。&lt;/p>&lt;/li>
&lt;li>&lt;p>发送之前的三个 HTTP 请求到 &lt;em>cnn.com&lt;/em> ：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD -c sleep -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
404
200
200
&lt;/code>&lt;/pre>
&lt;p>向 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 发送请求会返回 &lt;em>404 Not Found&lt;/em> ，然而向
&lt;a href="https://edition.cnn.com/sport">edition.cnn.com/sport&lt;/a> 和
&lt;a href="https://edition.cnn.com/health">edition.cnn.com/health&lt;/a> 发送请求，会像我们预想的那样返回 &lt;em>200 OK&lt;/em> 。&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">您可能需要等待几秒钟，等待 &lt;code>VirtualService&lt;/code> 的更新传播到 egress 网关。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;/li>
&lt;li>&lt;p>查询 Mixer 日志，可以看到关于请求的信息再次出现在日志中：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n istio-system logs -l istio-mixer-type=telemetry -c mixer | grep egress-access | grep cnn | tail -4
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:55:59.686082Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/politics&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:404,&amp;#34;responseSize&amp;#34;:0,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:55:59.697565Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/sport&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:2094561,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:56:00.264498Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/health&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:2157009,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;error&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T07:55:59.686082Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/politics&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:404,&amp;#34;responseSize&amp;#34;:0,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/sleep&amp;#34;}
&lt;/code>&lt;/pre>
&lt;p>你依然会得到关于访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 的信息和错误消息，然而这次 &lt;code>responseCode&lt;/code> 会像我们预想的那样返回 &lt;code>404&lt;/code> 。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>虽然在这个简单的例子中使用 Istio 路由实现访问控制是可行的，但是在更复杂的例子中就不够了。例如，组织可能希望在某些条件下允许访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a>，因此需要比仅通过 URL 路径过滤更复杂的策略逻辑。您可能想要应用 Istio Mixer 适配器，例如允许/禁止 URL 路径的&lt;a href="/v1.8/zh/docs/tasks/policy-enforcement/denial-and-list/#attribute-based-whitelists-or-blacklists">白名单或黑名单&lt;/a>。策略规则允许指定复杂的条件，用丰富的表达式语言指定，其中包括与和或逻辑运算符。这些规则可用于日志记录和策略检查。更高级的用户可能希望应用基于 &lt;a href="/v1.8/zh/docs/concepts/security/#authorization">Istio 角色访问控制&lt;/a>。&lt;/p>
&lt;p>另一方面是与远程访问策略系统的集成。如果在我们的用例中组织操作一些&lt;a href="https://en.wikipedia.org/wiki/Identity_management">标识和访问管理&lt;/a>系统，您可能希望配置 Istio 来使用来自这样一个系统的访问策略信息。您可以通过应用 &lt;a href="/v1.8/zh/blog/2017/adapter-model/">Istio Mixer 适配器&lt;/a>来实现这种集成。&lt;/p>
&lt;p>现在您移除在本节中使用的路由取消访问控制，在下一节将向您演示通过 Mixer 策略检查实现访问控制。&lt;/p>
&lt;ol>
&lt;li>&lt;p>用之前&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway-tls-origination/#perform-TLS-origination-with-an-egress-gateway">配置 Egress 网关&lt;/a>示例中的版本替换 &lt;em>edition.cnn.com&lt;/em> 的 &lt;code>VirtualService&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: direct-cnn-through-egress-gateway
spec:
hosts:
- edition.cnn.com
gateways:
- istio-egressgateway
- mesh
http:
- match:
- gateways:
- mesh
port: 80
route:
- destination:
host: istio-egressgateway.istio-system.svc.cluster.local
subset: cnn
port:
number: 443
weight: 100
- match:
- gateways:
- istio-egressgateway
port: 443
route:
- destination:
host: edition.cnn.com
port:
number: 443
weight: 100
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>发送之前的三个 HTTP 请求到 &lt;em>cnn.com&lt;/em> ，这一次您应该会收到三个 &lt;em>200 OK&lt;/em> 的响应：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD -c sleep -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
200
200
200
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">您可能需要等待几秒钟，等待 &lt;code>VirtualService&lt;/code> 的更新传播到 egress 网关。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;h3 id="access-control-by-Mixer-policy-checks">Mixer 策略检查访问控制&lt;/h3>
&lt;p>在该步骤中，您使用 Mixer &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/adapters/list/">&lt;code>Listchecker&lt;/code> 适配器&lt;/a>，它是一种白名单。您可以使用请求的 URL 路径定义一个 &lt;code>listentry&lt;/code>，并使用一个 &lt;code>listchecker&lt;/code> 由 &lt;code>overrides&lt;/code> 字段指定的允许 URL 路径的静态列表检查 &lt;code>listentry&lt;/code>。对于&lt;a href="https://en.wikipedia.org/wiki/Identity_management">外部标识和访问管理&lt;/a>系统，请使用 &lt;code>providerurl&lt;/code> 字段。实例、规则和处理程序的更新图如下所示。注意，您重用相同的策略规则 &lt;code>handle-cn-access&lt;/code> 来进行日志记录和访问策略检查。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:52.79420593027812%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-monitoring-access-control/egress-adapters-monitoring-policy.svg" title="用于 egress 监视和访问策略的实例、规则和处理程序">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-monitoring-access-control/egress-adapters-monitoring-policy.svg" alt="用于 egress 监视和访问策略的实例、规则和处理程序" />
&lt;/a>
&lt;/div>
&lt;figcaption>用于 egress 监视和访问策略的实例、规则和处理程序&lt;/figcaption>
&lt;/figure>
&lt;ol>
&lt;li>&lt;p>定义 &lt;code>path-checker&lt;/code> 和 &lt;code>request-path&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl create -f -
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: listchecker
metadata:
name: path-checker
namespace: istio-system
spec:
overrides: [&amp;#34;/health&amp;#34;, &amp;#34;/sport&amp;#34;] # overrides provide a static list
blacklist: false
---
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: listentry
metadata:
name: request-path
namespace: istio-system
spec:
value: request.path
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>修改 &lt;code>handle-cnn-access&lt;/code> 策略规则并发送 &lt;code>request-path&lt;/code> 实例到 &lt;code>path-checker&lt;/code>：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
# Rule handle egress access to cnn.com
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: handle-cnn-access
namespace: istio-system
spec:
match: request.host.endsWith(&amp;#34;.cnn.com&amp;#34;) &amp;amp;&amp;amp; context.reporter.uid.startsWith(&amp;#34;kubernetes://istio-egressgateway&amp;#34;)
actions:
- handler: egress-access-logger.stdio
instances:
- egress-access.logentry
- handler: path-checker.listchecker
instances:
- request-path.listentry
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>执行常规测试，将 HTTP 请求发送到 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a>，&lt;a href="https://edition.cnn.com/sport">edition.cnn.com/sport&lt;/a> 和 &lt;a href="https://edition.cnn.com/health">edition.cnn.com/health&lt;/a>。正如所料，对 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 的请求返回 &lt;em>403&lt;/em> （禁止）。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD -c sleep -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
403
200
200
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h3 id="access-control-by-Mixer-policy-checks-part-2">Mixer 策略检查访问控制，第二部分&lt;/h3>
&lt;p>在我们用例中的组织设法配置日志和访问控制之后，它决定扩展它的访问策略，允许具有特殊&lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">服务帐户&lt;/a>的应用程序访问 &lt;em>cnn.com&lt;/em> 的任何主题，而不受监控。您将看到如何在 Istio 中配置此需求。&lt;/p>
&lt;ol>
&lt;li>&lt;p>使用 &lt;code>politics&lt;/code> 服务账户开启 &lt;a href="https://github.com/istio/istio/tree/release-1.8/samples/sleep">sleep&lt;/a> 示例程序。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ sed &amp;#39;s/: sleep/: politics/g&amp;#39; samples/sleep/sleep.yaml | kubectl create -f -
serviceaccount &amp;#34;politics&amp;#34; created
service &amp;#34;politics&amp;#34; created
deployment &amp;#34;politics&amp;#34; created
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>定义 &lt;code>SOURCE_POD_POLITICS&lt;/code> shell 变量来保存带有 &lt;code>politics&lt;/code> 服务帐户的源 pod 的名称，以便向外部服务发送请求。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export SOURCE_POD_POLITICS=$(kubectl get pod -l app=politics -o jsonpath={.items..metadata.name})
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>执行常规测试，这次从 &lt;code>SOURCE_POD_POLITICS&lt;/code> 发送三个 HTTP 请求。对 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 的请求返回 &lt;em>403&lt;/em> ，因为您没有为 &lt;em>politics&lt;/em> 命名空间配置异常。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD_POLITICS -c politics -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
403
200
200
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>查询 Mixer 日志，可以看到来自 &lt;em>politics&lt;/em> 命名空间的请求信息出现在日志中：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n istio-system logs -l istio-mixer-type=telemetry -c mixer | grep egress-access | grep cnn | tail -4
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T08:04:42.559812Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/politics&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:403,&amp;#34;responseSize&amp;#34;:84,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/politics&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T08:04:42.568424Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/sport&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:2094561,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/politics&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;error&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T08:04:42.559812Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/politics&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:403,&amp;#34;responseSize&amp;#34;:84,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/politics&amp;#34;}
{&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;time&amp;#34;:&amp;#34;2019-01-29T08:04:42.615641Z&amp;#34;,&amp;#34;instance&amp;#34;:&amp;#34;egress-access.logentry.istio-system&amp;#34;,&amp;#34;destination&amp;#34;:&amp;#34;edition.cnn.com&amp;#34;,&amp;#34;path&amp;#34;:&amp;#34;/health&amp;#34;,&amp;#34;reporterUID&amp;#34;:&amp;#34;kubernetes://istio-egressgateway-747b6764b8-44rrh.istio-system&amp;#34;,&amp;#34;responseCode&amp;#34;:200,&amp;#34;responseSize&amp;#34;:2157009,&amp;#34;sourcePrincipal&amp;#34;:&amp;#34;cluster.local/ns/default/sa/politics&amp;#34;}
&lt;/code>&lt;/pre>
&lt;p>注意 &lt;code>sourcePrincipal&lt;/code> 是 &lt;code>cluster.local/ns/default/sa/politics&lt;/code>，表示 &lt;code>default&lt;/code> 命名空间中的 &lt;code>politics&lt;/code> 服务帐户。&lt;/p>&lt;/li>
&lt;li>&lt;p>重新定义 &lt;code>handle-cn-access&lt;/code> 和 &lt;code>handl-politics&lt;/code> 策略规则，使 &lt;em>politics&lt;/em> 命名空间中的应用程序免受监控和策略强制。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat &amp;lt;&amp;lt;EOF | kubectl apply -f -
# Rule to handle access to *.cnn.com/politics
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: handle-politics
namespace: istio-system
spec:
match: request.host.endsWith(&amp;#34;cnn.com&amp;#34;) &amp;amp;&amp;amp; context.reporter.uid.startsWith(&amp;#34;kubernetes://istio-egressgateway&amp;#34;) &amp;amp;&amp;amp; request.path.startsWith(&amp;#34;/politics&amp;#34;) &amp;amp;&amp;amp; source.principal != &amp;#34;cluster.local/ns/default/sa/politics&amp;#34;
actions:
- handler: egress-error-logger.stdio
instances:
- egress-access.logentry
---
# Rule handle egress access to cnn.com
apiVersion: &amp;#34;config.istio.io/v1alpha2&amp;#34;
kind: rule
metadata:
name: handle-cnn-access
namespace: istio-system
spec:
match: request.host.endsWith(&amp;#34;.cnn.com&amp;#34;) &amp;amp;&amp;amp; context.reporter.uid.startsWith(&amp;#34;kubernetes://istio-egressgateway&amp;#34;) &amp;amp;&amp;amp; source.principal != &amp;#34;cluster.local/ns/default/sa/politics&amp;#34;
actions:
- handler: egress-access-logger.stdio
instances:
- egress-access.logentry
- handler: path-checker.listchecker
instances:
- request-path.listentry
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>从 &lt;code>SOURCE_POD&lt;/code> 中执行常规测试：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD -c sleep -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
403
200
200
&lt;/code>&lt;/pre>
&lt;p>由于 &lt;code>SOURCE_POD&lt;/code> 没有 &lt;code>politics&lt;/code> 服务帐户，所以像以前一样访问 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 会被禁止。&lt;/p>&lt;/li>
&lt;li>&lt;p>从 &lt;code>SOURCE_POD_POLITICS&lt;/code> 中执行之前的测试：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl exec -it $SOURCE_POD_POLITICS -c politics -- sh -c &amp;#39;curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/politics; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/sport; curl -sL -o /dev/null -w &amp;#34;%{http_code}\n&amp;#34; http://edition.cnn.com/health&amp;#39;
200
200
200
&lt;/code>&lt;/pre>
&lt;p>访问 &lt;em>edition.cnn.com&lt;/em> 的所有话题都是被允许的。&lt;/p>&lt;/li>
&lt;li>&lt;p>检查 Mixer 日志，查看是否有更多使用 &lt;code>sourcePrincipal&lt;/code> 请求，能够匹配 &lt;code>cluster.local/ns/default/sa/politics&lt;/code> 的内容出现在日志中。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -n istio-system logs -l istio-mixer-type=telemetry -c mixer | grep egress-access | grep cnn | tail -4
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="comparison-with-HTTPS-egress-traffic-control">与 HTTPS egress 流量控制进行比较&lt;/h2>
&lt;p>在这个用例中，应用程序使用 HTTP 和 Istio Egress 网关为它们执行 TLS 初始化。或者，应用程序可以通过向 &lt;em>edition.cnn.com&lt;/em> 发出 HTTPS 请求来发起 TLS 本身。在本节中，我们将描述这两种方法及其优缺点。&lt;/p>
&lt;p>在 HTTP 方法中，请求在本地主机上不加密地发送，由 Istio sidecar 代理拦截并转发到 egress 网关。由于您将 Istio 配置为在 sidecar 代理和 egress 网关之间使用相互的 TLS，因此流量会使 pod 加密。egress 网关解密流量，检查 URL 路径、HTTP 方法和报头，报告遥测数据并执行策略检查。如果请求没有被某些策略检查阻止，那么 egress 网关将执行 TLS 发起到外部目的地（在我们的示例中是 &lt;em>cnn.com&lt;/em> ），因此请求将再次加密并发送到外部目的地。下图演示了这种方法的流程。网关内的 HTTP 协议根据解密后网关看到的协议来指定协议。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:64.81718469808756%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-monitoring-access-control/http-to-gateway.svg" title="HTTP egress 流量通过 egress 网关">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-monitoring-access-control/http-to-gateway.svg" alt="HTTP egress 流量通过 egress 网关" />
&lt;/a>
&lt;/div>
&lt;figcaption>HTTP egress 流量通过 egress 网关&lt;/figcaption>
&lt;/figure>
&lt;p>这种方法的缺点是请求在 pod 中发送时没有加密，这可能违反某些组织的安全策略。此外，一些 SDK 具有硬编码的外部服务 URL，包括协议，因此不可能发送 HTTP 请求。这种方法的优点是能够检查 HTTP 方法、头和 URL 路径，并基于它们应用策略。&lt;/p>
&lt;p>在 HTTPS 方法中，从应用程序到外部目的地的请求是端到端加密的。下图演示了这种方法的流程。网关中的 HTTPS 协议指定网关所看到的协议。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:64.81718469808756%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-monitoring-access-control/https-to-gateway.svg" title="HTTPS egress 流量通过 egress 网关">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-monitoring-access-control/https-to-gateway.svg" alt="HTTPS egress 流量通过 egress 网关" />
&lt;/a>
&lt;/div>
&lt;figcaption>HTTPS egress 流量通过 egress 网关&lt;/figcaption>
&lt;/figure>
&lt;p>从安全的角度来看，端到端 HTTPS 被认为是一种更好的方法。然而，由于流量是加密的，Istio 代理和出口网关只能看到源和目标 IP 以及目标的 &lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI&lt;/a>。由于您将 Istio 配置为在 sidecar 代理和 egress 网关之间使用相互的 TLS ，所以&lt;a href="/v1.8/zh/docs/concepts/security/#istio-identity">源标识&lt;/a>也是已知的。网关无法检查 URL 路径、HTTP 方法和请求的头，因此无法基于 HTTP 信息进行监控和策略。在我们的用例中，组织将能够允许访问 &lt;em>edition.cnn.com&lt;/em> 并指定允许哪些应用程序访问 &lt;em>edition.cnn.com&lt;/em> 。但是，将不可能允许或阻止对 &lt;em>edition.cnn.com&lt;/em> 的特定 URL 路径的访问。使用 HTTPS 方法既不能阻止对 &lt;a href="https://edition.cnn.com/politics">edition.cnn.com/politics&lt;/a> 的访问，也不能监控此类访问。&lt;/p>
&lt;p>我们认为，每个组织都应充分考虑这两种方法的优缺点，并选择最适合其需要的方法。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>在这篇博客文章中，我们展示了如何将 Istio 的不同监控和策略机制应用于 HTTP egress 流量。可以通过配置日志适配器来实现监控。访问策略可以通过配置 &lt;code>VirtualServices&lt;/code> 或配置各种策略检查适配器来实现。向您演示了一个只允许特定 URL 路径的简单策略。还向您展示了一个更复杂的策略，通过对具有特定服务帐户的应用程序进行豁免，扩展了简单策略。最后，比较了 HTTP-with-TLS-origination egress 流量与 HTTPS egress 流量，以及通过 Istio 进行控制的可能性。&lt;/p>
&lt;h2 id="cleanup">清理&lt;/h2>
&lt;ol>
&lt;li>&lt;p>执行&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/">配置 Egress 网关&lt;/a>示例的&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-gateway/#cleanup">清理&lt;/a>部分中的说明。&lt;/p>&lt;/li>
&lt;li>&lt;p>删除日志和策略检查配置：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete logentry egress-access -n istio-system
$ kubectl delete stdio egress-error-logger -n istio-system
$ kubectl delete stdio egress-access-logger -n istio-system
$ kubectl delete rule handle-politics -n istio-system
$ kubectl delete rule handle-cnn-access -n istio-system
$ kubectl delete -n istio-system listchecker path-checker
$ kubectl delete -n istio-system listentry request-path
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>删除 &lt;em>politics&lt;/em> 源 pod：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ sed &amp;#39;s/: sleep/: politics/g&amp;#39; samples/sleep/sleep.yaml | kubectl delete -f -
serviceaccount &amp;#34;politics&amp;#34; deleted
service &amp;#34;politics&amp;#34; deleted
deployment &amp;#34;politics&amp;#34; deleted
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol></description><pubDate>Fri, 22 Jun 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/egress-monitoring-access-control/</link><author>Vadim Eisenberg and Ronen Schaffer (IBM)</author><guid isPermaLink="true">/v1.8/zh/blog/2018/egress-monitoring-access-control/</guid><category>egress</category><category>traffic-management</category><category>access-control</category><category>monitoring</category></item><item><title>Istio v1aplha3 路由 API 介绍</title><description>
&lt;p>到目前为止，Istio 提供了一个简单的 API 来进行流量管理，该 API 包括了四种资源：&lt;code>RouteRule&lt;/code>，&lt;code>DestinationPolicy&lt;/code>，&lt;code>EgressRule&lt;/code> 和 （Kubernetes 的）&lt;code>Ingress&lt;/code>。借助此 API，用户可以轻松管理 Istio 服务网格中的流量。该 API 允许用户将请求路由到特定版本的服务，为弹性测试注入延迟和失败，添加超时和断路器等，所有这些功能都不必更改应用程序本身的代码。&lt;/p>
&lt;p>虽然目前 API 的功能已被证明是 Istio 非常引人注目的一部分，但用户的反馈也表明，这个 API 确实有一些缺点，尤其是在使用它来管理包含数千个服务的非常大的应用程序，以及使用 HTTP 以外的协议时。此外，使用 Kubernetes Ingress 资源来配置外部流量的方式已被证明不能满足需求。&lt;/p>
&lt;p>为了解决上述缺陷和其他的一些问题，Istio 引入了新的流量管理 API v1alpha3，新版本的 API 将完全取代之前的 API。尽管 v1alpha3 和之前的模型在本质上是基本相同的，但它并不向后兼容的，基于旧 API 的模型需要进行手动转换。&lt;/p>
&lt;p>为了证明该非兼容升级的必要性，v1alpha3 API 经历了漫长而艰苦的社区评估过程，以希望新的 API 能够大幅改进，并经得起时间考验。在本文中，我们将介绍新的配置模型，并试图解释影响这次变化的一些动机和设计原则。&lt;/p>
&lt;h2 id="design-principles">设计原则&lt;/h2>
&lt;p>路由模型的重构过程中遵循了一些关键的设计原则：&lt;/p>
&lt;ul>
&lt;li>除支持声明式（意图）配置外，也支持显式指定模型依赖的基础设施。例如，除了配置入口网关（的功能特性）之外，负责实现 入口网关功能的组件（Controller）也可以在模型指定。&lt;/li>
&lt;li>编写模型时应该&amp;rdquo;生产者导向”和&amp;rdquo;以 Host 为中心”，而不是通过组合多个规则来编写模型。例如，所有与特定 Host 关联的规则被配置在一起，而不是单独配置。&lt;/li>
&lt;li>将路由与路由后行为清晰分开。&lt;/li>
&lt;/ul>
&lt;h2 id="configuration-resources-in-v1alpha3">v1alpha3 中的配置资源&lt;/h2>
&lt;p>在一个典型的网格中，通常有一个或多个用于终结外部 TLS 链接，将流量引入网格的负载均衡器（我们称之为 gateway）。然后流量通过边车网关（sidecar gateway）流经内部服务。应用程序使用外部服务的情况也很常见（例如访问 Google Maps API），一些情况下，这些外部服务可能被直接调用；但在某些部署中，网格中所有访问外部服务的流量可能被要求强制通过专用的出口网关（Egress gateway）。下图描绘了网关在网格中的使用情况。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:35.204472660409245%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/v1alpha3-routing/gateways.svg" title="Istio 服务网格中的网关">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/v1alpha3-routing/gateways.svg" alt="Role of gateways in the mesh" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio 服务网格中的网关&lt;/figcaption>
&lt;/figure>
&lt;p>考虑到上述因素，&lt;code>v1alpha3&lt;/code>引入了以下这些新的配置资源来控制进入网格，网格内部和离开网格的流量路由。&lt;/p>
&lt;ol>
&lt;li>&lt;code>Gateway&lt;/code>&lt;/li>
&lt;li>&lt;code>VirtualService&lt;/code>&lt;/li>
&lt;li>&lt;code>DestinationRule&lt;/code>&lt;/li>
&lt;li>&lt;code>ServiceEntry&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>&lt;code>VirtualService&lt;/code>，&lt;code>DestinationRule&lt;/code> 和 &lt;code>ServiceEntry&lt;/code> 分别替换了原 API 中的 &lt;code>RouteRule&lt;/code>，&lt;code>DestinationPolicy&lt;/code> 和 &lt;code>EgressRule&lt;/code>。&lt;code>Gateway&lt;/code> 是一个独立于平台的抽象，用于对流入专用中间设备的流量进行建模。&lt;/p>
&lt;p>下图描述了跨多个配置资源的控制流程。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:41.164966727369595%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/v1alpha3-routing/virtualservices-destrules.svg" title="不同 v1alpha3 元素之间的关系">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/v1alpha3-routing/virtualservices-destrules.svg" alt="不同 v1alpha3 元素之间的关系" />
&lt;/a>
&lt;/div>
&lt;figcaption>不同 v1alpha3 元素之间的关系&lt;/figcaption>
&lt;/figure>
&lt;h3 id="gateway">&lt;code>Gateway&lt;/code>&lt;/h3>
&lt;p>&lt;a href="/v1.8/zh/docs/reference/config/networking/gateway/">&lt;code>Gateway&lt;/code>&lt;/a> 用于为 HTTP / TCP 流量配置负载均衡器，并不管该负载均衡器将在哪里运行。网格中可以存在任意数量的 Gateway，并且多个不同的 Gateway 实现可以共存。实际上，通过在配置中指定一组工作负载（Pod）标签，可以将 Gateway 配置绑定到特定的工作负载，从而允许用户通过编写简单的 Gateway Controller 来重用现成的网络设备。&lt;/p>
&lt;p>对于入口流量管理，您可能会问：&lt;em>为什么不直接使用 Kubernetes Ingress API&lt;/em> ？原因是 Ingress API 无法表达 Istio 的路由需求。Ingress 试图在不同的 HTTP 代理之间取一个公共的交集，因此只能支持最基本的 HTTP 路由，最终导致需要将代理的其他高级功能放入到注解（annotation）中，而注解的方式在多个代理之间是不兼容的，无法移植。&lt;/p>
&lt;p>Istio &lt;code>Gateway&lt;/code> 通过将 L4-L6 配置与 L7 配置分离的方式克服了 &lt;code>Ingress&lt;/code> 的这些缺点。&lt;code>Gateway&lt;/code> 只用于配置 L4-L6 功能（例如，对外公开的端口，TLS 配置），所有主流的 L7 代理均以统一的方式实现了这些功能。然后，通过在 &lt;code>Gateway&lt;/code> 上绑定 &lt;code>VirtualService&lt;/code> 的方式，可以使用标准的 Istio 规则来控制进入 &lt;code>Gateway&lt;/code> 的 HTTP 和 TCP 流量。&lt;/p>
&lt;p>例如，下面这个简单的 &lt;code>Gateway&lt;/code> 配置了一个 Load Balancer，以允许访问 host &lt;code>bookinfo.com&lt;/code> 的 https 外部流量进入网格中：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: Gateway
metadata:
name: bookinfo-gateway
spec:
servers:
- port:
number: 443
name: https
protocol: HTTPS
hosts:
- bookinfo.com
tls:
mode: SIMPLE
serverCertificate: /tmp/tls.crt
privateKey: /tmp/tls.key
&lt;/code>&lt;/pre>
&lt;p>要为进入上面的 Gateway 的流量配置相应的路由，必须为同一个 host 定义一个 &lt;code>VirtualService&lt;/code>（在下一节中描述），并使用配置中的 &lt;code>gateways&lt;/code> 字段绑定到前面定义的 &lt;code>Gateway&lt;/code> 上：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: bookinfo
spec:
hosts:
- bookinfo.com
gateways:
- bookinfo-gateway # &amp;lt;---- bind to gateway
http:
- match:
- uri:
prefix: /reviews
route:
...
&lt;/code>&lt;/pre>
&lt;p>&lt;code>Gateway&lt;/code> 可以用于建模边缘代理或纯粹的内部代理，如第一张图所示。无论在哪个位置，所有网关都可以用相同的方式进行配置和控制。&lt;/p>
&lt;h3 id="virtualservice">&lt;code>VirtualService&lt;/code>&lt;/h3>
&lt;p>用一种叫做 &amp;ldquo;Virtual services” 的东西代替路由规则可能看起来有点奇怪，但对于它配置的内容而言，这事实上是一个更好的名称，特别是在重新设计 API 以解决先前模型的可扩展性问题之后。&lt;/p>
&lt;p>实际上，发生的变化是：在之前的模型中，需要用一组相互独立的配置规则来为特定的目的服务设置路由规则，并通过 precedence 字段来控制这些规则的顺序；在新的 API 中，则直接对（虚拟）服务进行配置，该虚拟服务的所有规则以一个有序列表的方式配置在对应的 &lt;a href="/v1.8/zh/docs/reference/config/networking/virtual-service/">&lt;code>VirtualService&lt;/code>&lt;/a> 资源中。&lt;/p>
&lt;p>例如，之前在 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo&lt;/a> 应用程序的 &lt;code>reviews&lt;/code> 服务中有两个 &lt;code>RouteRule&lt;/code> 资源，如下所示：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
name: reviews-default
spec:
destination:
name: reviews
precedence: 1
route:
- labels:
version: v1
---
apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
name: reviews-test-v2
spec:
destination:
name: reviews
precedence: 2
match:
request:
headers:
cookie:
regex: &amp;#34;^(.*?;)?(user=jason)(;.*)?$&amp;#34;
route:
- labels:
version: v2
&lt;/code>&lt;/pre>
&lt;p>在 &lt;code>v1alpha3&lt;/code>，可以在单个 &lt;code>VirtualService&lt;/code> 资源中提供相同的配置：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: reviews
spec:
hosts:
- reviews
http:
- match:
- headers:
cookie:
regex: &amp;#34;^(.*?;)?(user=jason)(;.*)?$&amp;#34;
route:
- destination:
host: reviews
subset: v2
- route:
- destination:
host: reviews
subset: v1
&lt;/code>&lt;/pre>
&lt;p>正如你所看到的，和 &lt;code>reviews&lt;/code> 服务相关的两个规则集中写在了一个地方。这个改变乍一看可能觉得并没有什么特别的优势，然而，如果仔细观察这个新模型，会发现它和之前的 API 之间存在着根本的差异，这使得 &lt;code>v1alpha3&lt;/code> 功能更加强大。&lt;/p>
&lt;p>首先，请注意 &lt;code>VirtualService&lt;/code> 的目标服务是使用 &lt;code>hosts&lt;/code> 字段（实际上是重复字段）指定的，然后再在每个路由的 &lt;code>destination&lt;/code> 字段中指定。这是与以前模型的重要区别。&lt;/p>
&lt;p>&lt;code>VirtualService&lt;/code> 描述了一个或多个用户可寻址目标到网格内实际工作负载之间的映射。在上面的示例中，这两个地址是相同的，但实际上用户可寻址目标可以是任何用于定位服务的，具有可选通配符前缀或 CIDR 前缀的 DNS 名称。
这对于应用从单体架构到微服务架构的迁移过程特别有用，单体应用被拆分为多个独立的微服务后，采用 &lt;code>VirtualService&lt;/code> 可以继续把多个微服务对外暴露为同一个目标地址，而不需要服务消费者进行修改以适应该变化。&lt;/p>
&lt;p>例如，以下规则允许服务消费者访问 Bookinfo 应用程序的 reviews 和 ratings 服务，就好像它们是 &lt;code>http://bookinfo.com/&lt;/code>（虚拟）服务的一部分：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: bookinfo
spec:
hosts:
- bookinfo.com
http:
- match:
- uri:
prefix: /reviews
route:
- destination:
host: reviews
- match:
- uri:
prefix: /ratings
route:
- destination:
host: ratings
...
&lt;/code>&lt;/pre>
&lt;p>实际上在 &lt;code>VirtualService&lt;/code> 中 hosts 部分设置只是虚拟的目的地, 因此不一定是已在网格中注册的服务。这允许用户为在网格内没有可路由条目的虚拟主机的流量进行建模。通过将 &lt;code>VirtualService&lt;/code> 绑定到同一 Host 的 &lt;code>Gateway&lt;/code> 配置（如前一节所述 ），可向网格外部暴露这些 Host。&lt;/p>
&lt;p>除了这个重大的重构之外，&lt;code>VirtualService&lt;/code> 还包括其他一些重要的改变：&lt;/p>
&lt;ol>
&lt;li>&lt;p>可以在 &lt;code>VirtualService&lt;/code> 配置中表示多个匹配条件，从而减少对冗余的规则设置。&lt;/p>&lt;/li>
&lt;li>&lt;p>每个服务版本都有一个名称（称为服务子集）。属于某个子集的一组 Pod/VM 在 &lt;code>DestinationRule&lt;/code> 定义，具体定义参见下节。&lt;/p>&lt;/li>
&lt;li>&lt;p>通过使用带通配符前缀的 DNS 来指定 &lt;code>VirtualService&lt;/code> 的 host，可以创建单个规则以作用于所有匹配的服务。例如，在 Kubernetes 中，在 &lt;code>VirtualService&lt;/code> 中使用 &lt;code>*.foo.svc.cluster.local&lt;/code> 作为 host , 可以对 &lt;code>foo&lt;/code> 命名空间中的所有服务应用相同的重写规则。&lt;/p>&lt;/li>
&lt;/ol>
&lt;h3 id="destinationrule">&lt;code>DestinationRule&lt;/code>&lt;/h3>
&lt;p>&lt;a href="/v1.8/zh/docs/reference/config/networking/destination-rule/">&lt;code>DestinationRule&lt;/code>&lt;/a> 配置将流量转发到服务时应用的策略集。这些策略应由服务提供者撰写，用于描述断路器，负载均衡设置，TLS 设置等。
除了下述改变外，&lt;code>DestinationRule&lt;/code> 与其前身 &lt;code>DestinationPolicy&lt;/code> 大致相同。&lt;/p>
&lt;ol>
&lt;li>&lt;code>DestinationRule&lt;/code> 的 &lt;code>host&lt;/code> 可以包含通配符前缀，以允许单个规则应用于多个服务。&lt;/li>
&lt;li>&lt;code>DestinationRule&lt;/code> 定义了目的 host 的子集 &lt;code>subsets&lt;/code> （例如：命名版本）。这些 subset 用于 &lt;code>VirtualService&lt;/code> 的路由规则设置中，可以将流量导向服务的某些特定版本。通过这种方式为版本命名后，可以在不同的 virtual service 中明确地引用这些命名版本的 subset，简化 Istio 代理发出的统计数据，并可以将 subset 编码到 SNI 头中。
为 reviews 服务配置策略和 subsets 的 &lt;code>DestinationRule&lt;/code> 可能如下所示：&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: reviews
spec:
host: reviews
trafficPolicy:
loadBalancer:
simple: RANDOM
subsets:
- name: v1
labels:
version: v1
- name: v2
labels:
version: v2
trafficPolicy:
loadBalancer:
simple: ROUND_ROBIN
- name: v3
labels:
version: v3
&lt;/code>&lt;/pre>
&lt;p>注意，与 &lt;code>DestinationPolicy&lt;/code> 不同的是，可在单个 &lt;code>DestinationRule&lt;/code> 中指定多个策略（例如上面实例中的缺省策略和 v2 版本特定的策略）。&lt;/p>
&lt;h3 id="serviceentry">&lt;code>ServiceEntry&lt;/code>&lt;/h3>
&lt;p>&lt;a href="/v1.8/zh/docs/reference/config/networking/service-entry/">&lt;code>ServiceEntry&lt;/code>&lt;/a> 用于将附加条目添加到 Istio 内部维护的服务注册表中。
它最常用于对访问网格外部依赖的流量进行建模，例如访问 Web 上的 API 或遗留基础设施中的服务。&lt;/p>
&lt;p>所有以前使用 &lt;code>EgressRule&lt;/code> 进行配置的内容都可以通过 &lt;code>ServiceEntry&lt;/code> 轻松完成。例如，可以使用类似这样的配置来允许从网格内部访问一个简单的外部服务：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: foo-ext
spec:
hosts:
- foo.com
ports:
- number: 80
name: http
protocol: HTTP
&lt;/code>&lt;/pre>
&lt;p>也就是说，&lt;code>ServiceEntry&lt;/code> 比它的前身具有更多的功能。首先，&lt;code>ServiceEntry&lt;/code> 不限于外部服务配置，它可以有两种类型：网格内部或网格外部。网格内部条目只是用于向网格显式添加服务，添加的服务与其他内部服务一样。采用网格内部条目，可以把原本未被网格管理的基础设施也纳入到网格中（例如，把虚机中的服务添加到基于 Kubernetes 的服务网格中）。网格外部条目则代表了网格外部的服务。对于这些外部服务来说，双向 TLS 身份验证是禁用的，并且策略是在客户端执行的，而不是在像内部服务请求一样在服务器端执行策略。&lt;/p>
&lt;p>由于 &lt;code>ServiceEntry&lt;/code> 配置只是将服务添加到网格内部的服务注册表中，因此它可以像注册表中的任何其他服务一样, 与 &lt;code>VirtualService&lt;/code> 和/或 &lt;code>DestinationRule&lt;/code> 一起使用。例如，以下 &lt;code>DestinationRule&lt;/code> 可用于启动外部服务的 双向 TLS 连接：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: foo-ext
spec:
name: foo.com
trafficPolicy:
tls:
mode: MUTUAL
clientCertificate: /etc/certs/myclientcert.pem
privateKey: /etc/certs/client_private_key.pem
caCertificates: /etc/certs/rootcacerts.pem
&lt;/code>&lt;/pre>
&lt;p>除了扩展通用性以外，&lt;code>ServiceEntry&lt;/code> 还提供了其他一些有关 &lt;code>EgressRule&lt;/code> 改进，其中包括：&lt;/p>
&lt;ol>
&lt;li>一个 &lt;code>ServiceEntry&lt;/code> 可以配置多个服务端点，这在之前需要采用多个 &lt;code>EgressRules&lt;/code> 来实现。&lt;/li>
&lt;li>现在可以配置服务端点的解析模式（&lt;code>NONE&lt;/code>，&lt;code>STATIC&lt;/code> 或 &lt;code>DNS&lt;/code>）。&lt;/li>
&lt;li>此外，我们正在努力解决另一个难题：目前需要通过纯文本端口访问安全的外部服务（例如 &lt;code>http://google.com:443&lt;/code>）。该问题将会在未来几周内得到解决，届时将允许从应用程序直接访问 &lt;code>https://google.com&lt;/code>。请继续关注解决此限制的 Istio 补丁版本（0.8.x）。&lt;/li>
&lt;/ol>
&lt;h2 id="creating-and-deleting-v1alpha3-route-rules">创建和删除 v1alpha3 路由规则&lt;/h2>
&lt;p>由于一个特定目的地的所有路由规则现在都存储在单个 &lt;code>VirtualService&lt;/code> 资源的一个有序列表中，因此为该目的地添加新的规则不需要再创建新的 &lt;code>RouteRule&lt;/code>，而是通过更新该目的地的 &lt;code>VirtualService&lt;/code> 资源来实现。&lt;/p>
&lt;p>旧的路由规则：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f my-second-rule-for-destination-abc.yaml
&lt;/code>&lt;/pre>
&lt;p>&lt;code>v1alpha3&lt;/code> 路由规则：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f my-updated-rules-for-destination-abc.yaml
&lt;/code>&lt;/pre>
&lt;p>通过使用&lt;code>kubectl apply&lt;/code>更新现有资源，也可以删除特定目的地的最后一个路径规则。&lt;/p>
&lt;p>在添加或删除引用服务版本的路由时，需要在该服务相应的 &lt;code>DestinationRule&lt;/code> 更新 &lt;code>subsets&lt;/code> 。正如你可能猜到的，这也是使用 &lt;code>kubectl apply&lt;/code> 完成的。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>Istio &lt;code>v1alpha3&lt;/code> 路由 API 具有比其前身更多的功能，但不幸的是新的 API 并不向后兼容，旧的模型升级需要一次手动转换。Istio 0.9 以后将不再支持 &lt;code>RouteRule&lt;/code>，&lt;code>DesintationPolicy&lt;/code> 和 &lt;code>EgressRule&lt;/code> 这些以前的配置资源 。Kubernetes 用户可以继续使用 &lt;code>Ingress&lt;/code> 配置边缘负载均衡器来实现基本的路由。但是，高级路由功能（例如，跨两个版本的流量分割）则需要使 &lt;code>用 Gateway&lt;/code> ，这是一种功能更强大，Istio 推荐的 &lt;code>Ingress&lt;/code> 替代品。&lt;/p>
&lt;h2 id="acknowledgments">致谢&lt;/h2>
&lt;p>感谢以下人员为新版本的路由模型重构和实现工作做出的贡献（按字母顺序）&lt;/p>
&lt;ul>
&lt;li>Frank Budinsky (IBM)&lt;/li>
&lt;li>Zack Butcher (Google)&lt;/li>
&lt;li>Greg Hanson (IBM)&lt;/li>
&lt;li>Costin Manolache (Google)&lt;/li>
&lt;li>Martin Ostrowski (Google)&lt;/li>
&lt;li>Shriram Rajagopalan (VMware)&lt;/li>
&lt;li>Louis Ryan (Google)&lt;/li>
&lt;li>Isaiah Snell-Feikema (IBM)&lt;/li>
&lt;li>Kuat Yessenov (Google)&lt;/li>
&lt;/ul></description><pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/v1alpha3-routing/</link><author>Frank Budinsky (IBM) and Shriram Rajagopalan (VMware)</author><guid isPermaLink="true">/v1.8/zh/blog/2018/v1alpha3-routing/</guid><category>traffic-management</category></item><item><title>使用 AWS NLB 配置 Istio Ingress</title><description>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">本文已于 2019 年 1 月 16 日更新，其中包含一些使用警告。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>本文提供了使用 &lt;a href="https://docs.aws.amazon.com/elasticloadbalancing/latest/network/introduction.html">AWS 网络负载均衡器&lt;/a>配置 ingress Istio 的说明。&lt;/p>
&lt;p>可以使用网络负载均衡器 (NLB) 来代替传统的负载均衡器。你可以查看不同的 AWS &lt;code>负载均衡器&lt;/code> 之间的&lt;a href="https://aws.amazon.com/elasticloadbalancing/details/#Product_comparisons">比较&lt;/a>以获取更多的解释。&lt;/p>
&lt;h2 id="prerequisites">先行条件&lt;/h2>
&lt;p>以下说明需要 Kubernetes &lt;strong>1.9.0 或更高版本&lt;/strong> 的集群。&lt;/p>
&lt;p>&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#exclamation-mark"/>&lt;/svg> AWS &lt;code>nlb&lt;/code> 在 Kubernetes 上的使用是一项 Alpha 功能 ，不建议用于生产环境的集群。&lt;/p>
&lt;h2 id="iam-policy">IAM Policy&lt;/h2>
&lt;p>你需要在主角色上应用策略，以便能够配置网络负载均衡器。&lt;/p>
&lt;ol>
&lt;li>&lt;p>在 AWS &lt;code>iam&lt;/code> 控制台中，点击策略并单击“创建新策略”：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:52.430278884462155%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/aws-nlb/createpolicystart.png" title="创建一个新的策略">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/aws-nlb/createpolicystart.png" alt="创建一个新的策略" />
&lt;/a>
&lt;/div>
&lt;figcaption>创建一个新的策略&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;li>&lt;p>选择 &lt;code>json&lt;/code>:&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:50.63492063492063%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/aws-nlb/createpolicyjson.png" title="选择 json">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/aws-nlb/createpolicyjson.png" alt="选择 json" />
&lt;/a>
&lt;/div>
&lt;figcaption>选择 json&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;li>&lt;p>拷贝以下内容：&lt;/p>
&lt;pre>&lt;code class='language-json' data-expandlinks='true' data-repo='istio' >{
&amp;#34;Version&amp;#34;: &amp;#34;2012-10-17&amp;#34;,
&amp;#34;Statement&amp;#34;: [
{
&amp;#34;Sid&amp;#34;: &amp;#34;kopsK8sNLBMasterPermsRestrictive&amp;#34;,
&amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;,
&amp;#34;Action&amp;#34;: [
&amp;#34;ec2:DescribeVpcs&amp;#34;,
&amp;#34;elasticloadbalancing:AddTags&amp;#34;,
&amp;#34;elasticloadbalancing:CreateListener&amp;#34;,
&amp;#34;elasticloadbalancing:CreateTargetGroup&amp;#34;,
&amp;#34;elasticloadbalancing:DeleteListener&amp;#34;,
&amp;#34;elasticloadbalancing:DeleteTargetGroup&amp;#34;,
&amp;#34;elasticloadbalancing:DescribeListeners&amp;#34;,
&amp;#34;elasticloadbalancing:DescribeLoadBalancerPolicies&amp;#34;,
&amp;#34;elasticloadbalancing:DescribeTargetGroups&amp;#34;,
&amp;#34;elasticloadbalancing:DescribeTargetHealth&amp;#34;,
&amp;#34;elasticloadbalancing:ModifyListener&amp;#34;,
&amp;#34;elasticloadbalancing:ModifyTargetGroup&amp;#34;,
&amp;#34;elasticloadbalancing:RegisterTargets&amp;#34;,
&amp;#34;elasticloadbalancing:SetLoadBalancerPoliciesOfListener&amp;#34;
],
&amp;#34;Resource&amp;#34;: [
&amp;#34;*&amp;#34;
]
},
{
&amp;#34;Effect&amp;#34;: &amp;#34;Allow&amp;#34;,
&amp;#34;Action&amp;#34;: [
&amp;#34;ec2:DescribeVpcs&amp;#34;,
&amp;#34;ec2:DescribeRegions&amp;#34;
],
&amp;#34;Resource&amp;#34;: &amp;#34;*&amp;#34;
}
]
}
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>点击审核策略，填写所有字段，接着点击创建策略：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:60.08097165991902%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/aws-nlb/create_policy.png" title="验证策略">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/aws-nlb/create_policy.png" alt="验证策略" />
&lt;/a>
&lt;/div>
&lt;figcaption>验证策略&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;li>&lt;p>点击角色，选择你的主角色节点，然后点击附加策略：&lt;/p>
&lt;figure style="width:100%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:30.328324986087924%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/aws-nlb/roles_summary.png" title="附加策略">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/aws-nlb/roles_summary.png" alt="附加策略" />
&lt;/a>
&lt;/div>
&lt;figcaption>附加策略&lt;/figcaption>
&lt;/figure>&lt;/li>
&lt;li>&lt;p>现在，你的策略就已经附加到了主节点。&lt;/p>&lt;/li>
&lt;/ol>
&lt;h2 id="generate-the-Istio-manifest">重写 Istio Ingress 服务&lt;/h2>
&lt;p>你需要使用以下内容来重写 &lt;code>istio-ingress&lt;/code> 服务：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Service
metadata:
name: istio-ingress
namespace: istio-system
labels:
istio: ingress
annotations:
service.beta.kubernetes.io/aws-load-balancer-type: &amp;#34;nlb&amp;#34;
spec:
externalTrafficPolicy: Local
ports:
- port: 80
protocol: TCP
targetPort: 80
name: http
- port: 443
protocol: TCP
targetPort: 443
name: https
selector:
istio: ingress
type: LoadBalancer
&lt;/code>&lt;/pre></description><pubDate>Fri, 20 Apr 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/aws-nlb/</link><author>Julien SENON</author><guid isPermaLink="true">/v1.8/zh/blog/2018/aws-nlb/</guid><category>ingress</category><category>traffic-management</category><category>aws</category></item><item><title>Istio 的软性多租户支持</title><description>
&lt;p>多租户是一个在各种环境和各种应用中都得到了广泛应用的概念，但是不同环境中，为每租户提供的具体实现和功能性都是有差异的。&lt;a href="https://github.com/kubernetes/community/blob/master/wg-multitenancy/README.md">Kubernetes 多租户工作组&lt;/a>致力于在 Kubernetes 中定义多租户用例和功能。然而根据他们的工作进展来看，恶意容器和负载对于其他租户的 Pod 和内核资源的访问无法做到完全控制，因此只有&amp;rdquo;软性多租户”支持是可行的。&lt;/p>
&lt;h2 id="soft-multi-tenancy">软性多租户&lt;/h2>
&lt;p>文中提到的&amp;rdquo;软性多租户”的定义指的是单一 Kubernetes 控制平面和多个 Istio 控制平面以及多个服务网格相结合；每个租户都有自己的一个控制平面和一个服务网格。集群管理员对所有 Istio 控制面都有控制和监控的能力，而租户管理员仅能得到指定 Istio 的控制权。使用 Kubernetes 的命名空间和 RBAC 来完成不同租户的隔离。&lt;/p>
&lt;p>这种模式的一个用例就是企业内部共享的基础设施中，虽然预计不会发生恶意行为，但租户之间的清晰隔离仍然是很有必要的。&lt;/p>
&lt;p>本文最后会对 Istio 未来的多租户模型进行一些描述。&lt;/p>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">这里仅就在有限多租户环境中部署 Istio 做一些概要描述。当官方多租户支持实现之后，会在&lt;a href="/v1.8/zh/docs/">文档&lt;/a>中具体阐述。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;h2 id="deployment">部署&lt;/h2>
&lt;h3 id="multiple-Istio-control-planes">多个 Istio 控制面&lt;/h3>
&lt;p>要部署多个 Istio 控制面，首先要在 Istio 清单文件中对所有的 &lt;code>namespace&lt;/code> 引用进行替换。以 &lt;code>istio.yaml&lt;/code> 为例：如果需要两个租户级的 Istio 控制面，那么第一个租户可以使用 &lt;code>istio.yaml&lt;/code> 中的缺省命名空间也就是 &lt;code>istio-system&lt;/code>；而第二个租户就要生成一个新的 yaml 文件，并在其中使用不同的命名空间。例如使用下面的命令创建一个使用 &lt;code>istio-system1&lt;/code> 命名空间的 yaml 文件：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ cat istio.yaml | sed s/istio-system/istio-system1/g &amp;gt; istio-system1.yaml
&lt;/code>&lt;/pre>
&lt;p>&lt;code>istio.yaml&lt;/code> 文件包含了 Istio 控制面的部署细节，包含组成控制面的 Pod（Mixer、Pilot、Ingress 以及 CA）。部署这两个控制面 yaml 文件：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f install/kubernetes/istio.yaml
$ kubectl apply -f install/kubernetes/istio-system1.yaml
&lt;/code>&lt;/pre>
&lt;p>会在两个命名空间生成两个 Istio 控制面&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods --all-namespaces
NAMESPACE NAME READY STATUS RESTARTS AGE
istio-system istio-ca-ffbb75c6f-98w6x 1/1 Running 0 15d
istio-system istio-ingress-68d65fc5c6-dnvfl 1/1 Running 0 15d
istio-system istio-mixer-5b9f8dffb5-8875r 3/3 Running 0 15d
istio-system istio-pilot-678fc976c8-b8tv6 2/2 Running 0 15d
istio-system1 istio-ca-5f496fdbcd-lqhlk 1/1 Running 0 15d
istio-system1 istio-ingress-68d65fc5c6-2vldg 1/1 Running 0 15d
istio-system1 istio-mixer-7d4f7b9968-66z44 3/3 Running 0 15d
istio-system1 istio-pilot-5bb6b7669c-779vb 2/2 Running 0 15d
&lt;/code>&lt;/pre>
&lt;p>如果需要 Istio &lt;a href="/v1.8/zh/docs/setup/additional-setup/sidecar-injection/">Sidecar 注入组件&lt;/a>以及&lt;a href="/v1.8/zh/docs/tasks/observability/">遥测组件&lt;/a>，也需要根据租户的命名空间定义，修改所需的 yaml 文件。&lt;/p>
&lt;p>需要由集群管理员、而不是租户自己的管理员来加载这两组 yaml 文件。另外，要把租户管理员的操作权限限制在各自的命名空间内，还需要额外的 RBAC 配置。&lt;/p>
&lt;h3 id="split-common-and-namespace-specific-resources">区分通用资源和命名空间资源&lt;/h3>
&lt;p>Istio 仓库中的清单文件中会创建两种资源，一种是能够被所有 Istio 控制面访问的通用资源，另一种是每个控制平面一份的专属资源。上面所说的在 yaml 文件中替换 &lt;code>istio-system&lt;/code> 命名空间的方法自然是很简单的，更好的一种方法就是把 yaml 文件拆分为两块，一块是所有租户共享的通用部分；另一块就是租户自有的部分。根据 &lt;a href="https://kubernetes.io/docs/concepts/api-extension/custom-resources/#customresourcedefinitions">CRD 资源定义（Custom Resource Definitions）&lt;/a> 中的说法，角色和角色绑定资源需要从 Istio 文件中进行剥离。另外，清单文件中提供的角色和角色绑定的定义可能不适合多租户环境，还需要进一步的细化和定制。&lt;/p>
&lt;h3 id="Kubernetes-rbac-for-Istio-control-plane-resources">Istio 控制面的 Kubernetes RBAC 设置&lt;/h3>
&lt;p>租户管理员应该被限制在单独的 Istio 命名空间中，要完成这个限制，集群管理员需要创建一个清单，其中至少要包含一个 &lt;code>Role&lt;/code> 和 &lt;code>RoleBinding&lt;/code> 的定义，类似下面的文件所示。例子中定义了一个租户管理员，命名为 *sales-admin*，他被限制在命名空间 &lt;code>istio-system1&lt;/code> 之中。完整的清单中可能要在 &lt;code>Role&lt;/code> 中包含更多的 &lt;code>apiGroups&lt;/code> 条目，来定义租户管理员的资源访问能力。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
namespace: istio-system1
name: ns-access-for-sales-admin-istio-system1
rules:
- apiGroups: [&amp;#34;&amp;#34;] # &amp;#34;&amp;#34; 代表核心 API 资源组
resources: [&amp;#34;*&amp;#34;]
verbs: [&amp;#34;*&amp;#34;]
---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
name: access-all-istio-system1
namespace: istio-system1
subjects:
- kind: User
name: sales-admin
apiGroup: rbac.authorization.k8s.io
roleRef:
kind: Role
name: ns-access-for-sales-admin-istio-system1
apiGroup: rbac.authorization.k8s.io
&lt;/code>&lt;/pre>
&lt;h3 id="watching-specific-namespaces-for-service-discovery">关注特定命名空间进行服务发现&lt;/h3>
&lt;p>除了创建 RBAC 规则来限制租户管理员只能访问指定 Istio 控制平面之外，Istio 清单还需要为 Istio Pilot 指定一个用于应用程序的命名空间，以便生成 xDS 缓存。Pilot 组件提供了命令行参数 &lt;code>--appNamespace, ns-1&lt;/code> 可以完成这一任务。&lt;em>ns-1&lt;/em> 就是租户用来部署自己应用的命名空间。&lt;code>istio-system1.yaml&lt;/code> 中包含的相关代码大致如下：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: istio-pilot
namespace: istio-system1
annotations:
sidecar.istio.io/inject: &amp;#34;false&amp;#34;
spec:
replicas: 1
template:
metadata:
labels:
istio: pilot
spec:
serviceAccountName: istio-pilot-service-account
containers:
- name: discovery
image: docker.io/&amp;lt;user ID&amp;gt;/pilot:&amp;lt;tag&amp;gt;
imagePullPolicy: IfNotPresent
args: [&amp;#34;discovery&amp;#34;, &amp;#34;-v&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;--admission-service&amp;#34;, &amp;#34;istio-pilot&amp;#34;, &amp;#34;--appNamespace&amp;#34;, &amp;#34;ns-1&amp;#34;]
ports:
- containerPort: 8080
- containerPort: 443
&lt;/code>&lt;/pre>
&lt;h3 id="deploying-the-tenant-application-in-a-namespace">在特定命名空间中部署租户应用&lt;/h3>
&lt;p>现在集群管理员已经给租户创建了命名空间（&lt;code>istio-system1&lt;/code>），并且对 Istio Pilot 的服务发现进行了配置，要求它关注应用的命名空间（&lt;code>ns-1&lt;/code>），创建应用的 yaml 文件，将其部署到租户的专属命名空间中：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Namespace
metadata:
name: ns-1
&lt;/code>&lt;/pre>
&lt;p>然后把每个资源的命名空间都指定到 &lt;code>ns-1&lt;/code>，例如：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Service
metadata:
name: details
labels:
app: details
namespace: ns-1
&lt;/code>&lt;/pre>
&lt;p>虽然没有展示出来，但是应用的命名空间也应该有 RBAC 设置，用来对特定资源进行访问控制。集群管理员和租户管理员都有权完成这种 RBAC 限制。&lt;/p>
&lt;h3 id="using-in-a-multi-tenant-environment">在多租户环境中使用 &lt;code>istioctl&lt;/code>&lt;/h3>
&lt;p>定义&lt;a href="https://archive.istio.io/v0.7/docs/reference/config/istio.routing.v1alpha1/#RouteRule">路由规则&lt;/a>或者&lt;a href="https://archive.istio.io/v0.7/docs/reference/config/istio.routing.v1alpha1/#DestinationPolicy">目标策略&lt;/a>时，要确认 &lt;code>istioctl&lt;/code> 命令是针对专有的 Istio 控制面所在的命名空间运行的。另外规则自身的定义也要限制在租户的命名空间里，这样才能保证规则在租户自己的网格中生效。&lt;em>-i&lt;/em> 选项用来在 Istio 控制面所属的命名空间中创建（get 和 describe 也一样）规则。&lt;em>-n&lt;/em> 参数会限制规则的所在范围是租户的网格，取值就是租户应用所在的命名空间。如果 yaml 文件中的资源已经指定了范围，&lt;em>-n&lt;/em> 参数会被跳过。&lt;/p>
&lt;p>例如下面的命令会创建到 &lt;code>istio-system1&lt;/code> 命名空间的路由规则：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl –i istio-system1 apply -n ns-1 -f route_rule_v2.yaml
&lt;/code>&lt;/pre>
&lt;p>用下面的命令可以查看：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl -i istio-system1 -n ns-1 get routerule
NAME KIND NAMESPACE
details-Default RouteRule.v1alpha2.config.istio.io ns-1
productpage-default RouteRule.v1alpha2.config.istio.io ns-1
ratings-default RouteRule.v1alpha2.config.istio.io ns-1
reviews-default RouteRule.v1alpha2.config.istio.io ns-1
&lt;/code>&lt;/pre>
&lt;p>&lt;a href="/v1.8/zh/blog/2018/soft-multitenancy/#multiple-Istio-control-planes">Multiple Istio control planes&lt;/a> 中讲述了更多多租户环境下 &lt;code>命名空间&lt;/code> 的相关问题。&lt;/p>
&lt;h3 id="test-results">测试结果&lt;/h3>
&lt;p>根据前文的介绍，一个集群管理员能够创建一个受限于 RBAC 和命名空间的环境，租户管理员能在其中进行部署。&lt;/p>
&lt;p>完成部署后，租户管理员就可以访问指定的 Istio 控制平面的 Pod 了。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods -n istio-system
NAME READY STATUS RESTARTS AGE
grafana-78d649479f-8pqk9 1/1 Running 0 1d
istio-ca-ffbb75c6f-98w6x 1/1 Running 0 1d
istio-ingress-68d65fc5c6-dnvfl 1/1 Running 0 1d
istio-mixer-5b9f8dffb5-8875r 3/3 Running 0 1d
istio-pilot-678fc976c8-b8tv6 2/2 Running 0 1d
istio-sidecar-injector-7587bd559d-5tgk6 1/1 Running 0 1d
prometheus-cf8456855-hdcq7 1/1 Running 0 1d
&lt;/code>&lt;/pre>
&lt;p>然而无法访问全部命名空间的 Pod：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods --all-namespaces
Error from server (Forbidden): pods is forbidden: User &amp;#34;dev-admin&amp;#34; cannot list pods at the cluster scope
&lt;/code>&lt;/pre>
&lt;p>访问其他租户的命名空间也是不可以的：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods -n istio-system1
Error from server (Forbidden): pods is forbidden: User &amp;#34;dev-admin&amp;#34; cannot list pods in the namespace &amp;#34;istio-system1&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>租户管理员能够在租户指定的应用命名空间中进行应用部署。例如可以修改一下 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo&lt;/a> 的 yaml 然后部署到租户的命名空间 &lt;em>ns-0&lt;/em> 中，然后租户管理员就可以在这一命名空间中列出 Pod 了：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods -n ns-0
NAME READY STATUS RESTARTS AGE
details-v1-64b86cd49-b7rkr 2/2 Running 0 1d
productpage-v1-84f77f8747-rf2mt 2/2 Running 0 1d
ratings-v1-5f46655b57-5b4c5 2/2 Running 0 1d
reviews-v1-ff6bdb95b-pm5lb 2/2 Running 0 1d
reviews-v2-5799558d68-b989t 2/2 Running 0 1d
reviews-v3-58ff7d665b-lw5j9 2/2 Running 0 1d
&lt;/code>&lt;/pre>
&lt;p>同样也是不能访问其他租户的应用程序命名空间：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods -n ns-1
Error from server (Forbidden): pods is forbidden: User &amp;#34;dev-admin&amp;#34; cannot list pods in the namespace &amp;#34;ns-1&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>如果部署了&lt;a href="/v1.8/zh/docs/tasks/observability/">遥测组件&lt;/a>, 例如
&lt;a href="/v1.8/zh/docs/tasks/observability/metrics/querying-metrics/">Prometheus&lt;/a>（限制在 Istio 的 &lt;code>namespace&lt;/code>），其中获得的统计结果展示的也只是租户应用命名空间的私有数据。&lt;/p>
&lt;h2 id="conclusion">结语&lt;/h2>
&lt;p>上面的一些尝试表明 Istio 有足够的能力和安全性，符合少量多租户的用例需求。另外也很明显的，Istio 和 Kubernetes &lt;strong>无法&lt;/strong>提供足够的能力和安全性来满足其他的用例，尤其是在租户之间要求完全的安全性和隔离的要求的用例。只有等容器技术（例如 Kubernetes ）能够提供更好的安全模型以及隔离能力，我们才能进一步的增强这方面的支持，Istio 的支持并不是很重要。&lt;/p>
&lt;h2 id="issues">问题&lt;/h2>
&lt;ul>
&lt;li>一个租户（例如，&lt;code>istio-system&lt;/code> 命名空间）的 CA(Certificate Authority) 和 Mixer 的 Pod 中产生的 Log 包含了另一个租户（例如，&lt;code>istio-system1&lt;/code> 命名空间）的控制面的 &lt;code>info&lt;/code> 信息。&lt;/li>
&lt;/ul>
&lt;h2 id="challenges-with-other-multi-tenancy-models">其他多租户模型的挑战&lt;/h2>
&lt;p>还有其他值得考虑的多租户部署模型：&lt;/p>
&lt;ol>
&lt;li>&lt;p>一个网格中运行多个应用程序，每个租户一个应用。集群管理员能控制和监控网格范围内的所有应用，租户管理员只能控制一个特定应用。&lt;/p>&lt;/li>
&lt;li>&lt;p>单独的 Istio 控制平面控制多个网格，每个租户一个网格。集群管理员控制和监控整个 Istio 控制面以及所有网格，租户管理员只能控制特定的网格。&lt;/p>&lt;/li>
&lt;li>&lt;p>一个云环境（集群控制），多个 Kubernetes 控制面（租户控制）&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>这些选项，有的需要改写代码才能支持，有的无法满足用户要求。&lt;/p>
&lt;p>目前的 Istio 能力不适合第一种方案，这是因为其 RBAC 能力无法覆盖这种租户操作。另外在当前的网格模型中，Istio 的配置信息需要传递给 Envoy 代理服务器，多个租户在同一网格内共存的做法非常不安全。&lt;/p>
&lt;p>再看看第二个方式，目前的 Istio 假设每个 Istio 控制面对应一个网格。要支持这种模型需要大量改写。这种情况需要更好的对资源的范围限制进行调整，同时根据命名空间进行安全限制，此外还需要调整 Istio 的 RBAC 模型。这种模式未来可能会支持，但目前来说是不可能的。&lt;/p>
&lt;p>第三个方式对多数案例都是不合适的，毕竟多数集群管理员倾向于将同一个 Kubernetes 控制面作为 &lt;a href="https://en.wikipedia.org/wiki/Platform_as_a_service">PaaS&lt;/a> 提供给他们的租户。&lt;/p>
&lt;h2 id="future-work">未来&lt;/h2>
&lt;p>很明显，单一 Istio 控制面控制多个网格可能是下一个功能。还有可能就是在同一个网格中支持多个租户，并提供某种程度的隔离和安全保障。要完成这样的能力，就需要像 Kubernetes 中对命名空间的的操作那样，在一个单独的控制平面中进行分区，社区中发出了&lt;a href="https://docs.google.com/document/d/14Hb07gSrfVt5KX9qNi7FzzGwB_6WBpAnDpPG6QEEd9Q">这篇文档&lt;/a>来定义其他的用例，以及要支持这些用例所需要的 Istio 功能。&lt;/p>
&lt;h2 id="references">参考&lt;/h2>
&lt;ul>
&lt;li>视频：&lt;a href="https://www.youtube.com/watch?v=ahwCkJGItkU">用 RBAC 和命名空间支持的多租户功能及安全模型&lt;/a>, &lt;a href="https://schd.ws/hosted_files/kccncna17/21/Multi-tenancy%20Support%20%26%20Security%20Modeling%20with%20RBAC%20and%20Namespaces.pdf">幻灯片&lt;/a>.&lt;/li>
&lt;li>&lt;code>Kubecon&lt;/code> 讨论，关于对“协同软性多租户”的支持 &lt;a href="https://www.youtube.com/watch?v=YRR-kZub0cA">Building for Trust: How to Secure Your Kubernetes&lt;/a>.&lt;/li>
&lt;li>Kubernetes &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC 文档&lt;/a>以及&lt;a href="https://kubernetes.io/docs/tasks/administer-cluster/namespaces-walkthrough/">命名空间文档&lt;/a>.&lt;/li>
&lt;li>&lt;code>Kubecon&lt;/code> 幻灯片 &lt;a href="https://schd.ws/hosted_files/kccncna17/a9/kubecon-multitenancy.pdf">Multi-tenancy Deep Dive&lt;/a>.&lt;/li>
&lt;li>Google 文档 &lt;a href="https://docs.google.com/document/d/15w1_fesSUZHv-vwjiYa9vN_uyc--PySRoLKTuDhimjc">Multi-tenancy models for Kubernetes&lt;/a>. (需要授权)&lt;/li>
&lt;li>Cloud Foundry 提出的文档：&lt;a href="https://docs.google.com/document/d/14Hb07gSrfVt5KX9qNi7FzzGwB_6WBpAnDpPG6QEEd9Q">Multi-cloud and Multi-tenancy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.google.com/document/d/12F183NIRAwj2hprx-a-51ByLeNqbJxK16X06vwH5OWE">Istio Auto Multi-Tenancy 101&lt;/a>&lt;/li>
&lt;/ul></description><pubDate>Thu, 19 Apr 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/soft-multitenancy/</link><author>John Joyce 和 Rich Curran</author><guid isPermaLink="true">/v1.8/zh/blog/2018/soft-multitenancy/</guid><category>tenancy</category></item><item><title>用于在生产环境进行测试的 Istio 流量镜像功能</title><description>&lt;p>在非生产/测试环境中，尝试穷举一个服务所有可能的测试用例组合是个令人望而生畏的任务, 在某些情况下，您会发现编写这些用例的所有工作都与实际生产用例不匹配, 理想情况下，我们可以使用实时生产用例和流量来帮助说明我们可能在更人为的测试环境中错过的所测试服务的所有功能区域。&lt;/p>
&lt;p>Istio 可以在这里提供帮助, 随着 &lt;a href="/v1.8/zh/news/releases/0.x/announcing-0.5">Istio 0.5.0&lt;/a> 的发布，Istio 可以镜像流量来帮助测试您的服务, 您可以编写类似于以下内容的路由规则来启用流量镜像：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: config.istio.io/v1alpha2
kind: RouteRule
metadata:
name: mirror-traffic-to-httbin-v2
spec:
destination:
name: httpbin
precedence: 11
route:
- labels:
version: v1
weight: 100
- labels:
version: v2
weight: 0
mirror:
name: httpbin
labels:
version: v2
&lt;/code>&lt;/pre>
&lt;p>这里有几点需要注意：&lt;/p>
&lt;ul>
&lt;li>当流量镜像到不同的服务时，会发生在请求的关键路径之外&lt;/li>
&lt;li>忽略对任何镜像流量的响应; 流量被视为&amp;rdquo;即发即忘”&lt;/li>
&lt;li>必须创建一个权重为 0 的路由，让 Istio 据此通知 Envoy 创建对应的集群定义; &lt;a href="https://github.com/istio/istio/issues/3270">这应该在未来的版本中解决&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>访问&lt;a href="/v1.8/zh/docs/tasks/traffic-management/mirroring/">镜像任务&lt;/a>了解有关镜像的更多信息，并查看更多信息
&lt;a href="https://dzone.com/articles/traffic-shadowing-with-istio-reducing-the-risk-of">在我的博客上综合处理这种情况&lt;/a>.&lt;/p></description><pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/traffic-mirroring/</link><author>Christian Posta</author><guid isPermaLink="true">/v1.8/zh/blog/2018/traffic-mirroring/</guid><category>traffic-management</category><category>mirroring</category></item><item><title>使用外部 TCP 服务</title><description>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">这篇博客在 2018 年 7 月 23 日有修改，修改的内容使用了新的 &lt;a href="/v1.8/zh/blog/2018/v1alpha3-routing/">v1alpha3 流量管理 API&lt;/a>。如果你想使用旧版本 API，请参考&lt;a href="https://archive.istio.io/v0.7/blog/2018/egress-tcp.html">这个文档&lt;/a>。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>在我之前的博客文章&lt;a href="/v1.8/zh/blog/2018/egress-https/">使用外部 Web 服务&lt;/a>中，我描述了如何通过 HTTPS 在网格 Istio 应用程序中使用外部服务，在这篇文章中，我演示了通过 TCP 使用外部服务。你会用到 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Istio Bookinfo 示例应用程序&lt;/a>，这是将书籍评级数据保存在 MySQL 数据库中的版本。你会在集群外部署此数据库并配置 &lt;em>ratings&lt;/em> 服务以使用它，你还会定义&lt;a href="/v1.8/zh/docs/reference/config/networking/service-entry/">服务 Entry&lt;/a> 以允许网格内应用程序访问外部数据库。&lt;/p>
&lt;h2 id="Bookinfo-sample-application-with-external-ratings-database">Bookinfo 示例应用程序与外部评级数据库&lt;/h2>
&lt;p>首先，在 Kubernetes 集群之外设置了一个 MySQL 数据库实例来保存 Bookinfo 评级数据，然后修改 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo 示例应用程序&lt;/a>以使用这个数据库。&lt;/p>
&lt;h3 id="setting-up-the-database-for-ratings-data">为评级数据设置数据库&lt;/h3>
&lt;p>为此，你设置了 &lt;a href="https://www.mysql.com">MySQL&lt;/a> 的实例，你可以使用任何 MySQL 实例; 我使用 &lt;a href="https://www.ibm.com/cloud/compose/mysql">Compose for MySQL&lt;/a>，我使用 &lt;code>mysqlsh&lt;/code>（&lt;a href="https://dev.mysql.com/doc/mysql-shell/en/">MySQL Shell&lt;/a>）作为 MySQL 客户端来提供评级数据。&lt;/p>
&lt;ol>
&lt;li>&lt;p>设置 &lt;code>MYSQL_DB_HOST&lt;/code> 和 &lt;code>MYSQL_DB_PORT&lt;/code> 环境变量。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export MYSQL_DB_HOST=&amp;lt;你的 MySQL host&amp;gt;
$ export MYSQL_DB_PORT=&amp;lt;你的 MySQL port&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>如果你使用的是本地数据库，使用的是默认 MYSQL port，那 &lt;code>host&lt;/code> 和 &lt;code>port&lt;/code> 分别是 &lt;code>localhost&lt;/code> 和 &lt;code>3306&lt;/code>。&lt;/p>&lt;/li>
&lt;li>&lt;p>初始化数据库时，如果出现提示，执行下面的命令输入密码。这个命令通过 &lt;code>admin&lt;/code> 数据库用户凭证来执行。这个 &lt;code>admin&lt;/code> 用户是通过 &lt;a href="https://www.ibm.com/cloud/compose/mysql">Compose for Mysql&lt;/a> 创建数据库时默认存在的。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ curl -s https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/src/mysql/mysqldb-init.sql | mysqlsh --sql --ssl-mode=REQUIRED -u admin -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;strong>或者&lt;/strong>&lt;/em>&lt;/p>
&lt;p>使用 &lt;code>mysql&lt;/code> 客户端和本地 MySQL 数据库时，运行：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ curl -s https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/src/mysql/mysqldb-init.sql | mysql -u root -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>创建一个名为 &lt;code>bookinfo&lt;/code> 的用户，并在 &lt;code>test.ratings&lt;/code> 表上授予它 &lt;em>SELECT&lt;/em> 权限：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysqlsh --sql --ssl-mode=REQUIRED -u admin -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;CREATE USER &amp;#39;bookinfo&amp;#39; IDENTIFIED BY &amp;#39;&amp;lt;password you choose&amp;gt;&amp;#39;; GRANT SELECT ON test.ratings to &amp;#39;bookinfo&amp;#39;;&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;strong>或者&lt;/strong>&lt;/em>&lt;/p>
&lt;p>对于 &lt;code>mysql&lt;/code> 和本地数据库，命令是：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysql -u root -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;CREATE USER &amp;#39;bookinfo&amp;#39; IDENTIFIED BY &amp;#39;&amp;lt;password you choose&amp;gt;&amp;#39;; GRANT SELECT ON test.ratings to &amp;#39;bookinfo&amp;#39;;&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>在这里，你会应用&lt;a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小特权原则&lt;/a>，这意味着不在 Bookinfo 应用程序中使用 &lt;code>admin&lt;/code> 用户。相反，你为应用程序 Bookinfo 创建了一个最小权限的特殊用户 &lt;code>bookinfo&lt;/code>，在这种情况下，&lt;code>bookinfo&lt;/code> 用户只对单个表具有 &lt;code>SELECT&lt;/code> 特权。&lt;/p>
&lt;p>在运行命令创建用户之后，你可能会想通过检查最后一个命令的编号并运行 &lt;code>history -d &amp;lt;创建用户的命令编号&amp;gt;&lt;/code> 来清理我的 bash 历史记录。你可能不希望新用户的密码存储在 bash 历史记录中，如果你使用了 &lt;code>mysql&lt;/code> 命令行工具，记得要删除 &lt;code>~/.mysql_history&lt;/code> 文件中的最后一个命令。在 &lt;a href="https://dev.mysql.com/doc/refman/5.5/en/create-user.html">MySQL 文档&lt;/a>中阅读有关新创建用户的密码保护的更多信息。&lt;/p>&lt;/li>
&lt;li>&lt;p>检查创建的评级，看看一切都按预期工作：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysqlsh --sql --ssl-mode=REQUIRED -u bookinfo -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;select * from test.ratings;&amp;#34;
Enter password:
+----------+--------+
| ReviewID | Rating |
+----------+--------+
| 1 | 5 |
| 2 | 4 |
+----------+--------+
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;strong>或者&lt;/strong>&lt;/em>&lt;/p>
&lt;p>对于 &lt;code>mysql&lt;/code> 和本地数据库：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysql -u bookinfo -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;select * from test.ratings;&amp;#34;
Enter password:
+----------+--------+
| ReviewID | Rating |
+----------+--------+
| 1 | 5 |
| 2 | 4 |
+----------+--------+
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>暂时将评级设置为&lt;code>1&lt;/code>，以便在 Bookinfo &lt;em>ratings&lt;/em> 服务使用我们的数据库时提供可视线索：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysqlsh --sql --ssl-mode=REQUIRED -u admin -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;update test.ratings set rating=1; select * from test.ratings;&amp;#34;
Enter password:
Rows matched: 2 Changed: 2 Warnings: 0
+----------+--------+
| ReviewID | Rating |
+----------+--------+
| 1 | 1 |
| 2 | 1 |
+----------+--------+
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;strong>或&lt;/strong>&lt;/em>&lt;/p>
&lt;p>对于&lt;code>mysql&lt;/code>和本地数据库：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysql -u root -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;update test.ratings set rating=1; select * from test.ratings;&amp;#34;
Enter password:
+----------+--------+
| ReviewID | Rating |
+----------+--------+
| 1 | 1 |
| 2 | 1 |
+----------+--------+
&lt;/code>&lt;/pre>
&lt;p>在最后一个命令中使用了 &lt;code>admin&lt;/code> 用户（和 &lt;code>root&lt;/code> 用于本地数据库），因为 &lt;code>bookinfo&lt;/code> 用户在 &lt;code>test.ratings&lt;/code> 表上没有 &lt;code>UPDATE&lt;/code> 权限。&lt;/p>&lt;/li>
&lt;/ol>
&lt;p>现在你已经可以去部署使用外部数据库的 Bookinfo 应用程序版本了。&lt;/p>
&lt;h3 id="initial-setting-of-Bookinfo-application">Bookinfo 应用程序的初始设置&lt;/h3>
&lt;p>为了演示使用外部数据库的场景，你首先使用安装了 &lt;a href="/v1.8/zh/docs/setup/getting-started/">Istio&lt;/a> 的 Kubernetes 集群，然后部署 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Istio Bookinfo 示例应用程序&lt;/a>、&lt;a href="/v1.8/zh/docs/examples/bookinfo/#apply-default-destination-rules">应用默认的 destination rule&lt;/a> 并&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-control/#change-to-the-blocking-by-default-policy">将 Istio 默认策略修改为禁止 Egress&lt;/a>。&lt;/p>
&lt;p>此应用程序使用 &lt;code>ratings&lt;/code> 微服务来获取书籍评级，评分在 1 到 5 之间。评级显示为每个评论的星号，有几个版本的 &lt;code>ratings&lt;/code> 微服务。有些人使用 &lt;a href="https://www.mongodb.com">MongoDB&lt;/a>，有些使用 &lt;a href="https://www.mysql.com">MySQL&lt;/a> 作为他们的数据库。&lt;/p>
&lt;p>这篇博客例子里的命令是以 Istio 0.8 以上版本为基础的，无论启用或不启用&lt;a href="/v1.8/zh/docs/concepts/security/#mutual-TLS-authentication">双向 TLS&lt;/a>。&lt;/p>
&lt;p>提醒一下，这是 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo 示例应用程序&lt;/a>中应用程序的原始整体架构图。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:59.086918235567985%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/docs/examples/bookinfo/withistio.svg" title="原始的 Bookinfo 应用程序">
&lt;img class="element-to-stretch" src="/v1.8/zh/docs/examples/bookinfo/withistio.svg" alt="原始的 Bookinfo 应用程序" />
&lt;/a>
&lt;/div>
&lt;figcaption>原始的 Bookinfo 应用程序&lt;/figcaption>
&lt;/figure>
&lt;h3 id="use-the-database-for-ratings-data-in-Bookinfo-application">将数据库用于 Bookinfo 应用程序中的评级数据&lt;/h3>
&lt;ol>
&lt;li>&lt;p>修改使用 MySQL 数据库的 &lt;em>ratings&lt;/em> 服务版本的 &lt;code>deployment spec&lt;/code>，以使用你的数据库实例。该 &lt;code>spec&lt;/code> 位于 Istio 发行档案的 &lt;a href="https://github.com/istio/istio/blob/release-1.8/samples/bookinfo/platform/kube/bookinfo-ratings-v2-mysql.yaml">&lt;code>samples/bookinfo/platform/kube/bookinfo-ratings-v2-mysql.yaml&lt;/code>&lt;/a> 中。编辑以下几行：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >- name: MYSQL_DB_HOST
value: mysqldb
- name: MYSQL_DB_PORT
value: &amp;#34;3306&amp;#34;
- name: MYSQL_DB_USER
value: root
- name: MYSQL_DB_PASSWORD
value: password
&lt;/code>&lt;/pre>
&lt;p>替换上面代码段中的值，指定数据库主机，端口，用户和密码，请注意，在 Kubernetes 中使用容器环境变量中密码的正确方法是 &lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-environment-variables">使用 secret&lt;/a>，仅对于此示例任务，你可能会在 deployment spec 中直接配置明文的密码，&lt;strong>切记！不要在真实环境中这样做&lt;/strong>！我想你们应该也知道，&lt;code>&amp;quot;password&amp;quot;&lt;/code> 这个值也不应该用作密码。&lt;/p>&lt;/li>
&lt;li>&lt;p>应用修改后的 &lt;code>spec&lt;/code> 来部署使用外部数据库的 &lt;em>ratings&lt;/em> 服务，&lt;em>v2-mysql&lt;/em> 的版本。&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-ratings-v2-mysql.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/platform/kube/bookinfo-ratings-v2-mysql.yaml@
deployment &amp;#34;ratings-v2-mysql&amp;#34; created
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>将发往 &lt;em>reviews&lt;/em> 服务的所有流量路由到 &lt;em>v3&lt;/em> 版本，这样做是为了确保 &lt;em>reviews&lt;/em> 服务始终调用 &lt;em>ratings&lt;/em> 服务，此外，将发往 &lt;em>ratings&lt;/em> 服务的所有流量路由到使用外部数据库的 _ratings v2-mysql_。&lt;/p>
&lt;p>通过添加两个&lt;a href="/v1.8/zh/docs/reference/config/networking/virtual-service/">虚拟服务(virtual service)&lt;/a>，可以为上述两种服务指定路由。这些虚拟服务在 Istio 发行档案的 &lt;code>samples/bookinfo/networking/virtual-service-ratings-mysql.yaml&lt;/code> 中指定。
&lt;strong>&lt;em>注意：&lt;/em>&lt;/strong> 确保你在完成了&lt;a href="/v1.8/zh/docs/examples/bookinfo/#apply-default-destination-rules">添加默认目标路由&lt;/a>才执行下面的命令。&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-ratings-mysql.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/networking/virtual-service-ratings-mysql.yaml@
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>更新的架构如下所示，请注意，网格内的蓝色箭头标记根据我们添加的虚拟服务配置的流量，根据虚拟服务的定义，流量将发送到 &lt;em>reviews v3&lt;/em> 和 &lt;em>ratings v2-mysql&lt;/em> 。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:59.314858206480224%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-tcp/bookinfo-ratings-v2-mysql-external.svg" title="Bookinfo 应用程序，其评级为 v2-mysql，外部为 MySQL 数据库">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-tcp/bookinfo-ratings-v2-mysql-external.svg" alt="Bookinfo 应用程序，其评级为 v2-mysql，外部为 MySQL 数据库" />
&lt;/a>
&lt;/div>
&lt;figcaption>Bookinfo 应用程序，其评级为 v2-mysql，外部为 MySQL 数据库&lt;/figcaption>
&lt;/figure>
&lt;p>请注意，MySQL 数据库位于 Istio 服务网格之外，或者更准确地说是在 Kubernetes 集群之外，服务网格的边界由虚线标记。&lt;/p>
&lt;h3 id="access-the-webpage">访问网页&lt;/h3>
&lt;p>在&lt;a href="/v1.8/zh/docs/examples/bookinfo/#determine-the-ingress-IP-and-port">确定入口 IP 和端口&lt;/a>之后，访问应用程序的网页。&lt;/p>
&lt;p>你会发现问题，在每次审核下方都会显示消息 &lt;em>&amp;ldquo;Ratings service is currently unavailable”&lt;/em> 而不是评级星标。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:36.18705035971223%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-tcp/errorFetchingBookRating.png" title="Ratings 服务的错误信息">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-tcp/errorFetchingBookRating.png" alt="Ratings 服务的错误信息" />
&lt;/a>
&lt;/div>
&lt;figcaption>Ratings 服务的错误信息&lt;/figcaption>
&lt;/figure>
&lt;p>与&lt;a href="/v1.8/zh/blog/2018/egress-https/">使用外部 Web 服务&lt;/a>一样，你会体验到&lt;strong>优雅的服务降级&lt;/strong>，这很好，虽然 &lt;em>ratings&lt;/em> 服务中有错误，但是应用程序并没有因此而崩溃，应用程序的网页正确显示了书籍信息，详细信息和评论，只是没有评级星。&lt;/p>
&lt;p>你遇到的问题与&lt;a href="/v1.8/zh/blog/2018/egress-https/">使用外部 Web 服务&lt;/a>中的问题相同，即 Kubernetes 集群外的所有流量（TCP 和 HTTP）都被 sidecar 代理默认阻止，要为 TCP 启用此类流量，必须定义 TCP 的网格外部服务入口。&lt;/p>
&lt;h3 id="mesh-external-service-entry-for-an-external-MySQL-instance">外部 MySQL 实例的网格外部服务入口&lt;/h3>
&lt;p>&amp;ldquo;TCP 网格外部服务入口&amp;rdquo;功能可以解决上面的问题。&lt;/p>
&lt;ol>
&lt;li>&lt;p>获取你的 MySQL 数据库事例的 IP 地址，作为参考，你可以通过 &lt;a href="https://linux.die.net/man/1/host">host&lt;/a> 命令实现：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ export MYSQL_DB_IP=$(host $MYSQL_DB_HOST | grep &amp;#34; has address &amp;#34; | cut -d&amp;#34; &amp;#34; -f4)
&lt;/code>&lt;/pre>
&lt;p>如果是本地数据库，设置 &lt;code>MYSQL_DB_IP&lt;/code> 环境变量为你的本机 IP，保证这个环境变量能被集群访问到。&lt;/p>&lt;/li>
&lt;li>&lt;p>定义一个网格外部服务入口：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: mysql-external
spec:
hosts:
- $MYSQL_DB_HOST
addresses:
- $MYSQL_DB_IP/32
ports:
- name: tcp
number: $MYSQL_DB_PORT
protocol: tcp
location: MESH_EXTERNAL
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>检查你刚刚新增的服务入口，确保它的值是正确的&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get serviceentry mysql-external -o yaml
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
...
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;p>请注意，对于 TCP 服务入口，将 &lt;code>tcp&lt;/code> 指定为入口 &amp;ldquo;port&amp;rdquo; 的 &amp;ldquo;protocol&amp;rdquo; 的值，另请注意，要在 &amp;ldquo;addresses&amp;rdquo; 列表里面指定外部服务的 IP 地址，作为一个 &lt;code>32&lt;/code> 为后缀的 &lt;a href="https://tools.ietf.org/html/rfc2317">CIDR&lt;/a> 块。&lt;/p>
&lt;p>&lt;a href="#service-entries-for-tcp-traffic">下面&lt;/a>我将详细讨论 TCP 服务入口。现在先来验证我们添加的出口规则是否解决了问题。访问网页看看评星是否回来了。&lt;/p>
&lt;p>有效！访问应用程序的网页会显示评级而不会出现错误：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:36.69064748201439%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-tcp/externalMySQLRatings.png" title="Book Ratings 显示正常">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-tcp/externalMySQLRatings.png" alt="Book Ratings 显示正常" />
&lt;/a>
&lt;/div>
&lt;figcaption>Book Ratings 显示正常&lt;/figcaption>
&lt;/figure>
&lt;p>请注意，正如预期的那样，你会看到两个显示评论的一星评级。将评级更改为一颗星，为我们提供了一个视觉线索，确实使用了我们的外部数据库。&lt;/p>
&lt;p>与 HTTP/HTTPS 的服务入口一样，你可以动态地使用 &lt;code>kubectl&lt;/code> 删除和创建 TCP 的服务入口。&lt;/p>
&lt;h2 id="motivation-for-egress-TCP-traffic-control">出口 TCP 流量控制的动机&lt;/h2>
&lt;p>一些网内 Istio 应用程序必须访问外部服务，例如遗留系统，在许多情况下，不通过 HTTP 或 HTTPS 协议执行访问，使用其他 TCP 协议，例如 &lt;a href="https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/">MongoDB Wire 协议&lt;/a>和 &lt;a href="https://dev.mysql.com/doc/internals/en/client-server-protocol.html">MySQL 客户端/服务器协议&lt;/a>等特定于数据库的协议，与外部数据库通信。&lt;/p>
&lt;p>接下来我会再说说 TCP 流量的服务入口。&lt;/p>
&lt;h2 id="service-entries-for-tcp-traffic">TCP 流量的服务入口&lt;/h2>
&lt;p>启用到特定端口的 TCP 流量的服务入口必须指定 &lt;code>TCP&lt;/code> 作为端口的协议，此外，对于 &lt;a href="https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/">MongoDB Wire 协议&lt;/a>，协议可以指定为 &lt;code>MONGO&lt;/code>，而不是 &lt;code>TCP&lt;/code>。&lt;/p>
&lt;p>对于服务入口配置的 &lt;code>addresses&lt;/code> 字段，必须使用 &lt;a href="https://tools.ietf.org/html/rfc2317">CIDR&lt;/a> 表示法中的 IP 块。注意在 TCP 服务入口配置中，&lt;code>host&lt;/code> 字段会被忽略。&lt;/p>
&lt;p>要通过其主机名启用到外部服务的 TCP 流量，必须指定主机名的所有 IP，每个 IP 必须由 CIDR 块指定。&lt;/p>
&lt;p>请注意，外部服务的所有 IP 并不总是已知。要往外发送 TCP 流量，只能配置为被应用程序使用的 IP。&lt;/p>
&lt;p>另请注意，外部服务的 IP 并不总是静态的，例如在 &lt;a href="https://en.wikipedia.org/wiki/Content_delivery_network">CDN&lt;/a> 的情况下，有时 IP 在大多数情况下是静态的，但可以不时地更改，例如由于基础设施的变化。在这些情况下，如果已知可能 IP 的范围，则应通过 CIDR 块指定范围。如果不知道可能的 IP 的范围，则不能使用 TCP 服务入口，并且&lt;a href="/v1.8/zh/docs/tasks/traffic-management/egress/egress-control/#direct-access-to-external-services">必须直接调用外部服务&lt;/a>，绕过 sidecar 代理。&lt;/p>
&lt;h2 id="relation-to-virtual-machines-support">与网格扩展的关系&lt;/h2>
&lt;p>请注意，本文中描述的场景与&lt;a href="/v1.8/zh/docs/examples/virtual-machines/bookinfo/">集成虚拟机&lt;/a>示例中描述的网格扩展场景不同。在这种情况下，MySQL 实例在与 Istio 服务网格集成的外部（集群外）机器（裸机或 VM）上运行 ，MySQL 服务成为网格的一等公民，具有 Istio 的所有有益功能，除此之外，服务可以通过本地集群域名寻址，例如通过 &lt;code>mysqldb.vm.svc.cluster.local&lt;/code>，并且可以通过&lt;a href="/v1.8/zh/docs/concepts/security/#mutual-TLS-authentication">双向 TLS 身份验证&lt;/a>保护与它的通信，无需创建服务入口来访问此服务; 但是，该服务必须在 Istio 注侧，要启用此类集成，必须在计算机上安装 Istio 组件（&lt;em>Envoy proxy&lt;/em> ，&lt;em>node-agent&lt;/em> ，&lt;code>_istio-agent_&lt;/code> ），并且必须可以从中访问 Istio 控制平面（&lt;em>Pilot&lt;/em> ，&lt;em>Mixer&lt;/em> ，&lt;em>Citadel&lt;/em> ）。有关详细信息，请参阅 &lt;a href="/v1.8/zh/docs/examples/virtual-machines/">Istio VM 相关&lt;/a>。&lt;/p>
&lt;p>在这个的示例中，MySQL 实例可以在任何计算机上运行，也可以由云提供商作为服务进行配置，无需集成机器
与 Istio ，无需从机器访问 Istio 控制平面，在使用 MySQL 作为服务的情况下，运行 MySQL 的计算机可能无法访问，并且可能无法在其上安装必需的组件。在这个的例子中，MySQL 实例可以通过其全局域名进行寻址，如果消费应用程序希望使用该域名，这可能是有益的，当在消费应用程序的部署配置中无法更改预期的域名时，这尤其重要。&lt;/p>
&lt;h2 id="cleanup">清理&lt;/h2>
&lt;ol>
&lt;li>&lt;p>删除 &lt;code>test&lt;/code> 数据库和 &lt;code>bookinfo&lt;/code> 用户：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysqlsh --sql --ssl-mode=REQUIRED -u admin -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;drop database test; drop user bookinfo;&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>&lt;em>&lt;strong>或者&lt;/strong>&lt;/em>&lt;/p>
&lt;p>对于&lt;code>mysql&lt;/code>和本地数据库：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ mysql -u root -p --host $MYSQL_DB_HOST --port $MYSQL_DB_PORT -e &amp;#34;drop database test; drop user bookinfo;&amp;#34;
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>删除虚拟服务：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-ratings-mysql.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete -f @samples/bookinfo/networking/virtual-service-ratings-mysql.yaml@
Deleted config: virtual-service/default/reviews
Deleted config: virtual-service/default/ratings
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>取消部署 &lt;em>ratings v2-mysql&lt;/em> ：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-ratings-v2-mysql.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete -f @samples/bookinfo/platform/kube/bookinfo-ratings-v2-mysql.yaml@
deployment &amp;#34;ratings-v2-mysql&amp;#34; deleted
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>删除服务入口：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry mysql-external -n default
Deleted config: serviceentry mysql-external
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ol>
&lt;h2 id="conclusion">结论&lt;/h2>
&lt;p>在这篇博文中，我演示了 Istio 服务网格中的微服务如何通过 TCP 使用外部服务，默认情况下，Istio 会阻止所有流量（TCP 和 HTTP）到集群外的主机，要为 TCP 启用此类流量，必须为服务网格创建 TCP 网格外部服务入口。&lt;/p></description><pubDate>Tue, 06 Feb 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/egress-tcp/</link><author>Vadim Eisenberg</author><guid isPermaLink="true">/v1.8/zh/blog/2018/egress-tcp/</guid><category>traffic-management</category><category>egress</category><category>tcp</category></item><item><title>使用外部 Web 服务</title><description>
&lt;p>在许多情况下，在 &lt;em>service mesh&lt;/em> 中的微服务序并不是应用程序的全部，有时，
网格内部的微服务需要使用在服务网格外部的遗留系统提供的功能，虽然我们希望逐步将这些系统迁移到服务网格中。
但是在迁移这些系统之前，必须让服务网格内的应用程序能访问它们。还有其他情况，
应用程序使用外部组织提供的 Web 服务，通常是通过万维网提供的服务。&lt;/p>
&lt;p>在这篇博客文章中，我修改了 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Istio Bookinfo 示例应用程序&lt;/a>让它可以
从外部 Web 服务（&lt;a href="https://developers.google.com/books/docs/v1/getting_started">Google Books APIs&lt;/a> ）获取图书详细信息。
我将展示如何使用 &lt;em>mesh-external service entries&lt;/em> 在 Istio 中启用外部 HTTPS 流量。最后，
我解释了当前与 Istio 出口流量控制相关的问题。&lt;/p>
&lt;h2 id="initial-setting">初始设定&lt;/h2>
&lt;p>为了演示使用外部 Web 服务的场景，我首先使用安装了 &lt;a href="/v1.8/zh/docs/setup/getting-started/">Istio&lt;/a> 的
Kubernetes 集群, 然后我部署 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Istio Bookinfo 示例应用程序&lt;/a>,
此应用程序使用 &lt;em>details&lt;/em> 微服务来获取书籍详细信息，例如页数和发布者, 原始 &lt;em>details&lt;/em> 微服务提供书籍
详细信息，无需咨询任何外部服务。&lt;/p>
&lt;p>此博客文章中的示例命令适用于 Istio 1.0+，无论启用或不启用&lt;a href="/v1.8/zh/docs/concepts/security/#mutual-TLS-authentication">双向 TLS&lt;/a>。
Bookinfo 配置文件位于 Istio 发行存档的 &lt;code>samples/bookinfo&lt;/code> 目录中。&lt;/p>
&lt;p>以下是原始 &lt;a href="/v1.8/zh/docs/examples/bookinfo/">Bookinfo 示例应用程序&lt;/a>中应用程序端到端体系结构的副本。&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:59.086918235567985%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/docs/examples/bookinfo/withistio.svg" title="原 Bookinfo 应用程序">
&lt;img class="element-to-stretch" src="/v1.8/zh/docs/examples/bookinfo/withistio.svg" alt="原 Bookinfo 应用程序" />
&lt;/a>
&lt;/div>
&lt;figcaption>原 Bookinfo 应用程序&lt;/figcaption>
&lt;/figure>
&lt;p>执行&lt;a href="/v1.8/zh/docs/examples/bookinfo/#deploying-the-application">部署应用程序&lt;/a>、&lt;a href="/v1.8/zh/docs/examples/bookinfo/#confirm-the-app-is-accessible-from-outside-the-cluster">确认应用正在运行&lt;/a>，以及
&lt;a href="/v1.8/zh/docs/examples/bookinfo/#apply-default-destination-rules">应用默认目标规则&lt;/a>中的步骤部分。&lt;/p>
&lt;h3 id="Bookinfo-with-https-access-to-a-google-books-web-service">Bookinfo 使用 HTTPS 访问 Google 图书网络服务&lt;/h3>
&lt;p>让我们添加一个新版本的 &lt;em>details&lt;/em> 微服务，_v2_，从 &lt;a href="https://developers.google.com/books/docs/v1/getting_started">Google Books APIs&lt;/a> 中获取图书详细信息。
它设定了服务容器的 &lt;code>DO_NOT_ENCRYPT&lt;/code> 环境变量为 &lt;code>false&lt;/code>。此设置将指示已部署服务使用 HTTPS（而不是 HTTP ）来访问外部服务。&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-details-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/platform/kube/bookinfo-details-v2.yaml@ --dry-run -o yaml | kubectl set env --local -f - &amp;#39;DO_NOT_ENCRYPT=false&amp;#39; -o yaml | kubectl apply -f -
&lt;/code>&lt;/pre>&lt;/div>
&lt;p>现在，应用程序的更新架构如下所示：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:65.1654485092242%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-https/bookinfo-details-v2.svg" title="Bookinfo 的 details V2 应用程序">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-https/bookinfo-details-v2.svg" alt="Bookinfo 的 details V2 应用程序" />
&lt;/a>
&lt;/div>
&lt;figcaption>Bookinfo 的 details V2 应用程序&lt;/figcaption>
&lt;/figure>
&lt;p>请注意，Google Book 服务位于 Istio 服务网格之外，其边界由虚线标记。&lt;/p>
&lt;p>现在让我们将指向 &lt;em>details&lt;/em> 微服务的所有流量定向到 _details v2_：&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-details-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/networking/virtual-service-details-v2.yaml@
&lt;/code>&lt;/pre>&lt;/div>
&lt;p>请注意，&lt;code>VirtualService&lt;/code> 依赖于您在&lt;a href="/v1.8/zh/docs/examples/bookinfo/#apply-default-destination-rules">应用默认目标规则&lt;/a>部分中创建的目标规则。&lt;/p>
&lt;p>在&lt;a href="/v1.8/zh/docs/examples/bookinfo/#determine-the-ingress-IP-and-port">确定 ingress 的 IP 和端口&lt;/a>之后，
让我们访问应用程序的网页。&lt;/p>
&lt;p>糟糕&amp;hellip; 页面显示 _Error fetching product details_，而不是书籍详细信息：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:36.18649965205289%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-https/errorFetchingBookDetails.png" title="获取产品详细信息的错误消息">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-https/errorFetchingBookDetails.png" alt="获取产品详细信息的错误消息" />
&lt;/a>
&lt;/div>
&lt;figcaption>获取产品详细信息的错误消息&lt;/figcaption>
&lt;/figure>
&lt;p>好消息是我们的应用程序没有崩溃, 通过良好的微服务设计，我们没有让&lt;strong>故障扩散&lt;/strong>。在我们的例子中，
失败的 &lt;em>details&lt;/em> 微服务不会导致 &lt;code>productpage&lt;/code> 微服务失败, 尽管 &lt;em>details&lt;/em> 微服务失败，
仍然提供了应用程序的大多数功能, 我们有&lt;strong>优雅的服务降级&lt;/strong>：正如您所看到的，评论和评级正确显示，
应用程序仍然有用。&lt;/p>
&lt;p>那可能出了什么问题？啊&amp;hellip;&amp;hellip; 答案是我忘了启用从网格内部到外部服务的流量，在本例中是 Google Book Web 服务。
默认情况下，Istio sidecar 代理（&lt;a href="https://www.envoyproxy.io">Envoy proxies&lt;/a>）
&lt;strong>阻止到集群外目的地的所有流量&lt;/strong>, 要启用此类流量，我们必须定义 &lt;a href="/v1.8/zh/docs/reference/config/networking/service-entry/">mesh-external service entry&lt;/a>。&lt;/p>
&lt;h3 id="enable-https-access-to-a-google-books-web-service">启用对 Google Books 网络服务的 HTTPS 访问&lt;/h3>
&lt;p>不用担心，让我们定义&lt;strong>网格外部 &lt;code>ServiceEntry&lt;/code>&lt;/strong> 并修复我们的应用程序。您还必须定义 &lt;em>virtual
service&lt;/em> 使用 &lt;a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI&lt;/a> 对外部服务执行路由。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: googleapis
spec:
hosts:
- www.googleapis.com
ports:
- number: 443
name: https
protocol: HTTPS
location: MESH_EXTERNAL
resolution: DNS
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: googleapis
spec:
hosts:
- www.googleapis.com
tls:
- match:
- port: 443
sni_hosts:
- www.googleapis.com
route:
- destination:
host: www.googleapis.com
port:
number: 443
weight: 100
EOF
&lt;/code>&lt;/pre>
&lt;p>现在访问应用程序的网页会显示书籍详细信息而不会出现错误：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:34.82831114225648%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-https/externalBookDetails.png" title="正确显示书籍详细信息">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-https/externalBookDetails.png" alt="正确显示书籍详细信息" />
&lt;/a>
&lt;/div>
&lt;figcaption>正确显示书籍详细信息&lt;/figcaption>
&lt;/figure>
&lt;p>您可以查询您的 &lt;code>ServiceEntry&lt;/code> ：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get serviceentries
NAME AGE
googleapis 8m
&lt;/code>&lt;/pre>
&lt;p>您可以删除您的 &lt;code>ServiceEntry&lt;/code> ：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry googleapis
serviceentry &amp;#34;googleapis&amp;#34; deleted
&lt;/code>&lt;/pre>
&lt;p>并在输出中看到删除了 &lt;code>ServiceEntry&lt;/code>。&lt;/p>
&lt;p>删除 &lt;code>ServiceEntry&lt;/code> 后访问网页会产生我们之前遇到的相同错误，即 &lt;em>Error fetching product details&lt;/em>,
正如我们所看到的，与许多其他 Istio 配置一样，&lt;code>ServiceEntry&lt;/code> 是&lt;strong>动态定义&lt;/strong>的 , Istio 运算符可以动态决定
它们允许微服务访问哪些域, 他们可以动态启用和禁用外部域的流量，而无需重新部署微服务。&lt;/p>
&lt;h3 id="cleanup-of-https-access-to-a-google-books-web-service">清除对 Google 图书网络服务的 HTTPS 访问权限&lt;/h3>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-details-v2.yaml'>Zip&lt;/a>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-details-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry googleapis
$ kubectl delete virtualservice googleapis
$ kubectl delete -f @samples/bookinfo/networking/virtual-service-details-v2.yaml@
$ kubectl delete -f @samples/bookinfo/platform/kube/bookinfo-details-v2.yaml@
&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="TLS-origination-by-Istio">由 Istio 发起的 TLS&lt;/h2>
&lt;p>这个故事有一个警告。假设您要监视您的微服务使用 &lt;a href="https://developers.google.com/apis-explorer/">Google API&lt;/a> 的哪个特定集
（&lt;a href="https://developers.google.com/books/docs/v1/getting_started">书籍&lt;/a>，&lt;a href="https://developers.google.com/calendar/">日历&lt;/a>，&lt;a href="https://developers.google.com/tasks/">任务&lt;/a>等）
假设您要强制执行仅允许使用&lt;a href="https://developers.google.com/books/docs/v1/getting_started">图书 API&lt;/a> 的策略。
假设您要监控您的微服务访问的标识符。对于这些监视和策略任务，您需要知道 URL 路径。
考虑例如 URL &lt;a href="https://www.googleapis.com/books/v1/volumes?q=isbn:0486424618">&lt;code>www.googleapis.com/books/v1/volumes?q=isbn:0486424618&lt;/code>&lt;/a>。
在该网址中，路径段指定了&lt;a href="https://developers.google.com/books/docs/v1/getting_started">图书 API&lt;/a>
&lt;code>/books&lt;/code> 和路径段的 &lt;a href="https://en.wikipedia.org/wiki/International_Standard_Book_Number">ISBN&lt;/a> 代码
&lt;code>/volumes?q=isbn:0486424618&lt;/code>。但是，在 HTTPS 中，所有 HTTP 详细信息（主机名，路径，标头等）都是加密的
sidecar 代理的这种监督和策略执行是无法实现的。Istio 只能通过 &lt;a href="https://tools.ietf.org/html/rfc3546#section-3.1">SNI&lt;/a>（_Server Name Indication_）得知加密请求中的主机名称，在这里就是 &lt;code>www.googleapis.com&lt;/code>。&lt;/p>
&lt;p>为了允许 Istio 基于域执行出口请求的过滤，微服务必须发出 HTTP 请求, 然后，Istio 打开到目标的 HTTPS 连接（执行 TLS 发起）,
根据微服务是在 Istio 服务网格内部还是外部运行，
微服务的代码必须以不同方式编写或以不同方式配置, 这与&lt;a href="/v1.8/zh/docs/ops/deployment/architecture/#design-goals">最大化透明度&lt;/a>
的 Istio 设计目标相矛盾, 有时我们需要妥协&amp;hellip;&amp;hellip;&lt;/p>
&lt;p>下图显示了如何执行外部服务的 HTTPS 流量, 在顶部，Istio 服务网格外部的微服务发送常规 HTTPS 请求，
端到端加密, 在底部，Istio 服务网格内的相同微服务必须在 pod 内发送未加密的 HTTP 请求，
这些请求被 sidecar Envoy 代理拦截 , sidecar 代理执行 TLS 发起，因此 pod 和外部服务之间的流量被加密。&lt;/p>
&lt;figure style="width:60%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:95.1355088590701%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2018/egress-https/https_from_the_app.svg" title="对外发起 HTTPS 流量的两种方式：微服务自行发起，或由 Sidecar 代理发起">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2018/egress-https/https_from_the_app.svg" alt="对外发起 HTTPS 流量的两种方式：微服务自行发起，或由 Sidecar 代理发起" />
&lt;/a>
&lt;/div>
&lt;figcaption>对外发起 HTTPS 流量的两种方式：微服务自行发起，或由 Sidecar 代理发起&lt;/figcaption>
&lt;/figure>
&lt;p>以下是我们如何在 &lt;a href="https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/src/details/details.rb">Bookinfo 的 details 微服务代码&lt;/a>
中使用 Ruby &lt;a href="https://docs.ruby-lang.org/en/2.0.0/Net/HTTP.html">net/http 模块&lt;/a>：&lt;/p>
&lt;pre>&lt;code class='language-ruby' data-expandlinks='true' data-repo='istio' >uri = URI.parse(&amp;#39;https://www.googleapis.com/books/v1/volumes?q=isbn:&amp;#39; + isbn)
http = Net::HTTP.new(uri.host, ENV[&amp;#39;DO_NOT_ENCRYPT&amp;#39;] === &amp;#39;true&amp;#39; ? 80:443)
...
unless ENV[&amp;#39;DO_NOT_ENCRYPT&amp;#39;] === &amp;#39;true&amp;#39; then
http.use_ssl = true
end
&lt;/code>&lt;/pre>
&lt;p>当定义 &lt;code>WITH_ISTIO&lt;/code> 环境变量时，在没有 SSL（普通 HTTP ）的情况下请求会通过 80 端口执行。&lt;/p>
&lt;p>我们将 &lt;a href="https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-details-v2.yaml">details v2 的部署配置文件&lt;/a> 的环境变量 &lt;code>DO_NOT_ENCRYPT&lt;/code> 设置为 _&amp;ldquo;true&amp;rdquo;_。
&lt;code>container&lt;/code> 部分：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >env:
- name: DO_NOT_ENCRYPT
value: &amp;#34;true&amp;#34;
&lt;/code>&lt;/pre>
&lt;p>在下一节中，您将配置 TLS 发起以访问外部 Web 服务。&lt;/p>
&lt;h2 id="Bookinfo-with-TLS-origination-to-a-google-books-web-service">具有 TLS 的 Bookinfo 起源于 Google Books 网络服务&lt;/h2>
&lt;ol>
&lt;li>&lt;p>部署 &lt;em>details v2&lt;/em> 版本，将 HTTP 请求发送到 &lt;a href="https://developers.google.com/books/docs/v1/getting_started">Google Books API&lt;/a>。
在 &lt;a href="https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-details-v2.yaml">&lt;code>bookinfo-details-v2.yaml&lt;/code>&lt;/a> 中，
&lt;code>DO_NOT_ENCRYPT&lt;/code> 变量设置为 true。&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-details-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/platform/kube/bookinfo-details-v2.yaml@
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>将指向 &lt;em>details&lt;/em> 微服务的流量定向到 _details v2_。&lt;/p>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-details-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f @samples/bookinfo/networking/virtual-service-details-v2.yaml@
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>&lt;p>为 &lt;code>www.google.apis&lt;/code> 创建网格外部 &lt;code>ServiceEntry&lt;/code>，virtual service 将目标端口从 80 重写为 443，并执行 TLS 的 &lt;code>destination rule&lt;/code>。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: ServiceEntry
metadata:
name: googleapis
spec:
hosts:
- www.googleapis.com
ports:
- number: 80
name: http
protocol: HTTP
- number: 443
name: https
protocol: HTTPS
resolution: DNS
---
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: rewrite-port-for-googleapis
spec:
hosts:
- www.googleapis.com
http:
- match:
- port: 80
route:
- destination:
host: www.googleapis.com
port:
number: 443
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: originate-tls-for-googleapis
spec:
host: www.googleapis.com
trafficPolicy:
loadBalancer:
simple: ROUND_ROBIN
portLevelSettings:
- port:
number: 443
tls:
mode: SIMPLE # 访问 edition.cnn.com 时启动 HTTPS
EOF
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>&lt;p>访问应用程序的网页，并验证显示的书籍详细信息没有错误。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="/v1.8/zh/docs/tasks/observability/logs/access-log/#enable-envoy-s-access-logging">开启 Envoy 访问记录功能&lt;/a>&lt;/p>&lt;/li>
&lt;li>&lt;p>检查 &lt;em>details v2&lt;/em> 的 sidecar 代理的日志，并查看 HTTP 请求。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl logs $(kubectl get pods -l app=details -l version=v2 -o jsonpath=&amp;#39;{.items[0].metadata.name}&amp;#39;) istio-proxy | grep googleapis
[2018-08-09T11:32:58.171Z] &amp;#34;GET /books/v1/volumes?q=isbn:0486424618 HTTP/1.1&amp;#34; 200 - 0 1050 264 264 &amp;#34;-&amp;#34; &amp;#34;Ruby&amp;#34; &amp;#34;b993bae7-4288-9241-81a5-4cde93b2e3a6&amp;#34; &amp;#34;www.googleapis.com:80&amp;#34; &amp;#34;172.217.20.74:80&amp;#34;
EOF
&lt;/code>&lt;/pre>
&lt;p>请注意日志中的 URL 路径，可以监视路径并根据它来应用访问策略。要了解有关 HTTP 出口流量的监控和访问策略
的更多信息，请查看&lt;a href="https://archive.istio.io/v0.8/blog/2018/egress-monitoring-access-control/#logging">归档博客之出口流量监控之日志&lt;/a>。&lt;/p>&lt;/li>
&lt;/ol>
&lt;h3 id="cleanup-of-TLS-origination-to-a-google-books-web-service">清除 TLS 原始数据到 Google Books 网络服务&lt;/h3>
&lt;div>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/platform/kube/bookinfo-details-v2.yaml'>Zip&lt;/a>&lt;a data-skipendnotes='true' style='display:none' href='https://raw.githubusercontent.com/istio/istio/release-1.8/samples/bookinfo/networking/virtual-service-details-v2.yaml'>Zip&lt;/a>&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl delete serviceentry googleapis
$ kubectl delete virtualservice rewrite-port-for-googleapis
$ kubectl delete destinationrule originate-tls-for-googleapis
$ kubectl delete -f @samples/bookinfo/networking/virtual-service-details-v2.yaml@
$ kubectl delete -f @samples/bookinfo/platform/kube/bookinfo-details-v2.yaml@
&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="relation-to-Istio-mutual-TLS">Istio 双向 TLS 的关系&lt;/h3>
&lt;p>请注意，在这种情况下，TLS 的源与 Istio 应用的&lt;a href="/v1.8/zh/docs/concepts/security/#mutual-TLS-authentication">双向 TLS&lt;/a> 无关,
无论 Istio 双向 TLS 是否启用，外部服务的 TLS 源都将起作用 , 保证服务网&lt;strong>内&lt;/strong>的服务到服务通信，
并为每个服务提供强大的身份认证, 在此博客文章中的 &lt;strong>外部服务&lt;/strong>的情况下，我们有&lt;strong>单向&lt;/strong> TLS，
这是用于保护 Web 浏览器和 Web 服务器之间通信的相同机制 , TLS 应用于与外部服务的通信，
以验证外部服务器的身份并加密流量。&lt;/p>
&lt;h2 id="conclusion">结论&lt;/h2>
&lt;p>在这篇博文中，我演示了 Istio 服务网格中的微服务如何通过 HTTPS 使用外部 Web 服务, 默认情况下，
Istio 会阻止集群外主机的所有流量, 要启用此类流量，请使用 mesh-external, 必须为服务网格创建 &lt;code>ServiceEntry&lt;/code> ,
可以通过 HTTPS 访问外部站点，当微服务发出 HTTPS 请求时，流量是端到端加密的，但是 Istio 无法监视 HTTP 详细信息，
例如请求的 URL 路径。当微服务发出 HTTP 请求时，Istio 可以监视请求的 HTTP 详细信息并强制执行基于 HTTP 的访问策略。
但是，在这种情况下，微服务和 sidecar 代理之间的流量是未加密的。在具有非常严格的安全要求的组织中，
可以禁止未加密的部分流量。&lt;/p></description><pubDate>Wed, 31 Jan 2018 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2018/egress-https/</link><author>Vadim Eisenberg</author><guid isPermaLink="true">/v1.8/zh/blog/2018/egress-https/</guid><category>traffic-management</category><category>egress</category><category>https</category></item><item><title>Mixer 和 SPOF 神话</title><description>
&lt;p>&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/">Mixer&lt;/a> 出现在请求路径上，很自然的会引发一个疑问：他对系统可用性和延迟会产生什么样的影响？第一次看到 Istio 架构图时，人们最常见的问题就是：&amp;rdquo;这不就是一个单点失败的典型案例么？”&lt;/p>
&lt;p>本文中我们会深入挖掘和阐述 Mixer 的设计原则，在这些设计原则的支持下 Mixer 能够令人惊奇的提高网格内的系统可用性，降低平均请求延时。&lt;/p>
&lt;p>Istio 的 Mixer 对系统总体可用性和延迟有两个主要的好处：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>提高 SLO&lt;/strong>：Mixer 把 Proxy 和服务从基础设施后端的故障中隔离出来，提供了高级、高效的网格可用性保障。作为一个整体来说，在同基础设施后端的交互中，有了 Mixer 的帮助，会有更低的故障率。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>降低延迟&lt;/strong>：通过对各个层次的分片缓存的积极使用和共享，Mixer 能够降低平均延迟。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>接下来会对上面的内容进行一下解释。&lt;/p>
&lt;h2 id="how-we-got-here">Istio 是怎么来的&lt;/h2>
&lt;p>Google 在多年中都在使用一个内部的 API 和服务管理系统，用于处理 Google 提供的众多 API。这一系统支持了最大的服务群（Google Maps、YouTube 以及 Gmail 等），承受上百万 QPS 峰值的冲击。这套系统运行的虽然很好，但是仍然无法跟上 Google 快速增长的脚步，很显然，要有新的架构来降低飞涨的运维成本。&lt;/p>
&lt;p>2014 年，我们开始了一个草案，准备替换这一系统，进行更好的伸缩。这一决定最后证明是非常正确的，在 Google 进行整体部署之后，每月降低了上百万美元的运维成本。&lt;/p>
&lt;p>过去，流量在进入具体的服务之前，首先会进入一个较重的代理，旧系统就是以这个代理为中心构建的。新的架构摒弃了共享代理的设计，用轻量高效的 Sidecar 代理取而代之，这一代理和服务实例并行，共享一个控制平面。&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:74.79295535770372%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2017/mixer-spof-myth/mixer-spof-myth-1.svg" title="Google 系统拓扑">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2017/mixer-spof-myth/mixer-spof-myth-1.svg" alt="Google 系统拓扑" />
&lt;/a>
&lt;/div>
&lt;figcaption>Google 的 API 和 服务管理系统&lt;/figcaption>
&lt;/figure>
&lt;p>看起来很面熟吧？是的，跟 Istio 很像。Istio 就是作为这一分布式代理架构的继任者进行构思的。我们从内部系统中获取了核心的灵感，在同合作伙伴的协同工作中产生了很多概念，这些导致了 Istio 的诞生。&lt;/p>
&lt;h2 id="architecture-recap">架构总结&lt;/h2>
&lt;p>下图中，Mixer 在 Mesh 和基础设施之间：&lt;/p>
&lt;figure style="width:75%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:65.89948886170049%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2017/mixer-spof-myth/mixer-spof-myth-2.svg" title="Istio 拓扑">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2017/mixer-spof-myth/mixer-spof-myth-2.svg" alt="Istio 拓扑" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio 拓扑&lt;/figcaption>
&lt;/figure>
&lt;p>逻辑上，Envoy Sidecar 会在每次请求之前调用 Mixer，进行前置检查，每次请求之后又要进行指标报告。Sidecar 中包含本地缓存，一大部分的前置检查可以通过缓存来进行。另外，Sidecar 会把待发送的指标数据进行缓冲，这样可能在几千次请求之后才调用一次 Mixer。前置检查和请求处理是同步的，指标数据上送是使用 fire-and-forget 模式异步完成的。&lt;/p>
&lt;p>抽象一点说，Mixer 提供：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>后端抽象&lt;/strong>：Mixer 把 Istio 组件和网格中的服务从基础设施细节中隔离开来。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>中间人&lt;/strong>：Mixer 让运维人员能够对所有网格和基础设施后端之间的交互进行控制。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>除了这些纯功能方面，Mixer 还有一些其他特点，为系统提供更多益处。&lt;/p>
&lt;h3 id="mixer-booster">Mixer：SLO 助推器&lt;/h3>
&lt;p>有人说 Mixer 是一个 SPOF，会导致 Mesh 的崩溃，而我们认为 Mixer 增加了 Mesh 的可用性。这是如何做到的？下面是三个理由：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;strong>无状态&lt;/strong>：Mixer 没有状态，他不管理任何自己的持久存储。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>稳固&lt;/strong>：Mixer 是一个高可靠性的组件，设计要求所有 Mixer 实例都要有超过 99.999% 的可靠性。&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;strong>缓存和缓冲&lt;/strong>：Mixer 能够积累大量的短期状态数据。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>Sidecar 代理伴随每个服务实例而运行，必须节约使用内存，这样就限制了本地缓存和缓冲的数量。但是 Mixer 是独立运行的，能使用更大的缓存和缓冲。因此 Mixer 为 Sidecar 提供了高伸缩性高可用的二级缓存服务。&lt;/p>
&lt;p>Mixer 的预期可用性明显高于多数后端（多数是 99.9%）。他的本地缓存和缓冲区能够在后端无法响应的时候继续运行，因此有助于对基础设施故障的屏蔽，降低影响。&lt;/p>
&lt;h3 id="mixer-latency-slasher">Mixer：延迟削减器&lt;/h3>
&lt;p>上面我们解释过，Istio Sidecar 具备有效的一级缓存，在为流量服务的时候多数时间都可以使用缓存来完成。Mixer 提供了更大的共享池作为二级缓存，这也帮助了 Mixer 降低平均请求的延迟。&lt;/p>
&lt;p>不只是降低延迟，Mixer 还降低了 Mesh 到底层的请求数量，这样就能显著降低到基础设施后端的 QPS，如果你要付款给这些后端，那么这一优点就会节省更多成本。&lt;/p>
&lt;h2 id="work-ahead">下一步&lt;/h2>
&lt;p>我们还有机会对系统做出更多改进。&lt;/p>
&lt;h3 id="configuration-canaries">以金丝雀部署的方式进行配置发布&lt;/h3>
&lt;p>Mixer 具备高度的伸缩性，所以他通常不会故障。然而如果部署了错误的配置，还是会引发 Mixer 进程的崩溃。为了防止这种情况的出现，可以用金丝雀部署的方式来发布配置，首先为一小部分 Mixer 进行部署，然后扩大部署范围。&lt;/p>
&lt;p>目前的 Mixer 并未具备这样的能力，我们期待这一功能成为 Istio 可靠性配置工作的一部分最终得以发布。&lt;/p>
&lt;h3 id="cache-tuning">缓存调优&lt;/h3>
&lt;p>我们的 Sidecar 和 Mixer 缓存还需要更好的调整，这部分的工作会着眼于资源消耗的降低和性能的提高。&lt;/p>
&lt;h3 id="cache-sharing">缓存共享&lt;/h3>
&lt;p>现在 Mixer 的实例之间是各自独立的。一个请求在被某个 Mixer 实例处理之后，并不会把过程中产生的缓存传递给其他 Mixer 实例。我们最终会试验使用 Memcached 或者 Redis 这样的分布式缓存，以期提供一个网格范围内的共享缓存，更好的降低对后端基础设施的调用频率。&lt;/p>
&lt;h3 id="Sharding">分片&lt;/h3>
&lt;p>在大规模的网格中，Mixer 的负载可能很重。我们可以使用大量的 Mixer 实例，每个实例都为各自承担的流量维护各自的缓存。我们希望引入智能分片能力，这样 Mixer 实例就能针对特定的数据流提供特定的服务，从而提高缓存命中率；换句话说，分片可以利用把相似的流量分配给同一个 Mixer 实例的方式来提高缓存效率，而不是把请求交给随机选择出来的 Mixer 实例进行处理。&lt;/p>
&lt;h2 id="conclusion">结语&lt;/h2>
&lt;p>Google 的实际经验展示了轻代理、大缓存控制平面结合的好处：提供更好的可用性和延迟。过去的经验帮助 Istio 构建了更精确更有效的缓存、预抓取以及缓冲策略等功能。我们还优化了通讯协议，用于降低缓存无法命中的时候，对性能产生的影响。&lt;/p>
&lt;p>Mixer 还很年轻。在 Istio 0.3 中，Mixer 并没有性能方面的重要改进。这意味着如果一个请求没有被 Sidecar 缓存命中，Mixer 就会花费更多时间。未来的几个月中我们会做很多工作来优化同步的前置检查过程中的这种情况。&lt;/p>
&lt;p>我们希望本文能够让读者能够意识到 Mixer 对 Istio 的益处。&lt;/p>
&lt;p>如果有意见或者问题，无需犹豫，请前往 &lt;a href="https://groups.google.com/forum/#!forum/istio-policies-and-telemetry">istio-policies-and-telemetry@&lt;/a>。&lt;/p></description><pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2017/mixer-spof-myth/</link><author>Martin Taillefer</author><guid isPermaLink="true">/v1.8/zh/blog/2017/mixer-spof-myth/</guid><category>adapters</category><category>mixer</category><category>policies</category><category>telemetry</category><category>availability</category><category>latency</category></item><item><title>Mixer 适配器模型</title><description>
&lt;p>Istio 0.2 引入了一种新的 Mixer 适配器模型，这种模型使接入后端基础设施具有更多的灵活性 。本文将解释这种模型是如何工作的。&lt;/p>
&lt;h2 id="why-adapters">为什么是适配器模型？&lt;/h2>
&lt;p>后端基础设施提供了支持服务构建的功能。他们包括访问控制、遥测、配额控制、计费系统等等。传统服务会直接与这些后端系统集成，并与后端紧密耦合，并集成到其中的个性化语义和操作。&lt;/p>
&lt;p>Mixer 服务作为 Istio 和一套开放式基础设施之间的抽象层。Istio 组件和运行在 Service Mesh 中的服务，通过 Mixer 就可以在不直接访问后端接口的情况下和这些后端进行交互。&lt;/p>
&lt;p>除了作为应用层与基础设施隔离外，Mixer 提供了一种中介模型，这种模型允许注入和控制应用和后端的策略。操作人员可以控制哪些数据汇报给哪个后端，哪个后端提供授权等等。&lt;/p>
&lt;p>考虑到每个基础服务都有不同的接口和操作模型，Mixer 需要用户通过代码来解决这些差异，我们可以称这些用户自己封装的代码为 &lt;a href="https://github.com/istio/istio/wiki/Mixer-Compiled-In-Adapter-Dev-Guide">&lt;em>适配器&lt;/em>&lt;/a>。&lt;/p>
&lt;p>适配器以 Go 包的形式直接链接到 Mixer 二进制中。如果默认的适配器不能满足特定的使用需求，自定义适配器也是很简单的。&lt;/p>
&lt;h2 id="philosophy">设计哲学&lt;/h2>
&lt;p>Mixer 本质上就是一个处理属性和路由的机器。代理将&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/#attributes">属性&lt;/a>作为预检和遥测报告的一部分发送出来，并且转换为一系列对适配器的调用。运维人员提供了用于描述如何将传入的属性映射为适配器的配置。&lt;/p>
&lt;figure style="width:60%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:42.60859894197215%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/machine.svg" title="Attribute Machine">
&lt;img class="element-to-stretch" src="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/machine.svg" alt="Attribute Machine" />
&lt;/a>
&lt;/div>
&lt;figcaption>Attribute Machine&lt;/figcaption>
&lt;/figure>
&lt;p>配置是一个复杂的任务。有证据表明绝大多数服务中断是由配置错误造成的。为了帮助解决这一问题，Mixer 的配置模型通过做限制来避免错误。例如，在配置中使用强类型，以此来确保在上下文环境中使用了有意义的属性或者属性表达式。&lt;/p>
&lt;h2 id="handlers-configuring-adapters">Handlers: 适配器的配置&lt;/h2>
&lt;p>Mixer 使用的每个适配器都需要一些配置才能运行。一般来说，适配器需要一些信息。例如，到后端的 URL 、证书、缓存选项等等。每个适配器使用一个 &lt;a href="https://developers.google.com/protocol-buffers/">protobuf&lt;/a> 消息来定义所需要的配置数据。&lt;/p>
&lt;p>你可以通过创建 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/#handlers">&lt;em>handler&lt;/em>&lt;/a> 为适配器提供配置。Handler 就是一套能让一个适配器就绪的完整配置。对同一个适配器可以有任意数量的 Handler，这样就可以在不同的场景下复用了。&lt;/p>
&lt;h2 id="templates-adapter-input-schema">Templates: 适配输入结构&lt;/h2>
&lt;p>通常对于进入到 Mesh 服务中的请求，Mixer 会发生两次调用，一次是预检，一次是遥测报告。每一次调用，Mixer 都会调用一个或更多的适配器。不同的适配器需要不同的数据作为输入来处理。例如，日志适配器需要日志输入，metric 适配器需要 metric 数据作为输入，认证的适配器需要证书等等。Mixer &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/templates/">&lt;em>templates&lt;/em>&lt;/a> 用来描述每次请求适配器消费的数据。&lt;/p>
&lt;p>每个 Template 被指定为 &lt;a href="https://developers.google.com/protocol-buffers/">protobuf&lt;/a> 消息。一个模板描述了一组数据，这些数据在运行时被传递给一个或多个适配器。一个适配器可以支持任意数量的模板，开发者还可以设计支持特定模板的是适配器。&lt;/p>
&lt;p>&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/templates/metric/">&lt;code>metric&lt;/code>&lt;/a> 和 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/templates/logentry/">&lt;code>logentry&lt;/code>&lt;/a> 是两个最重要的模板，分别表示负载的单一指标，和到适当后端的单一日志条目。&lt;/p>
&lt;h2 id="instances-attribute-mapping">Instances: 属性映射&lt;/h2>
&lt;p>你可以通过创建 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/#instances">&lt;em>instances&lt;/em>&lt;/a> 来决定哪些数据被传递给特定的适配器。Instances 决定了 Mixer 如何通过 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/#attributes">attributes&lt;/a> 把来自代理的属性拆分为各种数据然后分发给不同的适配器。&lt;/p>
&lt;p>创建实例通常需要使用 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/expression-language/">attribute expressions&lt;/a> 。这些表达式的功能是使用属性和常量来生成结果数据，用于给 instance 字段进行赋值。&lt;/p>
&lt;p>在模板中定义的每个 instance 字段、每个属性、每个表达式都有一个 &lt;a href="https://github.com/istio/api/blob/release-1.8/policy/v1beta1/value_type.proto">type&lt;/a>，只有兼容的数据类型才能进行赋值。例如不能把整型的表达式赋值给字符串类型。强类型设计的目的就是为了降低配置出错引发的风险。&lt;/p>
&lt;h2 id="rules-delivering-data-to-adapters">Rules: 将数据交付给适配器&lt;/h2>
&lt;p>最后一个问题就是告诉 Mixer 哪个 instance 在什么时候发送给哪个 handler。这个通过创建 &lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/#rules">&lt;em>rules&lt;/em>&lt;/a> 实现。每个规则都会指定一个特定的处理程序和要发送给该处理程序的示例。当 Mixer 处理一个调用时，它会调用指定的处理程序，并给他一组特定的处理实例。&lt;/p>
&lt;p>Rule 中包含有匹配断言，这个断言是一个返回布尔值的属性表达式。只有属性表达式断言成功的 Rule 才会生效，否则这条规则就形同虚设，当然其中的 Handler 也不会被调用。&lt;/p>
&lt;h2 id="future">未来的工作&lt;/h2>
&lt;p>我们正在努力改进和提升适配器的使用及开发。例如，计划中包含很多新特性使用户更加方便地使用 Templates。另外，表达式语言也正在不断的发展和成熟。&lt;/p>
&lt;p>长远来看，我们正在寻找不直接将适配器直接连接到 Mixer 二进制的方法。这将简化部署和开发使用。&lt;/p>
&lt;h2 id="conclusion">结论&lt;/h2>
&lt;p>新的 Mixer 适配器模型的设计是为了提供一个灵活的框架用来支持一个开放基础设施。&lt;/p>
&lt;p>Handler 为各个适配器提供了配置数据，Template 用于在运行时确定不同的适配器所需的数据类型，Instance 让运维人员准备这些数据，Rule 将这些数据提交给一个或多个 Handler 进行处理。&lt;/p>
&lt;p>更多信息可以关注&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/mixer-overview/">这里&lt;/a>。更多关于 templates, handlers, 和 rules 的内容可以关注&lt;a href="/v1.8/zh/docs/reference/config/policy-and-telemetry/">这里&lt;/a>。你也可以在&lt;a href="https://github.com/istio/istio/tree/release-1.8/samples/bookinfo">这里&lt;/a>找到对应的示例。&lt;/p></description><pubDate>Fri, 03 Nov 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2017/adapter-model/</link><author>Martin Taillefer</author><guid isPermaLink="true">/v1.8/zh/blog/2017/adapter-model/</guid><category>adapters</category><category>mixer</category><category>policies</category><category>telemetry</category></item><item><title>Istio 使用网络策略</title><description>
&lt;p>使用网络策略去保护运行在 Kubernetes 上的应用程序现在是一种广泛接受的行业最佳实践。鉴于 Istio 也支持策略，我们希望花一些时间来解释 Istio 策略和 Kubernetes 网络策略的相互作用和互相支持提供应用程序的安全。&lt;/p>
&lt;p>让我们从基础开始：为什么你想要同时使用 Istio 和 Kubernetes 网络策略？简短的回答是它们处理不同的事情。表格列出 Istio 和网络策略之间的主要区别（我们将描述“典型”实现，例如：Calico，但具体实现细节可能因不同的网络提供商而异）：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>Istio 策略&lt;/th>
&lt;th>网络策略&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>层级&lt;/strong>&lt;/td>
&lt;td>&amp;ldquo;服务&amp;rdquo; &amp;mdash; L7&lt;/td>
&lt;td>&amp;ldquo;网络&amp;rdquo; &amp;mdash; L3-4&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>实现&lt;/strong>&lt;/td>
&lt;td>用户空间&lt;/td>
&lt;td>内核&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>执行点&lt;/strong>&lt;/td>
&lt;td>Pod&lt;/td>
&lt;td>节点&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="layer">层级&lt;/h2>
&lt;p>从 OSI 模型的角度来看 7 层（应用程序），Istio 策略运行在网络应用程序的“服务”层。但事实上云原生应用程序模型是 7 层实际上至少包含两层：服务层和内容层。服务层通常是 HTTP ，它封装了实际的应用程序数据（内容层）。Istio 的 Envoy 代理运行的 HTTP 服务层。相比之下，网络策略在 OSI 模型中的第 3 层（网络）和第 4 层（传输）运行。&lt;/p>
&lt;p>运行在服务层为 Envoy 代理提供了一组丰富的属性，以便基础协议进行策略决策，其中包括 HTTP/1.1 和 HTTP/2（gRPC 运行在 HTTP/2 上）。因此，您可以基于虚拟主机、URL 或其他 HTTP 头部应用策略。在未来，Istio 将支持广泛的 7 层协议、以及通用的 TCP 和 UDP 传输。&lt;/p>
&lt;p>相比之下，Istio 策略运行在网络层具有通用的优势，因为所有网络应用程序都使用 IP。无论 7 层协议如何，您都可以在网络层应用策略：DNS 、SQL 数据库、实时流以及许多不使用 HTTP 的其他服务都可以得到保护。网络策略不仅限于经典防火墙的 IP 地址、协议和端口三元组，Istio 和网络策略都可以使用丰富的 Kubernetes 标签来描述 pod 端点。&lt;/p>
&lt;h2 id="implementation">实现&lt;/h2>
&lt;p>Istio 的代理基于 &lt;a href="https://envoyproxy.github.io/envoy/">&lt;code>Envoy&lt;/code>&lt;/a>，它作为数据平面的用户空间守护进程实现的，使用标准套接字与网络层交互。这使它在处理方面具有很大的灵活性，并允许它在容器中分发（和升级！）。&lt;/p>
&lt;p>网络策略数据平面通常在内核空间中实现（例如：使用 iptables 、eBPF 过滤器、或甚至自定义内核模块）。在内核空间使它们性能很好，但不像 Envoy 代理那样灵活。&lt;/p>
&lt;h2 id="enforcement-point">执行点&lt;/h2>
&lt;p>Envoy 代理的策略执行是在 pod 中，作为同一网络命名空间中的 sidecar 容器。这使得部署模型简单。某些容器赋予权限可以重新配置其 pod 中的网络（&lt;code>CAP_NET_ADMIN&lt;/code>）。如果此类服务实例绕过代理受到损害或行为不当（如：在恶意租户中）。&lt;/p>
&lt;p>虽然这不会让攻击者访问其他启用了 Istio 的 pod ，但通过配置，会打开几种攻击：&lt;/p>
&lt;ul>
&lt;li>攻击未受保护的 pods&lt;/li>
&lt;li>尝试通过发送大量流量为受保护的 pods 造成访问拒绝&lt;/li>
&lt;li>在 pod 中收集的漏出数据&lt;/li>
&lt;li>攻击集群基础设施（服务器或 Kubernetes 服务）&lt;/li>
&lt;li>攻击网格外的服务，如数据库，存储阵列或遗留系统。&lt;/li>
&lt;/ul>
&lt;p>网络策略通常在客户机的网络命名空间之外的主机节点处执行。这意味着必须避免受损或行为不当的 pod 进入根命名空间的执行。通过在 Kubernetes 1.8 中添加 egress 策略，这是网络策略成为保护基础设施免受工作负载受损的关键部分。&lt;/p>
&lt;h2 id="examples">举例&lt;/h2>
&lt;p>让我们来看一些 Istio 应用程序使用 Kubernetes 网络策略的示例。下面我们以 Bookinfo 应用程序为例，介绍网络策略功能的用例：&lt;/p>
&lt;ul>
&lt;li>减少应用程序入口的攻击面&lt;/li>
&lt;li>在应用程序中实现细粒度隔离&lt;/li>
&lt;/ul>
&lt;h3 id="reduce-attack-surface-of-the-application-ingress">减少应用程序入口的攻击面&lt;/h3>
&lt;p>应用程序的 ingress 控制器是外部世界进入我们应用程序的主要入口。快速查看 &lt;code>istio.yaml&lt;/code> （用于安装 Istio ）定义了 Istio-ingress，如下所示：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Service
metadata:
name: istio-ingress
labels:
istio: ingress
spec:
type: LoadBalancer
ports:
- port: 80
name: http
- port: 443
name: https
selector:
istio: ingress
&lt;/code>&lt;/pre>
&lt;p>&lt;code>istio-ingress&lt;/code> 暴露端口 80 和 443 . 我们需要将流入流量限制在这两个端口上。Envoy 有 &lt;a href="https://www.envoyproxy.io/docs/envoy/latest/operations/admin.html#operations-admin-interface">&lt;code>内置管理接口&lt;/code>&lt;/a>，我们不希望错误配置 &lt;code>istio-ingress&lt;/code> 镜像而导致意外地将我们的管理接口暴露给外界。这里深度防御的示例：正确配置的镜像应该暴露接口，正确配置的网络策略将阻止任何人连接到它，要么失败，要么配置错误，受到保护。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
name: istio-ingress-lockdown
namespace: default
spec:
podSelector:
matchLabels:
istio: ingress
ingress:
- ports:
- protocol: TCP
port: 80
- protocol: TCP
port: 443
&lt;/code>&lt;/pre>
&lt;h3 id="enforce-fine-grained-isolation-within-the-application">在应用程序中实现细粒度隔离&lt;/h3>
&lt;p>如下是 Bookinfo 应用程序的服务示意图：&lt;/p>
&lt;figure style="width:80%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:59.086918235567985%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/docs/examples/bookinfo/withistio.svg" title="Bookinfo Service Graph">
&lt;img class="element-to-stretch" src="/v1.8/zh/docs/examples/bookinfo/withistio.svg" alt="Bookinfo Service Graph" />
&lt;/a>
&lt;/div>
&lt;figcaption>Bookinfo Service Graph&lt;/figcaption>
&lt;/figure>
&lt;p>此图显示了一个正确功能的应用程序应该允许的每个连接。所有其他连接，例如从 Istio Ingress 直接到 Rating 服务，不是应用程序的一部分。让我们排除那些无关的连接，它们不能被攻击者所用。例如：想象一下，Ingress pod 受到攻击者的攻击，允许攻击者运行任意代码。如果我们使用网络策略只允许连接到 &lt;code>productpage&lt;/code>（&lt;code>http://$GATEWAY_URL/productpage&lt;/code>）的 Pod ，则攻击者不再获得对我的应用程序后端的访问权限，尽管它们已经破坏了服务网格的成员。&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
name: product-page-ingress
namespace: default
spec:
podSelector:
matchLabels:
app: productpage
ingress:
- ports:
- protocol: TCP
port: 9080
from:
- podSelector:
matchLabels:
istio: ingress
&lt;/code>&lt;/pre>
&lt;p>推荐你可以而且应该为每个服务编写类似的策略，允许其他 pod 访问执行。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>我们认为 Istio 和网络策略在应用策略方面有不同的优势。Istio 具有应用协议感知和高度灵活性，非常适合应用策略来支持运营目标，如：服务路由、重试、熔断等，以及在应用层开启的安全性，例如：令牌验证。网络策略是通用的、高效的、与 pod 隔离，使其成为应用策略以支持网络安全目标的理想选择。此外，拥有在网络堆栈的不同层运行的策略是一件非常好的事情，因为它为每个层提供特定的上下文而不会混合状态并允许责任分离。&lt;/p>
&lt;p>这篇文章是基于 Spike Curtis 的三部分博客系列，他是 Tigera 的 Istio 团队成员之一。完整系列可以在这里找到：&lt;a href="https://www.projectcalico.org/using-network-policy-in-concert-with-istio/">https://www.projectcalico.org/using-network-policy-in-concert-with-istio/&lt;/a>&lt;/p></description><pubDate>Thu, 10 Aug 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2017/0.1-using-network-policy/</link><author>Spike Curtis</author><guid isPermaLink="true">/v1.8/zh/blog/2017/0.1-using-network-policy/</guid></item><item><title>使用 Istio 进行金丝雀部署</title><description>
&lt;div>
&lt;aside class="callout tip">
&lt;div class="type">&lt;svg class="large-icon">&lt;use xlink:href="/v1.8/img/icons.svg#callout-tip"/>&lt;/svg>&lt;/div>
&lt;div class="content">本篇博客最后更新时间 2018 年 5 月 16 号，采用了最新版本的流量管理模型。&lt;/div>
&lt;/aside>
&lt;/div>
&lt;p>采用 &lt;a href="/v1.8/zh/">Istio&lt;/a> 项目的一大好处就是为服务金丝雀方式部署提供了控制便利。金丝雀部署（或上线）背后的想法是通过让一小部分用户流量引入的新版本进行测试，如果一切顺利，则可以增加（可能逐渐增加）百分比，逐步替换旧版本。如在过程中出现任何问题，则可以中止并回滚到旧版本。最简单的方式，是随机选择百分比请求到金丝雀版本，但在更复杂的方案下，则可以基于请求的区域，用户或其他属性。&lt;/p>
&lt;p>基于领域的专业水平，您可能想知道为什么需要 Istio 来支持金丝雀部署，因为像 Kubernetes 这样的平台已经提供了进行&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment">版本上线&lt;/a>和&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments">金丝雀部署&lt;/a>的方法。问题解决了吗 ？不完全是。虽然以这种方式进行部署可以在简单的情况下工作，但功能非常有限，特别是在大规模自动缩放的云环境中大流量的情况下。&lt;/p>
&lt;h2 id="canary-deployment-in-Kubernetes">Kubernetes 中的金丝雀部署&lt;/h2>
&lt;p>假设我们有一个已部署的 &lt;strong>helloworld&lt;/strong> 服务 &lt;strong>v1&lt;/strong> 版本，我们想要测试（或简单上线）新版本 &lt;strong>v2&lt;/strong>。使用 Kubernetes，您可以通过简单地更新服务的 &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment&lt;/a> 中的镜像并自动进行部署来&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#updating-a-deployment">上线&lt;/a>新版本的 &lt;strong>helloworld&lt;/strong> 服务。如果我们特能够小心保证在启动并且在仅启动一个或两个 v2 副本&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment">暂停&lt;/a>上线时有足够的 &lt;strong>v1&lt;/strong> 副本运行，则能够保持金丝雀发布对系统的影响非常小。后续我们可以观察效果，或在必要时进行&lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#rolling-back-a-deployment">回滚&lt;/a>。最好，我们也能够对 Deployment 设置 &lt;a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#scaling-a-deployment">HPA&lt;/a>，在上线过程中减少或增加副本以处理流量负载时，也能够保持副本比例一致。&lt;/p>
&lt;p>尽管这种机制能够很好工作，但这种方式只适用于部署的经过适当测试的版本，也就是说，更多的是蓝/绿发布，又称红/黑发布，而不是 “蜻蜓点水“ 式的金丝雀部署。实际上，对于后者（例如，并没有完全准备好或者无意对外暴露的版本），Kubernetes 中的金丝雀部署将使用具有&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively">公共 pod 标签&lt;/a>的两个 Deployment 来完成。在这种情况下，我们不能再使用自动缩放器，因为是有由两个独立的自动缩放器来进行控制，不同负载情况下，副本比例（百分比）可能与所需的比例不同。&lt;/p>
&lt;p>无论我们使用一个或者两个部署，使用 Docker，Mesos/Marathon 或 Kubernetes 等容器编排平台进行的金丝雀发布管理都存在一个根本问题：使用实例扩容来管理流量；版本流量分发和副本部署在上述平台中并独立。所有 pod 副本，无论版本如何，在 &lt;code>kube-proxy&lt;/code> 循环池中都被一视同仁地对待，因此管理特定版本接收的流量的唯一方法是控制副本比例。以小百分比维持金丝雀流量需要许多副本（例如，1％ 将需要至少 100 个副本）。即使我们可以忽略这个问题，部署方式功能仍然非常有限，因为它只支持简单（随机百分比）金丝雀部署。如果我们想根据某些特定规则将请求路由到金丝雀版本上，我们仍然需要另一种解决方案。&lt;/p>
&lt;h2 id="enter-Istio">使用 Istio&lt;/h2>
&lt;p>使用 Istio，流量路由和副本部署是两个完全独立的功能。服务的 pod 数量可以根据流量负载灵活伸缩，与版本流量路由的控制完全正交。这在自动缩放的情况下能够更加简单地管理金丝雀版本。事实上，自动缩放管理器仍然独立运行，其在响应因流量路由导致的负载变化与其他原因导致负载变化的行为上没有区别。&lt;/p>
&lt;p>Istio 的&lt;a href="/v1.8/zh/docs/concepts/traffic-management/#routing-rules">路由规则&lt;/a>也带来了其他的便利；你可以轻松实现细粒度控制流量百分比（例如，路由 1％ 的流量而不需要 100 个 pod），当然也可以使用其他规则来控制流量（例如，将特定用户的流量路由到金丝雀版本）。作为展示，让我们看一下采用这种方式部署 &lt;strong>helloworld&lt;/strong> 服务的简单便捷。&lt;/p>
&lt;p>首先我们定义 &lt;strong>helloworld&lt;/strong> 服务，和普通 &lt;strong>Kubernetes&lt;/strong> 服务一样，如下所示：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >apiVersion: v1
kind: Service
metadata:
name: helloworld
labels:
app: helloworld
spec:
selector:
app: helloworld
...
&lt;/code>&lt;/pre>
&lt;p>然后我们添加 2 个 Deployment，分别为版本 &lt;strong>v1&lt;/strong> 和 &lt;strong>v2&lt;/strong>，这两个版本都包含服务选择标签 &lt;code>app：helloworld&lt;/code> ：&lt;/p>
&lt;pre>&lt;code class='language-yaml' data-expandlinks='true' data-repo='istio' >kind: Deployment
metadata:
name: helloworld-v1
spec:
replicas: 1
template:
metadata:
labels:
app: helloworld
version: v1
spec:
containers:
- image: helloworld-v1
...
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
name: helloworld-v2
spec:
replicas: 1
template:
metadata:
labels:
app: helloworld
version: v2
spec:
containers:
- image: helloworld-v2
...
&lt;/code>&lt;/pre>
&lt;p>需要注意的是，这与使用普通 Kubernetes 进行&lt;a href="https://kubernetes.io/docs/concepts/cluster-administration/manage-deployment/#canary-deployments">金丝雀部署&lt;/a>的方式完全相同，但是在 Kubernetes 方式下控制流量分配需要调整每个 Deployment 的副本数目。例如，将 10％ 的流量发送到金丝雀版本（v2），v1 和 v2 的副本可以分别设置为 9 和 1。&lt;/p>
&lt;p>但是在&lt;a href="/v1.8/zh/docs/setup/">启用 Istio&lt;/a> 的集群中，我们可以通过设置路由规则来控制流量分配。如将 10％ 的流量发送到金丝雀版本本，我们可以使用 &lt;code>kubectl&lt;/code> 来设置以下的路由规则：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: helloworld
spec:
hosts:
- helloworld
http:
- route:
- destination:
host: helloworld
subset: v1
weight: 90
- destination:
host: helloworld
subset: v2
weight: 10
---
apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
name: helloworld
spec:
host: helloworld
subsets:
- name: v1
labels:
version: v1
- name: v2
labels:
version: v2
EOF
&lt;/code>&lt;/pre>
&lt;p>当规则设置生效后，Istio 将确保只有 10% 的请求发送到金丝雀版本，无论每个版本的运行副本数量是多少。&lt;/p>
&lt;h2 id="autoscaling-the-deployments">部署中的自动缩放&lt;/h2>
&lt;p>由于我们不再需要保持副本比例，所以我们可以安全地设置 Kubernetes &lt;a href="https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/">HPA&lt;/a> 来管理两个版本 Deployment 的副本：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl autoscale deployment helloworld-v1 --cpu-percent=50 --min=1 --max=10
deployment &amp;#34;helloworld-v1&amp;#34; autoscaled
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl autoscale deployment helloworld-v2 --cpu-percent=50 --min=1 --max=10
deployment &amp;#34;helloworld-v2&amp;#34; autoscaled
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get hpa
NAME REFERENCE TARGET CURRENT MINPODS MAXPODS AGE
Helloworld-v1 Deployment/helloworld-v1 50% 47% 1 10 17s
Helloworld-v2 Deployment/helloworld-v2 50% 40% 1 10 15s
&lt;/code>&lt;/pre>
&lt;p>如果现在对 &lt;strong>helloworld&lt;/strong> 服务上产生一些负载，我们会注意到，当扩容开始时，&lt;strong>v1&lt;/strong> 扩容副本数目远高于 &lt;strong>v2&lt;/strong> ，因为 &lt;strong>v1&lt;/strong> pod 正在处理 90％ 的负载。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods | grep helloworld
helloworld-v1-3523621687-3q5wh 0/2 Pending 0 15m
helloworld-v1-3523621687-73642 2/2 Running 0 11m
helloworld-v1-3523621687-7hs31 2/2 Running 0 19m
helloworld-v1-3523621687-dt7n7 2/2 Running 0 50m
helloworld-v1-3523621687-gdhq9 2/2 Running 0 11m
helloworld-v1-3523621687-jxs4t 0/2 Pending 0 15m
helloworld-v1-3523621687-l8rjn 2/2 Running 0 19m
helloworld-v1-3523621687-wwddw 2/2 Running 0 15m
helloworld-v1-3523621687-xlt26 0/2 Pending 0 19m
helloworld-v2-4095161145-963wt 2/2 Running 0 50m
&lt;/code>&lt;/pre>
&lt;p>如果更改路由规则将 50％ 的流量发送到 &lt;strong>v2&lt;/strong>，我们则可以在短暂的延迟后注意到 &lt;strong>v1&lt;/strong> 副本数的减少，而 &lt;strong>v2&lt;/strong> 副本数相应地增加。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods | grep helloworld
helloworld-v1-3523621687-73642 2/2 Running 0 35m
helloworld-v1-3523621687-7hs31 2/2 Running 0 43m
helloworld-v1-3523621687-dt7n7 2/2 Running 0 1h
helloworld-v1-3523621687-gdhq9 2/2 Running 0 35m
helloworld-v1-3523621687-l8rjn 2/2 Running 0 43m
helloworld-v2-4095161145-57537 0/2 Pending 0 21m
helloworld-v2-4095161145-9322m 2/2 Running 0 21m
helloworld-v2-4095161145-963wt 2/2 Running 0 1h
helloworld-v2-4095161145-c3dpj 0/2 Pending 0 21m
helloworld-v2-4095161145-t2ccm 0/2 Pending 0 17m
helloworld-v2-4095161145-v3v9n 0/2 Pending 0 13m
&lt;/code>&lt;/pre>
&lt;p>最终结果与 Kubernetes Deployment 上线非常相似，只是整个流程并不是集中地进行编排和管理。相反，我们看到几个组件独立完成工作，虽然它们有因果关系。&lt;/p>
&lt;p>有一点不同的是，当我们停止负载时，无论设置路由规则如何，两个版本的副本数最终都会缩小到最小值（1）。&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl get pods | grep helloworld
helloworld-v1-3523621687-dt7n7 2/2 Running 0 1h
helloworld-v2-4095161145-963wt 2/2 Running 0 1h
&lt;/code>&lt;/pre>
&lt;h2 id="focused-canary-testing">聚焦金丝雀测试&lt;/h2>
&lt;p>如上所述，Istio 路由规则可用于根据特定规则准进行流量路由，从而能够提供更复杂的金丝雀部署方案。例如，与简单通过将金丝雀版本暴露给任意百分比的用户方式不同，我们希望在内部用户上尝试，甚至可能只是内部用户的一部分。&lt;/p>
&lt;p>以下命令可将特定网站上 50％ 的用户流量路由到金丝雀版本，而其他用户则不受影响：&lt;/p>
&lt;pre>&lt;code class='language-bash' data-expandlinks='true' data-repo='istio' >$ kubectl apply -f - &amp;lt;&amp;lt;EOF
apiVersion: networking.istio.io/v1alpha3
kind: VirtualService
metadata:
name: helloworld
spec:
hosts:
- helloworld
http:
- match:
- headers:
cookie:
regex: &amp;#34;^(.*?;)?(email=[^;]*@some-company-name.com)(;.*)?$&amp;#34;
route:
- destination:
host: helloworld
subset: v1
weight: 50
- destination:
host: helloworld
subset: v2
weight: 50
- route:
- destination:
host: helloworld
subset: v1
EOF
&lt;/code>&lt;/pre>
&lt;p>和以前一样，绑定到 2 个版本 Deployment 的自动缩放器会相应地自动管理副本，但这对流量分配没有影响。&lt;/p>
&lt;h2 id="summary">总结&lt;/h2>
&lt;p>本文中，我们看到了 Istio 如何支持通用可扩展的金丝雀部署，以及与 Kubernetes 部署的差异。Istio 服务网格提供了管理流量分配所需的基础控制，并完全独立于部署缩放。这允许简单而强大的方式来进行金丝雀测试和上线。&lt;/p>
&lt;p>支持金丝雀部署的智能路由只是 Istio 的众多功能之一，它将使基于大型微服务的应用程序的生产部署变得更加简单。查看 &lt;a href="/v1.8/zh/">istio.io&lt;/a> 了解更多信息。&lt;/p>
&lt;p>可在&lt;a href="https://github.com/istio/istio/tree/release-1.8/samples/helloworld">此处&lt;/a>查看示例代码。&lt;/p></description><pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2017/0.1-canary/</link><author>Frank Budinsky</author><guid isPermaLink="true">/v1.8/zh/blog/2017/0.1-canary/</guid><category>traffic-management</category><category>canary</category></item><item><title>使用 Istio 增强端到端安全</title><description>
&lt;p>传统的网络安全方式无法解决部署在动态变化环境下分布式应用的安全威胁。这里，我们将描述 Istio Auth 如何帮助企业将其安全从边界保护转变为内部所有服务间通信保护。使用 Istio Auth 开发人员和运维人员可以在不改动程序代码的情况下，对于敏感数据进行保护，防止未经授权的内部人员访问。&lt;/p>
&lt;p>Istio Auth 是更广泛的 &lt;a href="/v1.8/zh">Istio 平台&lt;/a>的安全组件。它结合了 Google 生产环境中保护数百万微服务安全的经验。&lt;/p>
&lt;h2 id="background">背景知识&lt;/h2>
&lt;p>现代应用程序体系结构越来越多地基于共享服务，共享服务部署在云平台上，可被方便地进行动态部署和扩容。传统的网络边界安全性（例如防火墙）控制力度太粗，会导致部分非预期的客户端访问。使用盗取合法客户端的认证令牌进行重放攻击，就是一种常见的安全风险。对于持有敏感数据公司而言，内部威胁是一个需要关注的主要风险。其他网络安全方法（如 IP 白名单）通过静态方式定义，难以大规模管理，不适合动态变化的生产环境。&lt;/p>
&lt;p>因此，安全管理员需要一种工具，其可以能够默认开启并且始终保护生产环境中服务间的所有通信。&lt;/p>
&lt;h2 id="solution-strong-service-identity-and-authentication">解决方案：增强的服务身份和验证&lt;/h2>
&lt;p>多年来，Google 通过研发架构和技术，帮助其生产环境中数百万个微服务抵御了外部攻击和内部威胁。关键安全原则包括信任端而不是网络，基于服务身份和级别授权的双向强身份验证。Istio Auth 基于相同的原则。&lt;/p>
&lt;p>Istio Auth 服务 0.1 版本在 Kubernetes 上运行，并提供以下功能：&lt;/p>
&lt;ul>
&lt;li>&lt;p>服务间强身份认证&lt;/p>&lt;/li>
&lt;li>&lt;p>访问控制以限制可以访问服务（及其数据）的身份&lt;/p>&lt;/li>
&lt;li>&lt;p>传输中的数据自动加密&lt;/p>&lt;/li>
&lt;li>&lt;p>密钥和证书的大规模管理&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>Istio Auth 基于双向 TLS 和 X.509 等行业标准。此外，Google 还积极参与一个开放的，社区驱动的 &lt;a href="https://spiffe.io/">SPIFFE&lt;/a> 服务安全框架。随着 &lt;a href="https://spiffe.io/">SPIFFE&lt;/a> 规范的成熟，我们打算让 Istio 安全验证参考并实现。&lt;/p>
&lt;p>下图描述了 Kubernetes 上 Istio Auth 服务的体系结构。&lt;/p>
&lt;figure style="width:100%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:56.25%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2017/0.1-auth/istio_auth_overview.svg" title="Istio Auth 概览">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2017/0.1-auth/istio_auth_overview.svg" alt="Istio Auth 概览" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio Auth 概览&lt;/figcaption>
&lt;/figure>
&lt;p>上图说明了三个关键的安全功能：&lt;/p>
&lt;h3 id="strong-identity">强身份认证&lt;/h3>
&lt;p>Istio Auth 使用了 &lt;a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/">Kubernetes 服务帐户&lt;/a>来识别服务运行的身份。身份用于建立信任和定义服务级别访问策略。身份在服务部署时分配，并在 X.509 证书的 SAN（主题备用名称）字段中进行编码。使用服务帐户作为身份具有以下优点：&lt;/p>
&lt;ul>
&lt;li>&lt;p>管理员可以使用 Kubernetes 1.6 中引入的 &lt;a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC&lt;/a> 功能配置谁有权访问服务帐户&lt;/p>&lt;/li>
&lt;li>&lt;p>灵活地识别人类用户，服务或一组服务&lt;/p>&lt;/li>
&lt;li>&lt;p>稳定地支持服务身份的动态配置和工作负载自动扩展&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="communication-security">通信安全&lt;/h3>
&lt;p>服务间通信基于高性能客户端和服务器端 &lt;a href="https://envoyproxy.github.io/envoy/">Envoy&lt;/a> 代理的传输隧道。代理之间的通信使用双向 TLS 来进行保护。使用双向 TLS 的好处是服务身份不会被替换为从源窃取或重放攻击的令牌。Istio Auth 还引入了安全命名的概念，以防止服务器欺骗攻击 - 客户端代理验证允许验证特定服务的授权的服务帐户。&lt;/p>
&lt;h3 id="key-management-and-distribution">密钥管理和分配&lt;/h3>
&lt;p>Istio Auth 为每个集群提供 CA（证书颁发机构），并可对密钥和证书自动管理。这种情况下，Istio Auth 具备以下功能 ：&lt;/p>
&lt;ul>
&lt;li>&lt;p>为每个服务帐户生成密钥和证书对。&lt;/p>&lt;/li>
&lt;li>&lt;p>使用 &lt;a href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes Secrets&lt;/a> 将密钥和证书分发到相应的 pod。&lt;/p>&lt;/li>
&lt;li>&lt;p>定期轮换密钥和证书。&lt;/p>&lt;/li>
&lt;li>&lt;p>必要时（未来）撤销特定密钥和证书对。&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>下图说明了 Kubernetes 上的端到端 Istio Auth 工作流程：&lt;/p>
&lt;figure style="width:100%">
&lt;div class="wrapper-with-intrinsic-ratio" style="padding-bottom:56.25%">
&lt;a data-skipendnotes="true" href="/v1.8/zh/blog/2017/0.1-auth/istio_auth_workflow.svg" title="Istio Auth 工作流程">
&lt;img class="element-to-stretch" src="/v1.8/zh/blog/2017/0.1-auth/istio_auth_workflow.svg" alt="Istio Auth 工作流程" />
&lt;/a>
&lt;/div>
&lt;figcaption>Istio Auth 工作流程&lt;/figcaption>
&lt;/figure>
&lt;p>Istio Auth 是更广泛的容器安全中的一部分。Red Hat 是 Kubernetes 开发的合作伙伴，定义了 &lt;a href="https://www.redhat.com/en/resources/container-security-openshift-cloud-devops-whitepaper">10 层&lt;/a>容器安全。Istio 和 Istio Auth 解决了其中两个层：”网络隔离” 和 “API 和服务端点管理”。随着集群联邦在 Kubernetes 和其他平台上的发展，我们的目的是让 Istio 对跨越多个联邦集群的服务间通信提供保护。&lt;/p>
&lt;h2 id="benefits-of-Istio-authentication">Istio Auth 的优点&lt;/h2>
&lt;p>&lt;strong>深度防御&lt;/strong>：当与 Kubernetes（或基础架构）网络策略结合使用时，用户可以获得更多的安全信心，因为他们知道 Pod 或服务间的通信在网络层和应用层上都得到保护。&lt;/p>
&lt;p>&lt;strong>默认安全&lt;/strong>：当与 Istio 的代理和集中策略引擎一起使用时，可在极少或不更改应用的情况下部署并配置 Istio Auth 。因此，管理员和操作员可以确保默认开启服务通信保护，并且可以跨协议和运行时一致地实施这些策略。&lt;/p>
&lt;p>&lt;strong>强大的服务认证&lt;/strong>：Istio Auth 使用双向 TLS 保护服务通信，以确保服务身份不会是其他来源窃取或重放攻击的令牌。这可确保只能从经过严格身份验证和授权的客户端才能够访问具有敏感数据的服务。&lt;/p>
&lt;h2 id="join-us-in-this-journey">加入我们&lt;/h2>
&lt;p>Istio Auth 是提供完整安全功能的第一步，安全功能可以用于抵御外部攻击和内部威胁，保护服务的敏感数据。虽然初始版本仅在 Kubernetes 上运行，但我们的目标是使其能够在不同的生产环境中保护服务通信。我们鼓励更多的社区&lt;a href="https://github.com/istio/istio/tree/release-1.8/security">加入我们&lt;/a>，为不同的应用技术栈和运行平台上轻松地提供强大的服务安全保障。&lt;/p></description><pubDate>Thu, 25 May 2017 00:00:00 +0000</pubDate><link>/v1.8/zh/blog/2017/0.1-auth/</link><author>The Istio Team</author><guid isPermaLink="true">/v1.8/zh/blog/2017/0.1-auth/</guid></item></channel></rss>