---
title: Identity provision through SDS
description: Shows how to enable SDS(secret discovery service) for istio identity provision.
weight: 70
keywords: [security,auth-sds]
---

This task shows how to enable SDS(secret discovery service) for istio identity provision.

Today in istio workload identity(cert/key) are generated by Citadel and distributed to sidecars 
through secret-mount files, this approach has below side effects:
* Traffic interruption: 
  When cert rotation happens, envoy(pilot agent) needs to restart to pick up key/cert update, 
  which causes traffic interruption. 
* Potential security issue: 
  Since key/cert are file-mounted to sidecars, hackers could remote to sidecar container and steal key/cert content.

To solve the above issues, from Istio 1.1, Istio supports identity provision through SDS(secret discovery service).

Workload requests key/cert from SDS server(nodeagent agent, which runs as per-node daemonSet) using k8s service account JWT follow
envoy SDS API, nodeagent agent generates private key and send CSR request to Citadel, which will sign the certificate chain, and key/cert 
will eventually sent back to workload sidecar through SDS server(nodeagent agent). Since key/cert is stored in workload sidecar memory in 
SDS flow, workload doesn't need to restart to pick up the cert change when rotation happens.

## Before you begin

* Set up Istio by following the instructions using [Helm](/docs/setup/kubernetes/helm-install/) with global mutual TLS enabled:

    {{< text bash >}}
    $ cat install/kubernetes/namespace.yaml > istio-auth-sds.yaml
    $ cat install/kubernetes/helm/istio-init/files/crd-* >> istio-auth-sds.yaml
    $ helm dep update --skip-refresh install/kubernetes/helm/istio
    $ helm template install/kubernetes/helm/istio --name istio --namespace istio-system --values install/kubernetes/helm/istio/values-istio-sds-auth.yaml >> istio-auth-sds.yaml
    $ kubectl create -f istio-auth-sds.yaml
    {{< /text >}}

## service-to-service mutual TLS using key/cert provisioned by SDS

Follow task in authn-policy to setup test services.

{{< text bash >}}
$ kubectl create ns foo
$ kubectl apply -f <(istioctl kube-inject -f samples/httpbin/httpbin.yaml) -n foo
$ kubectl apply -f <(istioctl kube-inject -f samples/sleep/sleep.yaml) -n foo
$ ubectl create ns bar
$ kubectl apply -f <(istioctl kube-inject -f samples/httpbin/httpbin.yaml) -n bar
$ kubectl apply -f <(istioctl kube-inject -f samples/sleep/sleep.yaml) -n bar
{{< /text >}}


all mutual TLS requests succeed 
{{< text bash >}}
$ for from in "foo" "bar"; do for to in "foo" "bar"; do kubectl exec $(kubectl get pod -l app=sleep -n ${from} -o jsonpath={.items..metadata.name}) -c sleep -n ${from} -- curl "http://httpbin.${to}:8000/ip" -s -o /dev/null -w "sleep.${from} to httpbin.${to}: %{http_code}\n"; done; done
sleep.foo to httpbin.foo: 200
sleep.foo to httpbin.bar: 200
sleep.bar to httpbin.foo: 200
sleep.bar to httpbin.bar: 200
{{< /text >}}

## Verifying no secret-mount file is generated

As mentioned earier, instead of using secret-mount file, key/cert provisioned by SDS flow is stored in workload sidecar memory,
Let's verify that in this section by remote to workload sidecar container we just deployed.

{{< text bash >}}
$ kubectl exec -it $(kubectl get pod -l app=sleep -n foo -o jsonpath={.items..metadata.name}) -c istio-proxy -n foo  -- /bin/bash
{{< /text >}}


## Cleanup

    {{< text bash >}}
    $ kubectl delete -f istio-auth-sds.yaml
    {{< /text >}}
