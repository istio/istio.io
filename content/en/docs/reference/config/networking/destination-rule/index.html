---
WARNING: THIS IS AN AUTO-GENERATED FILE, DO NOT EDIT. PLEASE MODIFY THE ORIGINAL SOURCE IN THE 'https://github.com/ericvn/api' REPO
source_repo: https://github.com/ericvn/api
title: Destination Rule
description: Configuration affecting load balancing, outlier detection, etc.
location: https://istio.io/docs/reference/config/networking/destination-rule.html
layout: partner-component
generator: protoc-gen-docs
schema: istio.networking.v1alpha3.DestinationRule
aliases: [/docs/reference/config/networking/v1alpha3/destination-rule]
number_of_entries: 23
---
<p><code>DestinationRule</code> defines policies that apply to traffic intended for a<br />
service after routing has occurred. These rules specify configuration<br />
for load balancing, connection pool size from the sidecar, and outlier<br />
detection settings to detect and evict unhealthy hosts from the load<br />
balancing pool. For example, a simple load balancing policy for the<br />
ratings service would look as follows:</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p>Version specific policies can be specified by defining a named<br />
<code>subset</code> and overriding the settings specified at the service level. The<br />
following rule uses a round robin load balancing policy for all traffic<br />
going to a subset named testversion that is composed of endpoints (e.g.,<br />
pods) with labels (version:v3).</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
  subsets:
  - name: testversion
    labels:
      version: v3
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
  subsets:
  - name: testversion
    labels:
      version: v3
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p><strong>Note:</strong> Policies specified for subsets will not take effect until<br />
a route rule explicitly sends traffic to this subset.</p>
<p>Traffic policies can be customized to specific ports as well. The<br />
following rule uses the least connection load balancing policy for all<br />
traffic to port 80, while uses a round robin load balancing setting for<br />
traffic to the port 9080.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-ratings-port
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy: # Apply to all ports
    portLevelSettings:
    - port:
        number: 80
      loadBalancer:
        simple: LEAST_REQUEST
    - port:
        number: 9080
      loadBalancer:
        simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-ratings-port
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy: # Apply to all ports
    portLevelSettings:
    - port:
        number: 80
      loadBalancer:
        simple: LEAST_REQUEST
    - port:
        number: 9080
      loadBalancer:
        simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p>Destination Rules can be customized to specific workloads as well.<br />
The following example shows how a destination rule can be applied to a<br />
specific workload using the workloadSelector configuration.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: configure-client-mtls-dr-with-workloadselector
spec:
  host: example.com
  workloadSelector:
    matchLabels:
      app: ratings
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    portLevelSettings:
    - port:
        number: 31443
      tls:
        credentialName: client-credential
        mode: MUTUAL
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: configure-client-mtls-dr-with-workloadselector
spec:
  host: example.com
  workloadSelector:
    matchLabels:
      app: ratings
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
    portLevelSettings:
    - port:
        number: 31443
      tls:
        credentialName: client-credential
        mode: MUTUAL
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>

<h2 id="DestinationRule">DestinationRule</h2>
<section>
<p>DestinationRule defines policies that apply to traffic intended for a service<br />
after routing has occurred.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="DestinationRule-host">
<td><code>host</code></td>
<td><code>string</code></td>
<td>
<p>The name of a service from the service registry. Service<br />
names are looked up from the platform's service registry (e.g.,<br />
Kubernetes services, Consul services, etc.) and from the hosts<br />
declared by <a href="/docs/reference/config/networking/service-entry/#ServiceEntry">ServiceEntries</a>. Rules defined for<br />
services that do not exist in the service registry will be ignored.</p>
<p><em>Note for Kubernetes users</em>: When short names are used (e.g. &quot;reviews&quot;<br />
instead of &quot;reviews.default.svc.cluster.local&quot;), Istio will interpret<br />
the short name based on the namespace of the rule, not the service. A<br />
rule in the &quot;default&quot; namespace containing a host &quot;reviews&quot; will be<br />
interpreted as &quot;reviews.default.svc.cluster.local&quot;, irrespective of<br />
the actual namespace associated with the reviews service. <em>To avoid<br />
potential misconfigurations, it is recommended to always use fully<br />
qualified domain names over short names.</em></p>
<p>Note that the host field applies to both HTTP and TCP services.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="DestinationRule-traffic_policy">
<td><code>trafficPolicy</code></td>
<td><code><a href="#TrafficPolicy">TrafficPolicy</a></code></td>
<td>
<p>Traffic policies to apply (load balancing policy, connection pool<br />
sizes, outlier detection).</p>

</td>
<td>
No
</td>
</tr>
<tr id="DestinationRule-subsets">
<td><code>subsets</code></td>
<td><code><a href="#Subset">Subset[]</a></code></td>
<td>
<p>One or more named sets that represent individual versions of a<br />
service. Traffic policies can be overridden at subset level.</p>

</td>
<td>
No
</td>
</tr>
<tr id="DestinationRule-export_to">
<td><code>exportTo</code></td>
<td><code>string[]</code></td>
<td>
<p>A list of namespaces to which this destination rule is exported.<br />
The resolution of a destination rule to apply to a service occurs in the<br />
context of a hierarchy of namespaces. Exporting a destination rule allows<br />
it to be included in the resolution hierarchy for services in<br />
other namespaces. This feature provides a mechanism for service owners<br />
and mesh administrators to control the visibility of destination rules<br />
across namespace boundaries.</p>
<p>If no namespaces are specified then the destination rule is exported to all<br />
namespaces by default.</p>
<p>The value &quot;.&quot; is reserved and defines an export to the same namespace that<br />
the destination rule is declared in. Similarly, the value &quot;*&quot; is reserved and<br />
defines an export to all namespaces.</p>

</td>
<td>
No
</td>
</tr>
<tr id="DestinationRule-workload_selector">
<td><code>workloadSelector</code></td>
<td><code><a href="/docs/reference/config/type/workload-selector/#WorkloadSelector">WorkloadSelector</a></code></td>
<td>
<p>Criteria used to select the specific set of pods/VMs on which this<br />
<code>DestinationRule</code> configuration should be applied. If specified, the <code>DestinationRule</code><br />
configuration will be applied only to the workload instances matching the workload selector<br />
label in the same namespace. Workload selectors do not apply across namespace boundaries.<br />
If omitted, the <code>DestinationRule</code> falls back to its default behavior.<br />
For example, if specific sidecars need to have egress TLS settings for services outside<br />
of the mesh, instead of every sidecar in the mesh needing to have the<br />
configuration (which is the default behaviour), a workload selector can be specified.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="TrafficPolicy">TrafficPolicy</h2>
<section>
<p>Traffic policies to apply for a specific destination, across all<br />
destination ports. See DestinationRule for examples.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="TrafficPolicy-load_balancer">
<td><code>loadBalancer</code></td>
<td><code><a href="#LoadBalancerSettings">LoadBalancerSettings</a></code></td>
<td>
<p>Settings controlling the load balancer algorithms.</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-connection_pool">
<td><code>connectionPool</code></td>
<td><code><a href="#ConnectionPoolSettings">ConnectionPoolSettings</a></code></td>
<td>
<p>Settings controlling the volume of connections to an upstream service</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-outlier_detection">
<td><code>outlierDetection</code></td>
<td><code><a href="#OutlierDetection">OutlierDetection</a></code></td>
<td>
<p>Settings controlling eviction of unhealthy hosts from the load balancing pool</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-tls">
<td><code>tls</code></td>
<td><code><a href="#ClientTLSSettings">ClientTLSSettings</a></code></td>
<td>
<p>TLS related settings for connections to the upstream service.</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-port_level_settings">
<td><code>portLevelSettings</code></td>
<td><code><a href="#TrafficPolicy-PortTrafficPolicy">PortTrafficPolicy[]</a></code></td>
<td>
<p>Traffic policies specific to individual ports. Note that port level<br />
settings will override the destination-level settings. Traffic<br />
settings specified at the destination-level will not be inherited when<br />
overridden by port-level settings, i.e. default values will be applied<br />
to fields omitted in port-level traffic policies.</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-tunnel">
<td><code>tunnel</code></td>
<td><code><a href="#TrafficPolicy-TunnelSettings">TunnelSettings</a></code></td>
<td>
<p>Configuration of tunneling TCP over other transport or application layers<br />
for the host configured in the DestinationRule.<br />
Tunnel settings can be applied to TCP or TLS routes and can't be applied to HTTP routes.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="Subset">Subset</h2>
<section>
<p>A subset of endpoints of a service. Subsets can be used for scenarios<br />
like A/B testing, or routing to a specific version of a service. Refer<br />
to <a href="/docs/reference/config/networking/virtual-service/#VirtualService">VirtualService</a> documentation for examples of using<br />
subsets in these scenarios. In addition, traffic policies defined at the<br />
service-level can be overridden at a subset-level. The following rule<br />
uses a round robin load balancing policy for all traffic going to a<br />
subset named testversion that is composed of endpoints (e.g., pods) with<br />
labels (version:v3).</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
  subsets:
  - name: testversion
    labels:
      version: v3
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: LEAST_REQUEST
  subsets:
  - name: testversion
    labels:
      version: v3
    trafficPolicy:
      loadBalancer:
        simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p><strong>Note:</strong> Policies specified for subsets will not take effect until<br />
a route rule explicitly sends traffic to this subset.</p>
<p>One or more labels are typically required to identify the subset destination,<br />
however, when the corresponding DestinationRule represents a host that<br />
supports multiple SNI hosts (e.g., an egress gateway), a subset without labels<br />
may be meaningful. In this case a traffic policy with <a href="#ClientTLSSettings">ClientTLSSettings</a><br />
can be used to identify a specific SNI host corresponding to the named subset.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="Subset-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>Name of the subset. The service name and the subset name can<br />
be used for traffic splitting in a route rule.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="Subset-labels">
<td><code>labels</code></td>
<td><code>map&lt;string,&nbsp;string&gt;</code></td>
<td>
<p>Labels apply a filter over the endpoints of a service in the<br />
service registry. See route rules for examples of usage.</p>

</td>
<td>
No
</td>
</tr>
<tr id="Subset-traffic_policy">
<td><code>trafficPolicy</code></td>
<td><code><a href="#TrafficPolicy">TrafficPolicy</a></code></td>
<td>
<p>Traffic policies that apply to this subset. Subsets inherit the<br />
traffic policies specified at the DestinationRule level. Settings<br />
specified at the subset level will override the corresponding settings<br />
specified at the DestinationRule level.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LoadBalancerSettings">LoadBalancerSettings</h2>
<section>
<p>Load balancing policies to apply for a specific destination. See Envoy's<br />
load balancing<br />
<a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/load_balancing">documentation</a><br />
for more details.</p>
<p>For example, the following rule uses a round robin load balancing policy<br />
for all traffic going to the ratings service.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      simple: ROUND_ROBIN
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p>The following example sets up sticky sessions for the ratings service<br />
hashing-based load balancer for the same ratings service using the<br />
the User cookie as the hash key.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      consistentHash:
        httpCookie:
          name: user
          ttl: 0s
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-ratings
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    loadBalancer:
      consistentHash:
        httpCookie:
          name: user
          ttl: 0s
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LoadBalancerSettings-simple" class="oneof oneof-start">
<td><code>simple</code></td>
<td><code><a href="#LoadBalancerSettings-SimpleLB">SimpleLB (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-consistent_hash" class="oneof">
<td><code>consistentHash</code></td>
<td><code><a href="#LoadBalancerSettings-ConsistentHashLB">ConsistentHashLB (oneof)</a></code></td>
<td>
</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-locality_lb_setting">
<td><code>localityLbSetting</code></td>
<td><code><a href="#LocalityLoadBalancerSetting">LocalityLoadBalancerSetting</a></code></td>
<td>
<p>Locality load balancer settings, this will override mesh wide settings in entirety, meaning no merging would be performed<br />
between this object and the object one in MeshConfig</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-warmup_duration_secs">
<td><code>warmupDurationSecs</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>Represents the warmup duration of Service. If set, the newly created endpoint of service<br />
remains in warmup mode starting from its creation time for the duration of this window and<br />
Istio progressively increases amount of traffic for that endpoint instead of sending proportional amount of traffic.<br />
This should be enabled for services that require warm up time to serve full production load with reasonable latency.<br />
Currently this is only supported for ROUND_ROBIN and LEAST_REQUEST load balancers.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ConnectionPoolSettings">ConnectionPoolSettings</h2>
<section>
<p>Connection pool settings for an upstream host. The settings apply to<br />
each individual host in the upstream service.  See Envoy's <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking">circuit<br />
breaker</a><br />
for more details. Connection pool settings can be applied at the TCP<br />
level as well as at HTTP level.</p>
<p>For example, the following rule sets a limit of 100 connections to redis<br />
service called myredissrv with a connect timeout of 30ms</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: bookinfo-redis
spec:
  host: myredissrv.prod.svc.cluster.local
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
        connectTimeout: 30ms
        tcpKeepalive:
          time: 7200s
          interval: 75s
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: bookinfo-redis
spec:
  host: myredissrv.prod.svc.cluster.local
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
        connectTimeout: 30ms
        tcpKeepalive:
          time: 7200s
          interval: 75s
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="ConnectionPoolSettings-tcp">
<td><code>tcp</code></td>
<td><code><a href="#ConnectionPoolSettings-TCPSettings">TCPSettings</a></code></td>
<td>
<p>Settings common to both HTTP and TCP upstream connections.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-http">
<td><code>http</code></td>
<td><code><a href="#ConnectionPoolSettings-HTTPSettings">HTTPSettings</a></code></td>
<td>
<p>HTTP connection pool settings.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="OutlierDetection">OutlierDetection</h2>
<section>
<p>A Circuit breaker implementation that tracks the status of each<br />
individual host in the upstream service.  Applicable to both HTTP and<br />
TCP services.  For HTTP services, hosts that continually return 5xx<br />
errors for API calls are ejected from the pool for a pre-defined period<br />
of time. For TCP services, connection timeouts or connection<br />
failures to a given host counts as an error when measuring the<br />
consecutive errors metric. See Envoy's <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier">outlier<br />
detection</a><br />
for more details.</p>
<p>The following rule sets a connection pool size of 100 HTTP1 connections<br />
with no more than 10 req/connection to the &quot;reviews&quot; service. In addition,<br />
it sets a limit of 1000 concurrent HTTP2 requests and configures upstream<br />
hosts to be scanned every 5 mins so that any host that fails 7 consecutive<br />
times with a 502, 503, or 504 error code will be ejected for 15 minutes.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: reviews-cb-policy
spec:
  host: reviews.prod.svc.cluster.local
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http2MaxRequests: 1000
        maxRequestsPerConnection: 10
    outlierDetection:
      consecutive5xxErrors: 7
      interval: 5m
      baseEjectionTime: 15m
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: reviews-cb-policy
spec:
  host: reviews.prod.svc.cluster.local
  trafficPolicy:
    connectionPool:
      tcp:
        maxConnections: 100
      http:
        http2MaxRequests: 1000
        maxRequestsPerConnection: 10
    outlierDetection:
      consecutive5xxErrors: 7
      interval: 5m
      baseEjectionTime: 15m
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="OutlierDetection-split_external_local_origin_errors">
<td><code>splitExternalLocalOriginErrors</code></td>
<td><code>bool</code></td>
<td>
<p>Determines whether to distinguish local origin failures from external errors. If set to true<br />
consecutive_local_origin_failure is taken into account for outlier detection calculations.<br />
This should be used when you want to derive the outlier detection status based on the errors<br />
seen locally such as failure to connect, timeout while connecting etc. rather than the status code<br />
retuned by upstream service. This is especially useful when the upstream service explicitly returns<br />
a 5xx for some requests and you want to ignore those responses from upstream service while determining<br />
the outlier detection status of a host.<br />
Defaults to false.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-consecutive_local_origin_failures">
<td><code>consecutiveLocalOriginFailures</code></td>
<td><code><a href="#google-protobuf-UInt32Value">UInt32Value</a></code></td>
<td>
<p>The number of consecutive locally originated failures before ejection<br />
occurs. Defaults to 5. Parameter takes effect only when split_external_local_origin_errors<br />
is set to true.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-consecutive_gateway_errors">
<td><code>consecutiveGatewayErrors</code></td>
<td><code><a href="#google-protobuf-UInt32Value">UInt32Value</a></code></td>
<td>
<p>Number of gateway errors before a host is ejected from the connection pool.<br />
When the upstream host is accessed over HTTP, a 502, 503, or 504 return<br />
code qualifies as a gateway error. When the upstream host is accessed over<br />
an opaque TCP connection, connect timeouts and connection error/failure<br />
events qualify as a gateway error.<br />
This feature is disabled by default or when set to the value 0.</p>
<p>Note that consecutive_gateway_errors and consecutive_5xx_errors can be<br />
used separately or together. Because the errors counted by<br />
consecutive_gateway_errors are also included in consecutive_5xx_errors,<br />
if the value of consecutive_gateway_errors is greater than or equal to<br />
the value of consecutive_5xx_errors, consecutive_gateway_errors will have<br />
no effect.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-consecutive_5xx_errors">
<td><code>consecutive5xxErrors</code></td>
<td><code><a href="#google-protobuf-UInt32Value">UInt32Value</a></code></td>
<td>
<p>Number of 5xx errors before a host is ejected from the connection pool.<br />
When the upstream host is accessed over an opaque TCP connection, connect<br />
timeouts, connection error/failure and request failure events qualify as a<br />
5xx error.<br />
This feature defaults to 5 but can be disabled by setting the value to 0.</p>
<p>Note that consecutive_gateway_errors and consecutive_5xx_errors can be<br />
used separately or together. Because the errors counted by<br />
consecutive_gateway_errors are also included in consecutive_5xx_errors,<br />
if the value of consecutive_gateway_errors is greater than or equal to<br />
the value of consecutive_5xx_errors, consecutive_gateway_errors will have<br />
no effect.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-interval">
<td><code>interval</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>Time interval between ejection sweep analysis. format:<br />
1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-base_ejection_time">
<td><code>baseEjectionTime</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>Minimum ejection duration. A host will remain ejected for a period<br />
equal to the product of minimum ejection duration and the number of<br />
times the host has been ejected. This technique allows the system to<br />
automatically increase the ejection period for unhealthy upstream<br />
servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-max_ejection_percent">
<td><code>maxEjectionPercent</code></td>
<td><code>int32</code></td>
<td>
<p>Maximum % of hosts in the load balancing pool for the upstream<br />
service that can be ejected. Defaults to 10%.</p>

</td>
<td>
No
</td>
</tr>
<tr id="OutlierDetection-min_health_percent">
<td><code>minHealthPercent</code></td>
<td><code>int32</code></td>
<td>
<p>Outlier detection will be enabled as long as the associated load balancing<br />
pool has at least min_health_percent hosts in healthy mode. When the<br />
percentage of healthy hosts in the load balancing pool drops below this<br />
threshold, outlier detection will be disabled and the proxy will load balance<br />
across all hosts in the pool (healthy and unhealthy). The threshold can be<br />
disabled by setting it to 0%. The default is 0% as it's not typically<br />
applicable in k8s environments with few pods per service.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ClientTLSSettings">ClientTLSSettings</h2>
<section>
<p>SSL/TLS related settings for upstream connections. See Envoy's <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/transport_sockets/tls/v3/common.proto.html#common-tls-configuration">TLS<br />
context</a><br />
for more details. These settings are common to both HTTP and TCP upstreams.</p>
<p>For example, the following rule configures a client to use mutual TLS<br />
for connections to upstream database cluster.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: db-mtls
spec:
  host: mydbserver.prod.svc.cluster.local
  trafficPolicy:
    tls:
      mode: MUTUAL
      clientCertificate: /etc/certs/myclientcert.pem
      privateKey: /etc/certs/client_private_key.pem
      caCertificates: /etc/certs/rootcacerts.pem
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: db-mtls
spec:
  host: mydbserver.prod.svc.cluster.local
  trafficPolicy:
    tls:
      mode: MUTUAL
      clientCertificate: /etc/certs/myclientcert.pem
      privateKey: /etc/certs/client_private_key.pem
      caCertificates: /etc/certs/rootcacerts.pem
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p>The following rule configures a client to use TLS when talking to a<br />
foreign service whose domain matches *.foo.com.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: tls-foo
spec:
  host: &quot;*.foo.com&quot;
  trafficPolicy:
    tls:
      mode: SIMPLE
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: tls-foo
spec:
  host: &quot;*.foo.com&quot;
  trafficPolicy:
    tls:
      mode: SIMPLE
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<p>The following rule configures a client to use Istio mutual TLS when talking<br />
to rating services.</p>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: DestinationRule
metadata:
  name: ratings-istio-mtls
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
</code></pre>
<p>{{<!-- raw HTML omitted -->}}</p>
<p>{{<!-- raw HTML omitted -->}}</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: ratings-istio-mtls
spec:
  host: ratings.prod.svc.cluster.local
  trafficPolicy:
    tls:
      mode: ISTIO_MUTUAL
</code></pre>
<p>{{<!-- raw HTML omitted -->}}<br />
{{<!-- raw HTML omitted -->}}</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="ClientTLSSettings-mode">
<td><code>mode</code></td>
<td><code><a href="#ClientTLSSettings-TLSmode">TLSmode</a></code></td>
<td>
<p>Indicates whether connections to this port should be secured<br />
using TLS. The value of this field determines how TLS is enforced.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="ClientTLSSettings-client_certificate">
<td><code>clientCertificate</code></td>
<td><code>string</code></td>
<td>
<p>REQUIRED if mode is <code>MUTUAL</code>. The path to the file holding the<br />
client-side TLS certificate to use.<br />
Should be empty if mode is <code>ISTIO_MUTUAL</code>.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ClientTLSSettings-private_key">
<td><code>privateKey</code></td>
<td><code>string</code></td>
<td>
<p>REQUIRED if mode is <code>MUTUAL</code>. The path to the file holding the<br />
client's private key.<br />
Should be empty if mode is <code>ISTIO_MUTUAL</code>.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ClientTLSSettings-ca_certificates">
<td><code>caCertificates</code></td>
<td><code>string</code></td>
<td>
<p>OPTIONAL: The path to the file containing certificate authority<br />
certificates to use in verifying a presented server certificate. If<br />
omitted, the proxy will not verify the server's certificate.<br />
Should be empty if mode is <code>ISTIO_MUTUAL</code>.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ClientTLSSettings-credential_name">
<td><code>credentialName</code></td>
<td><code>string</code></td>
<td>
<p>The name of the secret that holds the TLS certs for the<br />
client including the CA certificates. Secret must exist in the<br />
same namespace with the proxy using the certificates.<br />
The secret (of type <code>generic</code>)should contain the<br />
following keys and values: <code>key: &lt;privateKey&gt;</code>,<br />
<code>cert: &lt;clientCert&gt;</code>, <code>cacert: &lt;CACertificate&gt;</code>.<br />
Here CACertificate is used to verify the server certificate.<br />
Secret of type tls for client certificates along with<br />
ca.crt key for CA certificates is also supported.<br />
Only one of client certificates and CA certificate<br />
or credentialName can be specified.</p>
<p><strong>NOTE:</strong> This field is applicable at sidecars only if<br />
<code>DestinationRule</code> has a <code>workloadSelector</code> specified.<br />
Otherwise the field will be applicable only at gateways, and<br />
sidecars will continue to use the certificate paths.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ClientTLSSettings-subject_alt_names">
<td><code>subjectAltNames</code></td>
<td><code>string[]</code></td>
<td>
<p>A list of alternate names to verify the subject identity in the<br />
certificate. If specified, the proxy will verify that the server<br />
certificate's subject alt name matches one of the specified values.<br />
If specified, this list overrides the value of subject_alt_names<br />
from the ServiceEntry. If unspecified, automatic validation of upstream<br />
presented certificate for new upstream connections will be done based on the<br />
downstream HTTP host/authority header, provided <code>VERIFY_CERT_AT_CLIENT</code><br />
and <code>ENABLE_AUTO_SNI</code> environmental variables are set to <code>true</code>.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ClientTLSSettings-sni">
<td><code>sni</code></td>
<td><code>string</code></td>
<td>
<p>SNI string to present to the server during TLS handshake.<br />
If unspecified, SNI will be automatically set based on downstream HTTP<br />
host/authority header for SIMPLE and MUTUAL TLS modes, provided <code>ENABLE_AUTO_SNI</code><br />
environmental variable is set to <code>true</code>.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ClientTLSSettings-insecure_skip_verify">
<td><code>insecureSkipVerify</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#boolvalue">BoolValue</a></code></td>
<td>
<p>InsecureSkipVerify specifies whether the proxy should skip verifying the<br />
CA signature and SAN for the server certificate corresponding to the host.<br />
This flag should only be set if global CA signature verifcation is<br />
enabled, <code>VerifyCertAtClient</code> environmental variable is set to <code>true</code>,<br />
but no verification is desired for a specific host. If enabled with or<br />
without <code>VerifyCertAtClient</code> enabled, verification of the CA signature and<br />
SAN will be skipped.</p>
<p><code>InsecureSkipVerify</code> is <code>false</code> by default.<br />
<code>VerifyCertAtClient</code> is <code>false</code> by default in Istio version 1.9 but will<br />
be <code>true</code> by default in a later version where, going forward, it will be<br />
enabled by default.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LocalityLoadBalancerSetting">LocalityLoadBalancerSetting</h2>
<section>
<p>Locality-weighted load balancing allows administrators to control the<br />
distribution of traffic to endpoints based on the localities of where the<br />
traffic originates and where it will terminate. These localities are<br />
specified using arbitrary labels that designate a hierarchy of localities in<br />
{region}/{zone}/{sub-zone} form. For additional detail refer to<br />
<a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight">Locality Weight</a><br />
The following example shows how to setup locality weights mesh-wide.</p>
<p>Given a mesh with workloads and their service deployed to &quot;us-west/zone1/<em>&quot;<br />
and &quot;us-west/zone2/</em>&quot;. This example specifies that when traffic accessing a<br />
service originates from workloads in &quot;us-west/zone1/<em>&quot;, 80% of the traffic<br />
will be sent to endpoints in &quot;us-west/zone1/</em>&quot;, i.e the same zone, and the<br />
remaining 20% will go to endpoints in &quot;us-west/zone2/<em>&quot;. This setup is<br />
intended to favor routing traffic to endpoints in the same locality.<br />
A similar setting is specified for traffic originating in &quot;us-west/zone2/</em>&quot;.</p>
<pre><code class="language-yaml">  distribute:
    - from: us-west/zone1/*
      to:
        &quot;us-west/zone1/*&quot;: 80
        &quot;us-west/zone2/*&quot;: 20
    - from: us-west/zone2/*
      to:
        &quot;us-west/zone1/*&quot;: 20
        &quot;us-west/zone2/*&quot;: 80
</code></pre>
<p>If the goal of the operator is not to distribute load across zones and<br />
regions but rather to restrict the regionality of failover to meet other<br />
operational requirements an operator can set a 'failover' policy instead of<br />
a 'distribute' policy.</p>
<p>The following example sets up a locality failover policy for regions.<br />
Assume a service resides in zones within us-east, us-west &amp; eu-west<br />
this example specifies that when endpoints within us-east become unhealthy<br />
traffic should failover to endpoints in any zone or sub-zone within eu-west<br />
and similarly us-west should failover to us-east.</p>
<pre><code class="language-yaml"> failover:
   - from: us-east
     to: eu-west
   - from: us-west
     to: us-east
</code></pre>
<p>Locality load balancing settings.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LocalityLoadBalancerSetting-distribute">
<td><code>distribute</code></td>
<td><code><a href="#LocalityLoadBalancerSetting-Distribute">Distribute[]</a></code></td>
<td>
<p>Optional: only one of distribute, failover or failoverPriority can be set.<br />
Explicitly specify loadbalancing weight across different zones and geographical locations.<br />
Refer to <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/locality_weight">Locality weighted load balancing</a><br />
If empty, the locality weight is set according to the endpoints number within it.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalityLoadBalancerSetting-failover">
<td><code>failover</code></td>
<td><code><a href="#LocalityLoadBalancerSetting-Failover">Failover[]</a></code></td>
<td>
<p>Optional: only one of distribute, failover or failoverPriority can be set.<br />
Explicitly specify the region traffic will land on when endpoints in local region becomes unhealthy.<br />
Should be used together with OutlierDetection to detect unhealthy endpoints.<br />
Note: if no OutlierDetection specified, this will not take effect.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalityLoadBalancerSetting-failover_priority">
<td><code>failoverPriority</code></td>
<td><code>string[]</code></td>
<td>
<p>failoverPriority is an ordered list of labels used to sort endpoints to do priority based load balancing.<br />
This is to support traffic failover across different groups of endpoints.<br />
Suppose there are total N labels specified:</p>
<ol>
<li>Endpoints matching all N labels with the client proxy have priority P(0) i.e. the highest priority.</li>
<li>Endpoints matching the first N-1 labels with the client proxy have priority P(1) i.e. second highest priority.</li>
<li>By extension of this logic, endpoints matching only the first label with the client proxy has priority P(N-1) i.e. second lowest priority.</li>
<li>All the other endpoints have priority P(N) i.e. lowest priority.</li>
</ol>
<p>Note: For a label to be considered for match, the previous labels must match, i.e. nth label would be considered matched only if first n-1 labels match.</p>
<p>It can be any label specified on both client and server workloads.<br />
The following labels which have special semantic meaning are also supported:</p>
<ul>
<li><code>topology.istio.io/network</code> is used to match the network metadata of an endpoint, which can be specified by pod/namespace label <code>topology.istio.io/network</code>, sidecar env <code>ISTIO_META_NETWORK</code> or MeshNetworks.</li>
<li><code>topology.istio.io/cluster</code> is used to match the clusterID of an endpoint, which can be specified by pod label <code>topology.istio.io/cluster</code> or pod env <code>ISTIO_META_CLUSTER_ID</code>.</li>
<li><code>topology.kubernetes.io/region</code> is used to match the region metadata of an endpoint, which maps to Kubernetes node label <code>topology.kubernetes.io/region</code> or the deprecated label <code>failure-domain.beta.kubernetes.io/region</code>.</li>
<li><code>topology.kubernetes.io/zone</code> is used to match the zone metadata of an endpoint, which maps to Kubernetes node label <code>topology.kubernetes.io/zone</code> or the deprecated label <code>failure-domain.beta.kubernetes.io/zone</code>.</li>
<li><code>topology.istio.io/subzone</code> is used to match the subzone metadata of an endpoint, which maps to Istio node label <code>topology.istio.io/subzone</code>.</li>
</ul>
<p>The below topology config indicates the following priority levels:</p>
<pre><code class="language-yaml">failoverPriority:
- &quot;topology.istio.io/network&quot;
- &quot;topology.kubernetes.io/region&quot;
- &quot;topology.kubernetes.io/zone&quot;
- &quot;topology.istio.io/subzone&quot;
</code></pre>
<ol>
<li>endpoints match same [network, region, zone, subzone] label with the client proxy have the highest priority.</li>
<li>endpoints have same [network, region, zone] label but different [subzone] label with the client proxy have the second highest priority.</li>
<li>endpoints have same [network, region] label but different [zone] label with the client proxy have the third highest priority.</li>
<li>endpoints have same [network] but different [region] labels with the client proxy have the fourth highest priority.</li>
<li>all the other endpoints have the same lowest priority.</li>
</ol>
<p>Optional: only one of distribute, failover or failoverPriority can be set.<br />
And it should be used together with <code>OutlierDetection</code> to detect unhealthy endpoints, otherwise has no effect.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalityLoadBalancerSetting-enabled">
<td><code>enabled</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#boolvalue">BoolValue</a></code></td>
<td>
<p>enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.<br />
e.g. true means that turn on locality load balancing for this DestinationRule no matter what mesh wide settings is.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="TrafficPolicy-PortTrafficPolicy">TrafficPolicy.PortTrafficPolicy</h2>
<section>
<p>Traffic policies that apply to specific ports of the service</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="TrafficPolicy-PortTrafficPolicy-port">
<td><code>port</code></td>
<td><code><a href="/docs/reference/config/networking/virtual-service/#PortSelector">PortSelector</a></code></td>
<td>
<p>Specifies the number of a port on the destination service<br />
on which this policy is being applied.</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-PortTrafficPolicy-load_balancer">
<td><code>loadBalancer</code></td>
<td><code><a href="#LoadBalancerSettings">LoadBalancerSettings</a></code></td>
<td>
<p>Settings controlling the load balancer algorithms.</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-PortTrafficPolicy-connection_pool">
<td><code>connectionPool</code></td>
<td><code><a href="#ConnectionPoolSettings">ConnectionPoolSettings</a></code></td>
<td>
<p>Settings controlling the volume of connections to an upstream service</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-PortTrafficPolicy-outlier_detection">
<td><code>outlierDetection</code></td>
<td><code><a href="#OutlierDetection">OutlierDetection</a></code></td>
<td>
<p>Settings controlling eviction of unhealthy hosts from the load balancing pool</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-PortTrafficPolicy-tls">
<td><code>tls</code></td>
<td><code><a href="#ClientTLSSettings">ClientTLSSettings</a></code></td>
<td>
<p>TLS related settings for connections to the upstream service.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="TrafficPolicy-TunnelSettings">TrafficPolicy.TunnelSettings</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="TrafficPolicy-TunnelSettings-protocol">
<td><code>protocol</code></td>
<td><code>string</code></td>
<td>
<p>Specifies which protocol to use for tunneling the downstream connection.<br />
Supported protocols are:<br />
CONNECT - uses HTTP CONNECT;<br />
POST - uses HTTP POST.<br />
CONNECT is used by default if not specified.<br />
HTTP version for upstream requests is determined by the service protocol defined for the proxy.</p>

</td>
<td>
No
</td>
</tr>
<tr id="TrafficPolicy-TunnelSettings-target_host">
<td><code>targetHost</code></td>
<td><code>string</code></td>
<td>
<p>Specifies a host to which the downstream connection is tunneled.<br />
Target host must be an FQDN or IP address.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="TrafficPolicy-TunnelSettings-target_port">
<td><code>targetPort</code></td>
<td><code>uint32</code></td>
<td>
<p>Specifies a port to which the downstream connection is tunneled.</p>

</td>
<td>
Yes
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LoadBalancerSettings-ConsistentHashLB">LoadBalancerSettings.ConsistentHashLB</h2>
<section>
<p>Consistent Hash-based load balancing can be used to provide soft<br />
session affinity based on HTTP headers, cookies or other<br />
properties. The affinity to a particular destination host may be<br />
lost when one or more hosts are added/removed from the destination<br />
service.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LoadBalancerSettings-ConsistentHashLB-http_header_name" class="oneof oneof-start">
<td><code>httpHeaderName</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>Hash based on a specific HTTP header.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-http_cookie" class="oneof">
<td><code>httpCookie</code></td>
<td><code><a href="#LoadBalancerSettings-ConsistentHashLB-HTTPCookie">HTTPCookie (oneof)</a></code></td>
<td>
<p>Hash based on HTTP cookie.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-use_source_ip" class="oneof">
<td><code>useSourceIp</code></td>
<td><code>bool (oneof)</code></td>
<td>
<p>Hash based on the source IP address.<br />
This is applicable for both TCP and HTTP connections.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-http_query_parameter_name" class="oneof">
<td><code>httpQueryParameterName</code></td>
<td><code>string (oneof)</code></td>
<td>
<p>Hash based on a specific HTTP query parameter.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-ring_hash" class="oneof oneof-start">
<td><code>ringHash</code></td>
<td><code><a href="#LoadBalancerSettings-ConsistentHashLB-RingHash">RingHash (oneof)</a></code></td>
<td>
<p>The ring/modulo hash load balancer implements consistent hashing to backend hosts.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-maglev" class="oneof">
<td><code>maglev</code></td>
<td><code><a href="#LoadBalancerSettings-ConsistentHashLB-MagLev">MagLev (oneof)</a></code></td>
<td>
<p>The Maglev load balancer implements consistent hashing to backend hosts.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-minimum_ring_size" class="deprecated ">
<td><code>minimumRingSize</code></td>
<td><code>uint64</code></td>
<td>
<p>Deprecated. Use RingHash instead.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LoadBalancerSettings-ConsistentHashLB-RingHash">LoadBalancerSettings.ConsistentHashLB.RingHash</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LoadBalancerSettings-ConsistentHashLB-RingHash-minimum_ring_size">
<td><code>minimumRingSize</code></td>
<td><code>uint64</code></td>
<td>
<p>The minimum number of virtual nodes to use for the hash<br />
ring. Defaults to 1024. Larger ring sizes result in more granular<br />
load distributions. If the number of hosts in the load balancing<br />
pool is larger than the ring size, each host will be assigned a<br />
single virtual node.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LoadBalancerSettings-ConsistentHashLB-MagLev">LoadBalancerSettings.ConsistentHashLB.MagLev</h2>
<section>
<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LoadBalancerSettings-ConsistentHashLB-MagLev-table_size">
<td><code>tableSize</code></td>
<td><code>uint64</code></td>
<td>
<p>The table size for Maglev hashing. This helps in controlling the<br />
disruption when the backend hosts change.<br />
Increasing the table size reduces the amount of disruption.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LoadBalancerSettings-ConsistentHashLB-HTTPCookie">LoadBalancerSettings.ConsistentHashLB.HTTPCookie</h2>
<section>
<p>Describes a HTTP cookie that will be used as the hash key for the<br />
Consistent Hash load balancer. If the cookie is not present, it will<br />
be generated.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LoadBalancerSettings-ConsistentHashLB-HTTPCookie-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>Name of the cookie.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-HTTPCookie-path">
<td><code>path</code></td>
<td><code>string</code></td>
<td>
<p>Path to set for the cookie.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LoadBalancerSettings-ConsistentHashLB-HTTPCookie-ttl">
<td><code>ttl</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>Lifetime of the cookie.</p>

</td>
<td>
Yes
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ConnectionPoolSettings-TCPSettings">ConnectionPoolSettings.TCPSettings</h2>
<section>
<p>Settings common to both HTTP and TCP upstream connections.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="ConnectionPoolSettings-TCPSettings-max_connections">
<td><code>maxConnections</code></td>
<td><code>int32</code></td>
<td>
<p>Maximum number of HTTP1 /TCP connections to a destination host. Default 2^32-1.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-TCPSettings-connect_timeout">
<td><code>connectTimeout</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>TCP connection timeout. format:<br />
1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-TCPSettings-tcp_keepalive">
<td><code>tcpKeepalive</code></td>
<td><code><a href="#ConnectionPoolSettings-TCPSettings-TcpKeepalive">TcpKeepalive</a></code></td>
<td>
<p>If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-TCPSettings-max_connection_duration">
<td><code>maxConnectionDuration</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>The maximum duration of a connection. The duration is defined as the period since a connection<br />
was established. If not set, there is no max duration. When max_connection_duration<br />
is reached the connection will be closed. Duration must be at least 1ms.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ConnectionPoolSettings-HTTPSettings">ConnectionPoolSettings.HTTPSettings</h2>
<section>
<p>Settings applicable to HTTP1.1/HTTP2/GRPC connections.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="ConnectionPoolSettings-HTTPSettings-http1_max_pending_requests">
<td><code>http1MaxPendingRequests</code></td>
<td><code>int32</code></td>
<td>
<p>Maximum number of requests that will be queued while waiting for<br />
a ready connection pool connection. Default 1024.<br />
Refer to <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking">https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/circuit_breaking</a><br />
under which conditions a new connection is created for HTTP2.<br />
Please note that this is applicable to both HTTP/1.1 and HTTP2.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-http2_max_requests">
<td><code>http2MaxRequests</code></td>
<td><code>int32</code></td>
<td>
<p>Maximum number of active requests to a destination. Default 1024.<br />
Please note that this is applicable to both HTTP/1.1 and HTTP2.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-max_requests_per_connection">
<td><code>maxRequestsPerConnection</code></td>
<td><code>int32</code></td>
<td>
<p>Maximum number of requests per connection to a backend. Setting this<br />
parameter to 1 disables keep alive. Default 0, meaning &quot;unlimited&quot;,<br />
up to 2^29.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-max_retries">
<td><code>maxRetries</code></td>
<td><code>int32</code></td>
<td>
<p>Maximum number of retries that can be outstanding to all hosts in a<br />
cluster at a given time. Defaults to 2^32-1.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-idle_timeout">
<td><code>idleTimeout</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>The idle timeout for upstream connection pool connections. The idle timeout<br />
is defined as the period in which there are no active requests.<br />
If not set, the default is 1 hour. When the idle timeout is reached,<br />
the connection will be closed. If the connection is an HTTP/2<br />
connection a drain sequence will occur prior to closing the connection.<br />
Note that request based timeouts mean that HTTP/2 PINGs will not<br />
keep the connection alive. Applies to both HTTP1.1 and HTTP2 connections.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-h2_upgrade_policy">
<td><code>h2UpgradePolicy</code></td>
<td><code><a href="#ConnectionPoolSettings-HTTPSettings-H2UpgradePolicy">H2UpgradePolicy</a></code></td>
<td>
<p>Specify if http1.1 connection should be upgraded to http2 for the associated destination.</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-use_client_protocol">
<td><code>useClientProtocol</code></td>
<td><code>bool</code></td>
<td>
<p>If set to true, client protocol will be preserved while initiating connection to backend.<br />
Note that when this is set to true, h2_upgrade_policy will be ineffective i.e. the client<br />
connections will not be upgraded to http2.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ConnectionPoolSettings-TCPSettings-TcpKeepalive">ConnectionPoolSettings.TCPSettings.TcpKeepalive</h2>
<section>
<p>TCP keepalive.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="ConnectionPoolSettings-TCPSettings-TcpKeepalive-probes">
<td><code>probes</code></td>
<td><code>uint32</code></td>
<td>
<p>Maximum number of keepalive probes to send without response before<br />
deciding the connection is dead. Default is to use the OS level configuration<br />
(unless overridden, Linux defaults to 9.)</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-TCPSettings-TcpKeepalive-time">
<td><code>time</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>The time duration a connection needs to be idle before keep-alive<br />
probes start being sent. Default is to use the OS level configuration<br />
(unless overridden, Linux defaults to 7200s (ie 2 hours.)</p>

</td>
<td>
No
</td>
</tr>
<tr id="ConnectionPoolSettings-TCPSettings-TcpKeepalive-interval">
<td><code>interval</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration">Duration</a></code></td>
<td>
<p>The time duration between keep-alive probes.<br />
Default is to use the OS level configuration<br />
(unless overridden, Linux defaults to 75s.)</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LocalityLoadBalancerSetting-Distribute">LocalityLoadBalancerSetting.Distribute</h2>
<section>
<p>Describes how traffic originating in the 'from' zone or sub-zone is<br />
distributed over a set of 'to' zones. Syntax for specifying a zone is<br />
{region}/{zone}/{sub-zone} and terminal wildcards are allowed on any<br />
segment of the specification. Examples:</p>
<p><code>*</code> - matches all localities</p>
<p><code>us-west/*</code> - all zones and sub-zones within the us-west region</p>
<p><code>us-west/zone-1/*</code> - all sub-zones within us-west/zone-1</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LocalityLoadBalancerSetting-Distribute-from">
<td><code>from</code></td>
<td><code>string</code></td>
<td>
<p>Originating locality, '/' separated, e.g. 'region/zone/sub_zone'.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalityLoadBalancerSetting-Distribute-to">
<td><code>to</code></td>
<td><code>map&lt;string,&nbsp;uint32&gt;</code></td>
<td>
<p>Map of upstream localities to traffic distribution weights. The sum of<br />
all weights should be 100. Any locality not present will<br />
receive no traffic.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LocalityLoadBalancerSetting-Failover">LocalityLoadBalancerSetting.Failover</h2>
<section>
<p>Specify the traffic failover policy across regions. Since zone and sub-zone<br />
failover is supported by default this only needs to be specified for<br />
regions when the operator needs to constrain traffic failover so that<br />
the default behavior of failing over to any endpoint globally does not<br />
apply. This is useful when failing over traffic across regions would not<br />
improve service health or may need to be restricted for other reasons<br />
like regulatory controls.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="LocalityLoadBalancerSetting-Failover-from">
<td><code>from</code></td>
<td><code>string</code></td>
<td>
<p>Originating region.</p>

</td>
<td>
No
</td>
</tr>
<tr id="LocalityLoadBalancerSetting-Failover-to">
<td><code>to</code></td>
<td><code>string</code></td>
<td>
<p>Destination region the traffic will fail over to when endpoints in<br />
the 'from' region becomes unhealthy.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="google-protobuf-UInt32Value">google.protobuf.UInt32Value</h2>
<section>
<p>Wrapper message for <code>uint32</code>.</p>
<p>The JSON representation for <code>UInt32Value</code> is JSON number.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="google-protobuf-UInt32Value-value">
<td><code>value</code></td>
<td><code>uint32</code></td>
<td>
<p>The uint32 value.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="LoadBalancerSettings-SimpleLB">LoadBalancerSettings.SimpleLB</h2>
<section>
<p>Standard load balancing algorithms that require no tuning.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="LoadBalancerSettings-SimpleLB-UNSPECIFIED">
<td><code>UNSPECIFIED</code></td>
<td>
<p>No load balancing algorithm has been specified by the user. Istio<br />
will select an appropriate default.</p>

</td>
</tr>
<tr id="LoadBalancerSettings-SimpleLB-RANDOM">
<td><code>RANDOM</code></td>
<td>
<p>The random load balancer selects a random healthy host. The random<br />
load balancer generally performs better than round robin if no health<br />
checking policy is configured.</p>

</td>
</tr>
<tr id="LoadBalancerSettings-SimpleLB-PASSTHROUGH">
<td><code>PASSTHROUGH</code></td>
<td>
<p>This option will forward the connection to the original IP address<br />
requested by the caller without doing any form of load<br />
balancing. This option must be used with care. It is meant for<br />
advanced use cases. Refer to Original Destination load balancer in<br />
Envoy for further details.</p>

</td>
</tr>
<tr id="LoadBalancerSettings-SimpleLB-ROUND_ROBIN">
<td><code>ROUND_ROBIN</code></td>
<td>
<p>A basic round robin load balancing policy. This is generally unsafe<br />
for many scenarios (e.g. when enpoint weighting is used) as it can<br />
overburden endpoints. In general, prefer to use LEAST_REQUEST as a<br />
drop-in replacement for ROUND_ROBIN.</p>

</td>
</tr>
<tr id="LoadBalancerSettings-SimpleLB-LEAST_REQUEST">
<td><code>LEAST_REQUEST</code></td>
<td>
<p>The least request load balancer spreads load across endpoints, favoring<br />
endpoints with the least outstanding requests. This is generally safer<br />
and outperforms ROUND_ROBIN in nearly all cases. Prefer to use<br />
LEAST_REQUEST as a drop-in replacement for ROUND_ROBIN.</p>

</td>
</tr>
<tr id="LoadBalancerSettings-SimpleLB-LEAST_CONN" class="deprecated ">
<td><code>LEAST_CONN</code></td>
<td>
<p>Deprecated. Use LEAST_REQUEST instead.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ConnectionPoolSettings-HTTPSettings-H2UpgradePolicy">ConnectionPoolSettings.HTTPSettings.H2UpgradePolicy</h2>
<section>
<p>Policy for upgrading http1.1 connections to http2.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="ConnectionPoolSettings-HTTPSettings-H2UpgradePolicy-DEFAULT">
<td><code>DEFAULT</code></td>
<td>
<p>Use the global default.</p>

</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-H2UpgradePolicy-DO_NOT_UPGRADE">
<td><code>DO_NOT_UPGRADE</code></td>
<td>
<p>Do not upgrade the connection to http2.<br />
This opt-out option overrides the default.</p>

</td>
</tr>
<tr id="ConnectionPoolSettings-HTTPSettings-H2UpgradePolicy-UPGRADE">
<td><code>UPGRADE</code></td>
<td>
<p>Upgrade the connection to http2.<br />
This opt-in option overrides the default.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="ClientTLSSettings-TLSmode">ClientTLSSettings.TLSmode</h2>
<section>
<p>TLS connection mode</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="ClientTLSSettings-TLSmode-DISABLE">
<td><code>DISABLE</code></td>
<td>
<p>Do not setup a TLS connection to the upstream endpoint.</p>

</td>
</tr>
<tr id="ClientTLSSettings-TLSmode-SIMPLE">
<td><code>SIMPLE</code></td>
<td>
<p>Originate a TLS connection to the upstream endpoint.</p>

</td>
</tr>
<tr id="ClientTLSSettings-TLSmode-MUTUAL">
<td><code>MUTUAL</code></td>
<td>
<p>Secure connections to the upstream using mutual TLS by presenting<br />
client certificates for authentication.</p>

</td>
</tr>
<tr id="ClientTLSSettings-TLSmode-ISTIO_MUTUAL">
<td><code>ISTIO_MUTUAL</code></td>
<td>
<p>Secure connections to the upstream using mutual TLS by presenting<br />
client certificates for authentication.<br />
Compared to Mutual mode, this mode uses certificates generated<br />
automatically by Istio for mTLS authentication. When this mode is<br />
used, all other fields in <code>ClientTLSSettings</code> should be empty.</p>

</td>
</tr>
</tbody>
</table>
</section>
