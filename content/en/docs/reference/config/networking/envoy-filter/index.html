---
WARNING: THIS IS AN AUTO-GENERATED FILE, DO NOT EDIT. PLEASE MODIFY THE ORIGINAL SOURCE IN THE 'https://github.com/ericvn/api' REPO
source_repo: https://github.com/ericvn/api
title: Envoy Filter
description: Customizing Envoy configuration generated by Istio.
location: https://istio.io/docs/reference/config/networking/envoy-filter.html
layout: partner-component
generator: protoc-gen-docs
schema: istio.networking.v1alpha3.EnvoyFilter
aliases: [/docs/reference/config/networking/v1alpha3/envoy-filter]
number_of_entries: 18
---
<p><code>EnvoyFilter</code> provides a mechanism to customize the Envoy<br />
configuration generated by Istio Pilot. Use EnvoyFilter to modify<br />
values for certain fields, add specific filters, or even add<br />
entirely new listeners, clusters, etc. This feature must be used<br />
with care, as incorrect configurations could potentially<br />
destabilize the entire mesh. Unlike other Istio networking objects,<br />
EnvoyFilters are additively applied. Any number of EnvoyFilters can<br />
exist for a given workload in a specific namespace. The order of<br />
application of these EnvoyFilters is as follows: all EnvoyFilters<br />
in the config <a href="/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig">root<br />
namespace</a>,<br />
followed by all matching EnvoyFilters in the workload's namespace.</p>
<p><strong>NOTE 1</strong>: Some aspects of this API are deeply tied to the internal<br />
implementation in Istio networking subsystem as well as Envoy's XDS<br />
API. While the EnvoyFilter API by itself will maintain backward<br />
compatibility, any envoy configuration provided through this<br />
mechanism should be carefully monitored across Istio proxy version<br />
upgrades, to ensure that deprecated fields are removed and replaced<br />
appropriately.</p>
<p><strong>NOTE 2</strong>: When multiple EnvoyFilters are bound to the same<br />
workload in a given namespace, all patches will be processed<br />
sequentially in order of creation time.  The behavior is undefined<br />
if multiple EnvoyFilter configurations conflict with each other.</p>
<p><strong>NOTE 3</strong>: To apply an EnvoyFilter resource to all workloads<br />
(sidecars and gateways) in the system, define the resource in the<br />
config <a href="/docs/reference/config/istio.mesh.v1alpha1/#MeshConfig">root<br />
namespace</a>,<br />
without a workloadSelector.</p>
<p>The example below declares a global default EnvoyFilter resource in<br />
the root namespace called <code>istio-config</code>, that adds a custom<br />
protocol filter on all sidecars in the system, for outbound port<br />
9307. The filter should be added before the terminating tcp_proxy<br />
filter to take effect. In addition, it sets a 30s idle timeout for<br />
all HTTP connections in both gateways and sidecars.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: custom-protocol
  namespace: istio-config # as defined in meshConfig resource.
spec:
  configPatches:
  - applyTo: NETWORK_FILTER
    match:
      context: SIDECAR_OUTBOUND # will match outbound listeners in all sidecars
      listener:
        portNumber: 9307
        filterChain:
          filter:
            name: &quot;envoy.filters.network.tcp_proxy&quot;
    patch:
      operation: INSERT_BEFORE
      value:
        # This is the full filter config including the name and typed_config section.
        name: &quot;envoy.extensions.filters.network.mongo_proxy&quot;
        typed_config:
          &quot;@type&quot;: &quot;type.googleapis.com/envoy.extensions.filters.network.mongo_proxy.v3.MongoProxy&quot;
          ...
  - applyTo: NETWORK_FILTER # http connection manager is a filter in Envoy
    match:
      # context omitted so that this applies to both sidecars and gateways
      listener:
        filterChain:
          filter:
            name: &quot;envoy.filters.network.http_connection_manager&quot;
    patch:
      operation: MERGE
      value:
        name: &quot;envoy.filters.network.http_connection_manager&quot;
        typed_config:
          &quot;@type&quot;: &quot;type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&quot;
          common_http_protocol_options:
            idle_timeout: 30s
</code></pre>
<p>The following example enables Envoy's Lua filter for all inbound<br />
HTTP calls arriving at service port 8080 of the reviews service pod<br />
with labels &quot;app: reviews&quot;, in the bookinfo namespace. The lua<br />
filter calls out to an external service internal.org.net:8888 that<br />
requires a special cluster definition in envoy. The cluster is also<br />
added to the sidecar as part of this configuration.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: reviews-lua
  namespace: bookinfo
spec:
  workloadSelector:
    labels:
      app: reviews
  configPatches:
    # The first patch adds the lua filter to the listener/http connection manager
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
      listener:
        portNumber: 8080
        filterChain:
          filter:
            name: &quot;envoy.filters.network.http_connection_manager&quot;
            subFilter:
              name: &quot;envoy.filters.http.router&quot;
    patch:
      operation: INSERT_BEFORE
      value: # lua filter specification
       name: envoy.filters.http.lua
       typed_config:
          &quot;@type&quot;: &quot;type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua&quot;
          inlineCode: |
            function envoy_on_request(request_handle)
              -- Make an HTTP call to an upstream host with the following headers, body, and timeout.
              local headers, body = request_handle:httpCall(
               &quot;lua_cluster&quot;,
               {
                [&quot;:method&quot;] = &quot;POST&quot;,
                [&quot;:path&quot;] = &quot;/acl&quot;,
                [&quot;:authority&quot;] = &quot;internal.org.net&quot;
               },
              &quot;authorize call&quot;,
              5000)
            end
  # The second patch adds the cluster that is referenced by the lua code
  # cds match is omitted as a new cluster is being added
  - applyTo: CLUSTER
    match:
      context: SIDECAR_OUTBOUND
    patch:
      operation: ADD
      value: # cluster specification
        name: &quot;lua_cluster&quot;
        type: STRICT_DNS
        connect_timeout: 0.5s
        lb_policy: ROUND_ROBIN
        load_assignment:
          cluster_name: lua_cluster
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    protocol: TCP
                    address: &quot;internal.org.net&quot;
                    port_value: 8888
</code></pre>
<p>The following example overwrites certain fields (HTTP idle timeout<br />
and X-Forward-For trusted hops) in the HTTP connection manager in a<br />
listener on the ingress gateway in istio-system namespace for the<br />
SNI host app.example.com:</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: hcm-tweaks
  namespace: istio-system
spec:
  workloadSelector:
    labels:
      istio: ingressgateway
  configPatches:
  - applyTo: NETWORK_FILTER # http connection manager is a filter in Envoy
    match:
      context: GATEWAY
      listener:
        filterChain:
          sni: app.example.com
          filter:
            name: &quot;envoy.filters.network.http_connection_manager&quot;
    patch:
      operation: MERGE
      value:
        typed_config:
          &quot;@type&quot;: &quot;type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager&quot;
          xff_num_trusted_hops: 5
          common_http_protocol_options:
            idle_timeout: 30s
</code></pre>
<p>The following example inserts an attributegen filter<br />
that produces <code>istio_operationId</code> attribute which is consumed<br />
by the istio.stats filter. <code>filterClass: STATS</code> encodes this dependency.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: reviews-request-operation
  namespace: myns
spec:
  workloadSelector:
    labels:
      app: reviews
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
    patch:
      operation: ADD
      filterClass: STATS # This filter will run *before* the Istio stats filter.
      value:
        name: istio.request_operation
        typed_config:
         &quot;@type&quot;: type.googleapis.com/udpa.type.v1.TypedStruct
         type_url: type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
         value:
           config:
             configuration: |
               {
                 &quot;attributes&quot;: [
                   {
                     &quot;output_attribute&quot;: &quot;istio_operationId&quot;,
                     &quot;match&quot;: [
                       {
                         &quot;value&quot;: &quot;ListReviews&quot;,
                         &quot;condition&quot;: &quot;request.url_path == '/reviews' &amp;&amp; request.method == 'GET'&quot;
                       }]
                   }]
               }
             vm_config:
               runtime: envoy.wasm.runtime.null
               code:
                 local: { inline_string: &quot;envoy.wasm.attributegen&quot; }
</code></pre>
<p>The following example inserts an http ext_authz filter in the <code>myns</code> namespace.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: myns-ext-authz
  namespace: myns
spec:
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
    patch:
      operation: ADD
      filterClass: AUTHZ # This filter will run *after* the Istio authz filter.
      value:
        name: envoy.filters.http.ext_authz
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
          grpc_service:
            envoy_grpc:
              cluster_name: acme-ext-authz
            initial_metadata:
            - key: foo
              value: myauth.acme # required by local ext auth server.
</code></pre>
<p>A workload in the <code>myns</code> namespace needs to access a different ext_auth server<br />
that does not accept initial metadata. Since proto merge cannot remove fields, the<br />
following configuration uses the <code>REPLACE</code> operation. If you do not need to inherit<br />
fields, REPLACE is preferred over MERGE.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: mysvc-ext-authz
  namespace: myns
spec:
  workloadSelector:
    labels:
      app: mysvc
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: SIDECAR_INBOUND
    patch:
      operation: REPLACE
      value:
        name: envoy.filters.http.ext_authz
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
          grpc_service:
            envoy_grpc:
              cluster_name: acme-ext-authz-alt
</code></pre>
<p>The following example deploys a Wasm extension for all inbound sidecar HTTP requests.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: wasm-example
  namespace: myns
spec:
  configPatches:
  # The first patch defines a named Wasm extension and provides a URL to fetch Wasm binary from,
  # and the binary configuration. It should come before the next patch that applies it.
  # This resource is visible to all proxies in the namespace &quot;myns&quot;. It is possible to provide
  # multiple definitions for the same name &quot;my-wasm-extension&quot; in multiple namespaces. We recommend that:
  # - if overriding is desired, then the root level definition can be overriden per namespace with REPLACE.
  # - if overriding is not desired, then the name should be qualified with the namespace &quot;myns/my-wasm-extension&quot;,
  #   to avoid accidental name collisions.
  - applyTo: EXTENSION_CONFIG
    patch:
      operation: ADD # REPLACE is also supported, and would override a cluster level resource with the same name.
      value:
        name: my-wasm-extension
        typed_config:
          &quot;@type&quot;: type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm
          config:
            root_id: my-wasm-root-id
            vm_config:
              vm_id: my-wasm-vm-id
              runtime: envoy.wasm.runtime.v8
              code:
                remote:
                  http_uri:
                    uri: http://my-wasm-binary-uri
            configuration:
              &quot;@type&quot;: &quot;type.googleapis.com/google.protobuf.StringValue&quot;
              value: |
                {}
  # The second patch instructs to apply the above Wasm filter to the listener/http connection manager.
  - applyTo: HTTP_FILTER
    match:
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router
    patch:
      operation: INSERT_BEFORE
      value:
        name: my-wasm-extension # This must match the name above
        config_discovery:
          config_source:
            ads: {}
          type_urls: [&quot;type.googleapis.com/envoy.extensions.filters.http.wasm.v3.Wasm&quot;]
</code></pre>
<p>The following example adds a Wasm service extension for all proxies using a locally available Wasm file.<br />
The singleton Wasm extension is used to maintain a shared state between workers executing Wasm filters.<br />
For example, a local rate limit extension would rely on a singleton to limit requests across all workers.<br />
As another example, an authorization Wasm extension can use a singleton to maintain a database of accounts.</p>
<pre><code class="language-yaml">apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: wasm-service
  namespace: myns
spec:
  configPatches:
  - applyTo: BOOTSTRAP
    patch:
      operation: MERGE
      value:
        bootstrap_extensions:
        - name: envoy.bootstrap.wasm
          typed_config:
            &quot;@type&quot;: type.googleapis.com/envoy.extensions.wasm.v3.WasmService
            singleton: true
            config:
              name: my_plugin
              configuration:
                &quot;@type&quot;: type.googleapis.com/google.protobuf.StringValue
                value: |
                  {}
              vm_config:
                runtime: &quot;envoy.wasm.runtime.v8&quot;
                code:
                  local:
                    filename: &quot;/etc/envoy_filter_http_wasm_example.wasm&quot;
</code></pre>

<h2 id="EnvoyFilter">EnvoyFilter</h2>
<section>
<p>EnvoyFilter provides a mechanism to customize the Envoy configuration<br />
generated by Istio Pilot.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-workload_selector">
<td><code>workloadSelector</code></td>
<td><code><a href="/docs/reference/config/networking/sidecar/#WorkloadSelector">WorkloadSelector</a></code></td>
<td>
<p>Criteria used to select the specific set of pods/VMs on which<br />
this patch configuration should be applied. If omitted, the set<br />
of patches in this configuration will be applied to all workload<br />
instances in the same namespace.  If omitted, the <code>EnvoyFilter</code><br />
patches will be applied to all workloads in the same<br />
namespace. If the <code>EnvoyFilter</code> is present in the config root<br />
namespace, it will be applied to all applicable workloads in any<br />
namespace.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-config_patches">
<td><code>configPatches</code></td>
<td><code><a href="#EnvoyFilter-EnvoyConfigObjectPatch">EnvoyConfigObjectPatch[]</a></code></td>
<td>
<p>One or more patches with match conditions.</p>

</td>
<td>
Yes
</td>
</tr>
<tr id="EnvoyFilter-priority">
<td><code>priority</code></td>
<td><code>int32</code></td>
<td>
<p>Priority defines the order in which patch sets are applied within a context.<br />
When one patch depends on another patch, the order of patch application<br />
is significant. The API provides two primary ways to order patches.<br />
Patch sets in the root namespace are applied before the patch sets in the<br />
workload namespace. Patches within a patch set are processed in the order<br />
that they appear in the <code>configPatches</code> list.</p>
<p>The default value for priority is 0 and the range is [ min-int32, max-int32 ].<br />
A patch set with a negative priority is processed before the default. A patch<br />
set with a positive priority is processed after the default.</p>
<p>It is recommended to start with priority values that are multiples of 10<br />
to leave room for further insertion.</p>
<p>Patch sets are sorted in the following ascending key order:<br />
priority, creation time, fully qualified resource name.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ProxyMatch">EnvoyFilter.ProxyMatch</h2>
<section>
<p>One or more properties of the proxy to match on.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ProxyMatch-proxy_version">
<td><code>proxyVersion</code></td>
<td><code>string</code></td>
<td>
<p>A regular expression in golang regex format (RE2) that can be<br />
used to select proxies using a specific version of istio<br />
proxy. The Istio version for a given proxy is obtained from the<br />
node metadata field <code>ISTIO_VERSION</code> supplied by the proxy when<br />
connecting to Pilot. This value is embedded as an environment<br />
variable (<code>ISTIO_META_ISTIO_VERSION</code>) in the Istio proxy docker<br />
image. Custom proxy implementations should provide this metadata<br />
variable to take advantage of the Istio version check option.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ProxyMatch-metadata">
<td><code>metadata</code></td>
<td><code>map&lt;string,&nbsp;string&gt;</code></td>
<td>
<p>Match on the node metadata supplied by a proxy when connecting<br />
to Istio Pilot. Note that while Envoy's node metadata is of<br />
type Struct, only string key-value pairs are processed by<br />
Pilot. All keys specified in the metadata must match with exact<br />
values. The match will fail if any of the specified keys are<br />
absent or the values fail to match.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ClusterMatch">EnvoyFilter.ClusterMatch</h2>
<section>
<p>Conditions specified in <code>ClusterMatch</code> must be met for the patch<br />
to be applied to a cluster.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ClusterMatch-port_number">
<td><code>portNumber</code></td>
<td><code>uint32</code></td>
<td>
<p>The service port for which this cluster was generated.  If<br />
omitted, applies to clusters for any port.<br />
<strong>Note:</strong> for inbound cluster, it is the service target port.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ClusterMatch-service">
<td><code>service</code></td>
<td><code>string</code></td>
<td>
<p>The fully qualified service name for this cluster. If omitted,<br />
applies to clusters for any service. For services defined<br />
through service entries, the service name is same as the hosts<br />
defined in the service entry.<br />
<strong>Note:</strong> for inbound cluster, this is ignored.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ClusterMatch-subset">
<td><code>subset</code></td>
<td><code>string</code></td>
<td>
<p>The subset associated with the service. If omitted, applies to<br />
clusters for any subset of a service.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ClusterMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>The exact name of the cluster to match. To match a specific<br />
cluster by name, such as the internally generated <code>Passthrough</code><br />
cluster, leave all fields in clusterMatch empty, except the<br />
name.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-RouteConfigurationMatch">EnvoyFilter.RouteConfigurationMatch</h2>
<section>
<p>Conditions specified in RouteConfigurationMatch must be met for<br />
the patch to be applied to a route configuration object or a<br />
specific virtual host within the route configuration.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-RouteConfigurationMatch-port_number">
<td><code>portNumber</code></td>
<td><code>uint32</code></td>
<td>
<p>The service port number or gateway server port number for which<br />
this route configuration was generated. If omitted, applies to<br />
route configurations for all ports.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-port_name">
<td><code>portName</code></td>
<td><code>string</code></td>
<td>
<p>Applicable only for GATEWAY context. The gateway server port<br />
name for which this route configuration was generated.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-gateway">
<td><code>gateway</code></td>
<td><code>string</code></td>
<td>
<p>The Istio gateway config's namespace/name for which this route<br />
configuration was generated. Applies only if the context is<br />
GATEWAY. Should be in the namespace/name format. Use this field<br />
in conjunction with the <code>portNumber</code> and <code>portName</code> to accurately<br />
select the Envoy route configuration for a specific HTTPS<br />
server within a gateway config object.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-vhost">
<td><code>vhost</code></td>
<td><code><a href="#EnvoyFilter-RouteConfigurationMatch-VirtualHostMatch">VirtualHostMatch</a></code></td>
<td>
<p>Match a specific virtual host in a route configuration and<br />
apply the patch to the virtual host.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>Route configuration name to match on. Can be used to match a<br />
specific route configuration by name, such as the internally<br />
generated <code>http_proxy</code> route configuration for all sidecars.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ListenerMatch">EnvoyFilter.ListenerMatch</h2>
<section>
<p>Conditions specified in a listener match must be met for the<br />
patch to be applied to a specific listener across all filter<br />
chains, or a specific filter chain inside the listener.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ListenerMatch-port_number">
<td><code>portNumber</code></td>
<td><code>uint32</code></td>
<td>
<p>The service port/gateway port to which traffic is being<br />
sent/received. If not specified, matches all listeners. Even though<br />
inbound listeners are generated for the instance/pod ports, only<br />
service ports should be used to match listeners.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-filter_chain">
<td><code>filterChain</code></td>
<td><code><a href="#EnvoyFilter-ListenerMatch-FilterChainMatch">FilterChainMatch</a></code></td>
<td>
<p>Match a specific filter chain in a listener. If specified, the<br />
patch will be applied to the filter chain (and a specific<br />
filter if specified) and not to other filter chains in the<br />
listener.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>Match a specific listener by its name. The listeners generated<br />
by Pilot are typically named as IP:Port.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-Patch">EnvoyFilter.Patch</h2>
<section>
<p>Patch specifies how the selected object should be modified.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-Patch-operation">
<td><code>operation</code></td>
<td><code><a href="#EnvoyFilter-Patch-Operation">Operation</a></code></td>
<td>
<p>Determines how the patch should be applied.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-Patch-value">
<td><code>value</code></td>
<td><code><a href="https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#struct">Struct</a></code></td>
<td>
<p>The JSON config of the object being patched. This will be merged using<br />
proto merge semantics with the existing proto in the path.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-Patch-filter_class">
<td><code>filterClass</code></td>
<td><code><a href="#EnvoyFilter-Patch-FilterClass">FilterClass</a></code></td>
<td>
<p>Determines the filter insertion order.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-EnvoyConfigObjectMatch">EnvoyFilter.EnvoyConfigObjectMatch</h2>
<section>
<p>One or more match conditions to be met before a patch is applied<br />
to the generated configuration for a given proxy.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-EnvoyConfigObjectMatch-context">
<td><code>context</code></td>
<td><code><a href="#EnvoyFilter-PatchContext">PatchContext</a></code></td>
<td>
<p>The specific config generation context to match on. Istio Pilot<br />
generates envoy configuration in the context of a gateway,<br />
inbound traffic to sidecar and outbound traffic from sidecar.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-EnvoyConfigObjectMatch-proxy">
<td><code>proxy</code></td>
<td><code><a href="#EnvoyFilter-ProxyMatch">ProxyMatch</a></code></td>
<td>
<p>Match on properties associated with a proxy.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-EnvoyConfigObjectMatch-listener" class="oneof oneof-start">
<td><code>listener</code></td>
<td><code><a href="#EnvoyFilter-ListenerMatch">ListenerMatch (oneof)</a></code></td>
<td>
<p>Match on envoy listener attributes.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-EnvoyConfigObjectMatch-route_configuration" class="oneof">
<td><code>routeConfiguration</code></td>
<td><code><a href="#EnvoyFilter-RouteConfigurationMatch">RouteConfigurationMatch (oneof)</a></code></td>
<td>
<p>Match on envoy HTTP route configuration attributes.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-EnvoyConfigObjectMatch-cluster" class="oneof">
<td><code>cluster</code></td>
<td><code><a href="#EnvoyFilter-ClusterMatch">ClusterMatch (oneof)</a></code></td>
<td>
<p>Match on envoy cluster attributes.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-EnvoyConfigObjectPatch">EnvoyFilter.EnvoyConfigObjectPatch</h2>
<section>
<p>Changes to be made to various envoy config objects.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-EnvoyConfigObjectPatch-apply_to">
<td><code>applyTo</code></td>
<td><code><a href="#EnvoyFilter-ApplyTo">ApplyTo</a></code></td>
<td>
<p>Specifies where in the Envoy configuration, the patch should be<br />
applied.  The match is expected to select the appropriate<br />
object based on applyTo.  For example, an applyTo with<br />
<code>HTTP_FILTER</code> is expected to have a match condition on the<br />
listeners, with a network filter selection on<br />
<code>envoy.filters.network.http_connection_manager</code> and a sub filter selection on the<br />
HTTP filter relative to which the insertion should be<br />
performed. Similarly, an applyTo on <code>CLUSTER</code> should have a match<br />
(if provided) on the cluster and not on a listener.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-EnvoyConfigObjectPatch-match">
<td><code>match</code></td>
<td><code><a href="#EnvoyFilter-EnvoyConfigObjectMatch">EnvoyConfigObjectMatch</a></code></td>
<td>
<p>Match on listener/route configuration/cluster.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-EnvoyConfigObjectPatch-patch">
<td><code>patch</code></td>
<td><code><a href="#EnvoyFilter-Patch">Patch</a></code></td>
<td>
<p>The patch to apply along with the operation.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-RouteConfigurationMatch-RouteMatch">EnvoyFilter.RouteConfigurationMatch.RouteMatch</h2>
<section>
<p>Match a specific route inside a virtual host in a route configuration.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>The Route objects generated by default are named as<br />
default.  Route objects generated using a virtual service<br />
will carry the name used in the virtual service's HTTP<br />
routes.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-action">
<td><code>action</code></td>
<td><code><a href="#EnvoyFilter-RouteConfigurationMatch-RouteMatch-Action">Action</a></code></td>
<td>
<p>Match a route with specific action type.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-RouteConfigurationMatch-VirtualHostMatch">EnvoyFilter.RouteConfigurationMatch.VirtualHostMatch</h2>
<section>
<p>Match a specific virtual host inside a route configuration.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-RouteConfigurationMatch-VirtualHostMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>The VirtualHosts objects generated by Istio are named as<br />
host:port, where the host typically corresponds to the<br />
VirtualService's host field or the hostname of a service in the<br />
registry.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-VirtualHostMatch-route">
<td><code>route</code></td>
<td><code><a href="#EnvoyFilter-RouteConfigurationMatch-RouteMatch">RouteMatch</a></code></td>
<td>
<p>Match a specific route within the virtual host.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ListenerMatch-FilterChainMatch">EnvoyFilter.ListenerMatch.FilterChainMatch</h2>
<section>
<p>For listeners with multiple filter chains (e.g., inbound<br />
listeners on sidecars with permissive mTLS, gateway listeners<br />
with multiple SNI matches), the filter chain match can be used<br />
to select a specific filter chain to patch.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ListenerMatch-FilterChainMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>The name assigned to the filter chain.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-FilterChainMatch-sni">
<td><code>sni</code></td>
<td><code>string</code></td>
<td>
<p>The SNI value used by a filter chain's match condition.  This<br />
condition will evaluate to false if the filter chain has no<br />
sni match.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-FilterChainMatch-transport_protocol">
<td><code>transportProtocol</code></td>
<td><code>string</code></td>
<td>
<p>Applies only to <code>SIDECAR_INBOUND</code> context. If non-empty, a<br />
transport protocol to consider when determining a filter<br />
chain match.  This value will be compared against the<br />
transport protocol of a new connection, when it's detected by<br />
the <code>tls_inspector</code> listener filter.</p>
<p>Accepted values include:</p>
<ul>
<li><code>raw_buffer</code> - default, used when no transport protocol is detected.</li>
<li><code>tls</code> - set when TLS protocol is detected by the TLS inspector.</li>
</ul>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-FilterChainMatch-application_protocols">
<td><code>applicationProtocols</code></td>
<td><code>string</code></td>
<td>
<p>Applies only to sidecars. If non-empty, a comma separated set<br />
of application protocols to consider when determining a<br />
filter chain match.  This value will be compared against the<br />
application protocols of a new connection, when it's detected<br />
by one of the listener filters such as the <code>http_inspector</code>.</p>
<p>Accepted values include: h2, http/1.1, http/1.0</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-FilterChainMatch-filter">
<td><code>filter</code></td>
<td><code><a href="#EnvoyFilter-ListenerMatch-FilterMatch">FilterMatch</a></code></td>
<td>
<p>The name of a specific filter to apply the patch to. Set this<br />
to <code>envoy.filters.network.http_connection_manager</code> to add a filter or apply a<br />
patch to the HTTP connection manager.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-FilterChainMatch-destination_port">
<td><code>destinationPort</code></td>
<td><code>uint32</code></td>
<td>
<p>The destination_port value used by a filter chain's match condition.<br />
This condition will evaluate to false if the filter chain has no destination_port match.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ListenerMatch-FilterMatch">EnvoyFilter.ListenerMatch.FilterMatch</h2>
<section>
<p>Conditions to match a specific filter within a filter chain.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ListenerMatch-FilterMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>The filter name to match on.<br />
For standard Envoy filters, <a href="https://www.envoyproxy.io/docs/envoy/latest/version_history/v1.14.0#deprecated">canonical filter</a><br />
names should be used.</p>

</td>
<td>
No
</td>
</tr>
<tr id="EnvoyFilter-ListenerMatch-FilterMatch-sub_filter">
<td><code>subFilter</code></td>
<td><code><a href="#EnvoyFilter-ListenerMatch-SubFilterMatch">SubFilterMatch</a></code></td>
<td>
<p>The next level filter within this filter to match<br />
upon. Typically used for HTTP Connection Manager filters and<br />
Thrift filters.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ListenerMatch-SubFilterMatch">EnvoyFilter.ListenerMatch.SubFilterMatch</h2>
<section>
<p>Conditions to match a specific filter within another<br />
filter. This field is typically useful to match a HTTP filter<br />
inside the <code>envoy.filters.network.http_connection_manager</code> network filter.<br />
This could also be applicable for thrift filters.</p>

<table class="message-fields">
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Description</th>
<th>Required</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ListenerMatch-SubFilterMatch-name">
<td><code>name</code></td>
<td><code>string</code></td>
<td>
<p>The filter name to match on.</p>

</td>
<td>
No
</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-Action">EnvoyFilter.RouteConfigurationMatch.RouteMatch.Action</h2>
<section>
<p>Action refers to the route action taken by Envoy when a http route matches.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-Action-ANY">
<td><code>ANY</code></td>
<td>
<p>All three route actions</p>

</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-Action-ROUTE">
<td><code>ROUTE</code></td>
<td>
<p>Route traffic to a cluster / weighted clusters.</p>

</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-Action-REDIRECT">
<td><code>REDIRECT</code></td>
<td>
<p>Redirect request.</p>

</td>
</tr>
<tr id="EnvoyFilter-RouteConfigurationMatch-RouteMatch-Action-DIRECT_RESPONSE">
<td><code>DIRECT_RESPONSE</code></td>
<td>
<p>directly respond to a request with specific payload.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-Patch-Operation">EnvoyFilter.Patch.Operation</h2>
<section>
<p>Operation denotes how the patch should be applied to the selected<br />
configuration.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-Patch-Operation-INVALID">
<td><code>INVALID</code></td>
<td>
</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-MERGE">
<td><code>MERGE</code></td>
<td>
<p>Merge the provided config with the generated config using<br />
proto merge semantics. If you are specifying config in its<br />
entirety, use <code>REPLACE</code> instead.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-ADD">
<td><code>ADD</code></td>
<td>
<p>Add the provided config to an existing list (of listeners,<br />
clusters, virtual hosts, network filters, or http<br />
filters). This operation will be ignored when <code>applyTo</code> is set<br />
to <code>ROUTE_CONFIGURATION</code>, or <code>HTTP_ROUTE</code>.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-REMOVE">
<td><code>REMOVE</code></td>
<td>
<p>Remove the selected object from the list (of listeners,<br />
clusters, virtual hosts, network filters, routes, or http<br />
filters). Does not require a value to be specified. This<br />
operation will be ignored when <code>applyTo</code> is set to<br />
<code>ROUTE_CONFIGURATION</code>, or <code>HTTP_ROUTE</code>.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-INSERT_BEFORE">
<td><code>INSERT_BEFORE</code></td>
<td>
<p>Insert operation on an array of named objects. This operation<br />
is typically useful only in the context of filters or routes,<br />
where the order of elements matter. Routes should be ordered<br />
based on most to least specific matching criteria since the<br />
first matching element is selected. For clusters and virtual hosts,<br />
order of the element in the array does not matter. Insert<br />
before the selected filter or sub filter. If no filter is<br />
selected, the specified filter will be inserted at the front<br />
of the list.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-INSERT_AFTER">
<td><code>INSERT_AFTER</code></td>
<td>
<p>Insert operation on an array of named objects. This operation<br />
is typically useful only in the context of filters or routes,<br />
where the order of elements matter. Routes should be ordered<br />
based on most to least specific matching criteria since the<br />
first matching element is selected. For clusters and virtual hosts,<br />
order of the element in the array does not matter. Insert<br />
after the selected filter or sub filter. If no filter is<br />
selected, the specified filter will be inserted at the end<br />
of the list.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-INSERT_FIRST">
<td><code>INSERT_FIRST</code></td>
<td>
<p>Insert operation on an array of named objects. This operation<br />
is typically useful only in the context of filters or routes,<br />
where the order of elements matter. Routes should be ordered<br />
based on most to least specific matching criteria since the<br />
first matching element is selected. For clusters and virtual hosts,<br />
order of the element in the array does not matter. Insert<br />
first in the list based on the presence of selected filter or not.<br />
This is specifically useful when you want your filter first in the<br />
list based on a match condition specified in Match clause.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-Operation-REPLACE">
<td><code>REPLACE</code></td>
<td>
<p>Replace contents of a named filter with new contents.<br />
<code>REPLACE</code> operation is only valid for <code>HTTP_FILTER</code> and<br />
<code>NETWORK_FILTER</code>. If the named filter is not found, this operation<br />
has no effect.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-Patch-FilterClass">EnvoyFilter.Patch.FilterClass</h2>
<section>
<p>FilterClass determines the filter insertion point in the filter chain<br />
relative to the filters implicitly inserted by the control plane.<br />
It is used in conjuction with the <code>ADD</code> operation.<br />
This is the preferred insertion mechanism for adding filters over<br />
the <code>INSERT_*</code> operations since those operations rely on potentially unstable<br />
filter names.<br />
Filter ordering is important if your filter depends on or affects the<br />
functioning of a another filter in the filter chain.<br />
Within a filter class, filters are inserted in the order of processing.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-Patch-FilterClass-UNSPECIFIED">
<td><code>UNSPECIFIED</code></td>
<td>
<p>Control plane decides where to insert the filter.<br />
Do not specify <code>FilterClass</code> if the filter is independent of others.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-FilterClass-AUTHN">
<td><code>AUTHN</code></td>
<td>
<p>Insert filter after Istio authentication filters.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-FilterClass-AUTHZ">
<td><code>AUTHZ</code></td>
<td>
<p>Insert filter after Istio authorization filters.</p>

</td>
</tr>
<tr id="EnvoyFilter-Patch-FilterClass-STATS">
<td><code>STATS</code></td>
<td>
<p>Insert filter before Istio stats filters.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-ApplyTo">EnvoyFilter.ApplyTo</h2>
<section>
<p><code>ApplyTo</code> specifies where in the Envoy configuration, the given patch should be applied.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-ApplyTo-INVALID">
<td><code>INVALID</code></td>
<td>
</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-LISTENER">
<td><code>LISTENER</code></td>
<td>
<p>Applies the patch to the listener.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-FILTER_CHAIN">
<td><code>FILTER_CHAIN</code></td>
<td>
<p>Applies the patch to the filter chain.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-NETWORK_FILTER">
<td><code>NETWORK_FILTER</code></td>
<td>
<p>Applies the patch to the network filter chain, to modify an<br />
existing filter or add a new filter.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-HTTP_FILTER">
<td><code>HTTP_FILTER</code></td>
<td>
<p>Applies the patch to the HTTP filter chain in the http<br />
connection manager, to modify an existing filter or add a new<br />
filter.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-ROUTE_CONFIGURATION">
<td><code>ROUTE_CONFIGURATION</code></td>
<td>
<p>Applies the patch to the Route configuration (rds output)<br />
inside a HTTP connection manager. This does not apply to the<br />
virtual host. Currently, only <code>MERGE</code> operation is allowed on the<br />
route configuration objects.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-VIRTUAL_HOST">
<td><code>VIRTUAL_HOST</code></td>
<td>
<p>Applies the patch to a virtual host inside a route configuration.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-HTTP_ROUTE">
<td><code>HTTP_ROUTE</code></td>
<td>
<p>Applies the patch to a route object inside the matched virtual<br />
host in a route configuration.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-CLUSTER">
<td><code>CLUSTER</code></td>
<td>
<p>Applies the patch to a cluster in a CDS output. Also used to add new clusters.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-EXTENSION_CONFIG">
<td><code>EXTENSION_CONFIG</code></td>
<td>
<p>Applies the patch to or adds an extension config in ECDS output. Note that ECDS<br />
is only supported by HTTP filters.</p>

</td>
</tr>
<tr id="EnvoyFilter-ApplyTo-BOOTSTRAP">
<td><code>BOOTSTRAP</code></td>
<td>
<p>Applies the patch to bootstrap configuration.</p>

</td>
</tr>
</tbody>
</table>
</section>
<h2 id="EnvoyFilter-PatchContext">EnvoyFilter.PatchContext</h2>
<section>
<p>PatchContext selects a class of configurations based on the<br />
traffic flow direction and workload type.</p>

<table class="enum-values">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr id="EnvoyFilter-PatchContext-ANY">
<td><code>ANY</code></td>
<td>
<p>All listeners/routes/clusters in both sidecars and gateways.</p>

</td>
</tr>
<tr id="EnvoyFilter-PatchContext-SIDECAR_INBOUND">
<td><code>SIDECAR_INBOUND</code></td>
<td>
<p>Inbound listener/route/cluster in sidecar.</p>

</td>
</tr>
<tr id="EnvoyFilter-PatchContext-SIDECAR_OUTBOUND">
<td><code>SIDECAR_OUTBOUND</code></td>
<td>
<p>Outbound listener/route/cluster in sidecar.</p>

</td>
</tr>
<tr id="EnvoyFilter-PatchContext-GATEWAY">
<td><code>GATEWAY</code></td>
<td>
<p>Gateway listener/route/cluster.</p>

</td>
</tr>
</tbody>
</table>
</section>
